diff -Nur hmmer-3.3.orig/easel/esl_fileparser.c hmmer-3.3/easel/esl_fileparser.c
--- hmmer-3.3.orig/easel/esl_fileparser.c	2019-11-18 14:23:44.000000000 +0100
+++ hmmer-3.3/easel/esl_fileparser.c	2019-12-06 15:39:25.112539155 +0100
@@ -499,6 +499,37 @@
   esl_fileparser_Destroy(efp);
 }
 
+/* Function:  esl_fileparser_Reset()
+ * Incept:    
+ *
+ * Purpose:   Resets an open <ESL_FILEPARSER> for reuse
+ * 
+ */
+void
+esl_fileparser_Reset(ESL_FILEPARSER *efp)
+{
+  if (efp == NULL) return;
+
+  if (efp->fp != NULL && efp->fp != stdin) fseeko(efp->fp, 0, SEEK_SET);
+  if (efp->buf != NULL) free(efp->buf);
+
+  efp->buf         = NULL;
+  efp->buflen      = 0;
+  efp->s           = NULL;
+  efp->commentchar = '\0';
+  efp->tok         = NULL;
+  efp->toklen      = 0;
+  efp->tokchar     = '\0';
+  efp->filename    = NULL;
+  efp->linenumber  = 0;
+  efp->errbuf[0]   = '\0';
+  efp->is_buffer   = FALSE;
+  efp->mem_buffer  = NULL;
+  efp->mem_size    = 0;
+  efp->mem_pos     = 0;
+
+}
+
 
 
 /*****************************************************************
diff -Nur hmmer-3.3.orig/easel/esl_fileparser.c.orig hmmer-3.3/easel/esl_fileparser.c.orig
--- hmmer-3.3.orig/easel/esl_fileparser.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ hmmer-3.3/easel/esl_fileparser.c.orig	2019-11-18 14:23:44.000000000 +0100
@@ -0,0 +1,794 @@
+/* A simple token-based file parsing system.
+ * 
+ * Contents:
+ *    1. The ESL_FILEPARSER object and its API.
+ *    2. Private functions.
+ *    3. Unit tests.
+ *    4. Test driver.
+ *    5. Examples.
+ */
+#include "esl_config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "easel.h"
+#include "esl_fileparser.h"
+
+static int nextline(ESL_FILEPARSER *efp);
+
+/*****************************************************************
+ * 1. The ESL_FILEPARSER object and its API.
+ *****************************************************************/
+
+/* Function:  esl_fileparser_Open()
+ * Incept:    SRE, Tue Apr  3 08:09:56 2007 [Janelia]
+ *
+ * Purpose:   Opens <filename> for reading. 
+ * 
+ *            As a special case, if <filename> is "-", set up the
+ *            fileparser to read and parse <stdin>.
+ *            
+ *            <envvar> is optional name of an environment variable,
+ *            such as <BLASTDB>. This environment variable contains a
+ *            colon-delimited list of directories in which the
+ *            <filename> may lie relative to.  We looks first relative
+ *            to the current working directory, then in any
+ *            directories specified by <envvar>. If <envvar> is <NULL>,
+ *            we only look in the current working directory.
+ *            
+ * Args:      filename  - filename, relative path, or fully qualified path
+ *            envvar    - optional environment variable name to find 
+ *                        colon-delimited list of directories <filename>
+ *                        may reside in; or <NULL>
+ *            ret_efp   - RETURN: opened <ESL_FILEPARSER>            
+ *
+ * Returns:   <eslOK> on success, and <ret_fp> points
+ *            to a new <ESL_FILEPARSER> object.
+ *            
+ *            Returns <eslENOTFOUND> if <filename> can't
+ *            be opened for reading, and <ret_fp> is set
+ *            to <NULL>.
+ *
+ * Throws:    <eslEMEM> on allocation failure.
+ */
+int
+esl_fileparser_Open(const char *filename, const char *envvar, ESL_FILEPARSER **ret_efp)
+{
+  int             status;
+  ESL_FILEPARSER *efp = NULL;
+
+  if ((efp = esl_fileparser_Create(NULL)) == NULL) { status = eslEMEM;      goto ERROR; }
+
+  if (strcmp(filename, "-") == 0) 
+    efp->fp = stdin;
+  else if ((efp->fp = fopen(filename, "r")) != NULL) { 
+    if ((status  = esl_strdup(filename, -1, &(efp->filename))) != eslOK) goto ERROR;
+  }
+  else if ((status = esl_FileEnvOpen(filename, envvar, &(efp->fp), &(efp->filename))) != eslOK) 
+    { status = eslENOTFOUND; goto ERROR; }    
+    
+  *ret_efp = efp;
+  return eslOK;
+
+ ERROR:
+  esl_fileparser_Close(efp);
+  *ret_efp = NULL;
+  return status;
+}
+
+
+/* Function:  esl_fileparser_Create()
+ * Incept:    SRE, Fri Jul  9 12:50:29 2004 [St. Louis]
+ *
+ * Purpose:   Take an open file <fp>, and transform it to
+ *            a fileparser object -- preparing to parse it
+ *            one whitespace-delimited field at a time.
+ *
+ * Args:      fp  - open FILE to parse
+ *
+ * Returns:   a new <ESL_FILEPARSER> object, which must be 
+ *            free'd by the caller with <esl_fileparser_Destroy()>.
+ *
+ * Throws:    <eslEMEM> if an allocation failed.
+ *            
+ * Xref:      STL8 p.56.
+ */
+ESL_FILEPARSER *
+esl_fileparser_Create(FILE *fp)
+{
+  int status;
+  ESL_FILEPARSER *efp = NULL;
+
+  ESL_ALLOC(efp, sizeof(ESL_FILEPARSER));
+  efp->fp          = fp;
+  efp->buf         = NULL;
+  efp->buflen      = 0;
+  efp->s           = NULL;
+  efp->commentchar = '\0';
+  efp->filename    = NULL;
+  efp->linenumber  = 0;
+  efp->errbuf[0]   = '\0';
+  efp->is_buffer   = FALSE;
+  efp->mem_buffer  = NULL;
+  efp->mem_size    = 0;
+  efp->mem_pos     = 0;
+  return efp;
+  
+ ERROR:
+  esl_fileparser_Destroy(efp);
+  return NULL;
+}
+
+
+/* Function:  esl_fileparser_CreateMapped()
+ * Incept:    MSF, Mon Aug 16 2010 [Janelia]
+ *
+ * Purpose:   Sets up a memory buffer to be parsed with the
+ *            file parser routines.Take an open file <fp>, and transform it to
+ *            a fileparser object -- preparing to parse it
+ *            one whitespace-delimited field at a time.
+ *
+ * Args:      fp  - open FILE to parse
+ *
+ * Returns:   a new <ESL_FILEPARSER> object, which must be 
+ *            free'd by the caller with <esl_fileparser_Destroy()>.
+ *
+ * Throws:    <eslEMEM> if an allocation failed.
+ *            
+ * Xref:      STL8 p.56.
+ */
+ESL_FILEPARSER *
+esl_fileparser_CreateMapped(const void *buffer, int size)
+{
+  ESL_FILEPARSER *efp = NULL;
+
+  if ((efp = esl_fileparser_Create(NULL)) == NULL) return NULL;
+  
+  efp->is_buffer   = TRUE;
+  efp->mem_buffer  = buffer;
+  efp->mem_size    = size;
+  return efp;
+}
+
+
+
+
+/* Function:  esl_fileparser_SetCommentChar()
+ *
+ * Purpose:   Defines a single character <c> for comments. Anything
+ *            on a line following this character is ignored
+ *            when parsing.
+ *
+ * Args:      efp - open fileparser
+ *            c    - comment character ('#', for example)        
+ *
+ * Returns:   <eslOK> on success.
+ */
+int
+esl_fileparser_SetCommentChar(ESL_FILEPARSER *efp, char c)
+{
+  efp->commentchar = c;
+  return eslOK;
+}
+
+
+
+/* Function:  esl_fileparser_GetToken()
+ * Incept:    SRE, Fri Jul  9 13:03:50 2004 [St. Louis]
+ *
+ * Purpose:   Sets a pointer to the next field in the 
+ *            file we're parsing.
+ *            
+ *            The <opt_tok> pointer is into an internal line buffer
+ *            that may be invalidated upon the next call to a
+ *            <fileparser> function. If you want to store it, make a
+ *            copy.
+ *
+ * Args:      efp        - open fileparser
+ *            opt_tok    - optRETURN: ptr to next field
+ *            opt_toklen - optRETURN: length of tok.       
+ *
+ * Returns:   <eslOK> if <tok>, <toklen> contain valid data.
+ *            <eslEOF> on normal end-of-file.
+ *            
+ * Throws:    <eslEMEM> if an allocation fails.
+ *
+ * Xref:      STL8 p.56.
+ */
+int
+esl_fileparser_GetToken(ESL_FILEPARSER *efp, char **opt_tok, int *opt_toklen)
+{
+  char *tok    = NULL;
+  int   toklen = 0;
+  int   tokcode;
+  int   fcode;
+  int   goodtok;
+
+  if (opt_tok)    *opt_tok    = NULL;
+  if (opt_toklen) *opt_toklen = 0;
+
+  /* First, make sure we have a line loaded. 
+   * On the first call to GetToken, we won't.
+   */
+  if (efp->buf == NULL) {
+    fcode = nextline(efp);
+    if (fcode != eslOK) return fcode;
+  }
+
+  /* Start strtok()'ing this line to try to find token.
+   * If we don't find one, keep loading lines until we
+   * do, or we run out of data.
+   * efp->s was set either by nextline() or previous GetToken().
+   */
+  do {
+    goodtok = FALSE;
+    tokcode = esl_strtok_adv(&(efp->s), " \t\r\n", &tok, &toklen, NULL);
+    if (tokcode == eslEOL || (tokcode == eslOK && *tok == efp->commentchar)) 
+      {
+	fcode = nextline(efp);
+	if (fcode != eslOK) return fcode;
+      } 
+    else if (tokcode == eslOK) goodtok = TRUE;
+    else 
+      { sprintf(efp->errbuf, "esl_strtok() failed"); return tokcode;}
+  } while (! goodtok);
+
+  if (opt_tok)    *opt_tok    = tok;
+  if (opt_toklen) *opt_toklen = toklen;
+  return eslOK;
+}
+
+
+/* Function:  esl_fileparser_NextLine()
+ * Incept:    SRE, Tue Apr  3 08:27:22 2007 [Janelia]
+ *
+ * Purpose:   Advance the parser to the next non-blank, non-comment
+ *            data line that contains at least one token. 
+ *            
+ *            Upon return, <efp->buf> is a data-containing line, and
+ *            <efp->s> points to the first non-whitespace character on
+ *            it. A line-based parser can work on one or both of these.
+ *            
+ *            A line-oriented but token-based parser will call
+ *            <esl_fileparser_GetTokenOnLine()> to extract successive
+ *            tokens from it.
+ *            
+ *            A pure token-based parser will generally not call
+ *            <_NextLine()>.  The only reason would be to skip the
+ *            remainder of a line it's in the middle of parsing, and
+ *            advance to the next one -- but that's a sort of
+ *            line-oriented thing to do.
+ *
+ * Returns:   <eslOK> on success.
+ *            <eslEOF> if no more data lines remain in the file.  
+ *
+ * Throws:    <eslEMEM> on allocation error.
+ */
+int
+esl_fileparser_NextLine(ESL_FILEPARSER *efp)
+{
+  int   status;
+
+  while ((status = nextline(efp)) == eslOK) 
+    {
+      while (*(efp->s) != '\0' && isspace(*(efp->s))) efp->s++;
+      if    (*(efp->s) != '\0' && *efp->s != efp->commentchar) break;
+    } 
+  if (status == eslEOF) return status;
+  if (status != eslOK)  ESL_FAIL(status, efp->errbuf, "nextline() failed");
+  return eslOK;
+}  
+
+
+/* Function:  esl_fileparser_NextLinePeeked()
+ * Synopsis:  Read the next line, prepending a peek.
+ * Incept:    SRE, Wed Oct 15 10:08:37 2008 [Janelia]
+ *
+ * Purpose:   Sometimes we need to peek at the start of an input stream
+ *            to see whether it is in a binary format, before we start
+ *            parsing it as ASCII lines. When this happens, the caller
+ *            will typically have used <fread()> to read a fixed
+ *            number of bytes from the input stream, checked to see if
+ *            they are a magic number representing a binary format,
+ *            and found that they are not. The caller then wants to
+ *            switch to reading in ASCII format with the <fileparser>
+ *            API, but with those bytes included on the first
+ *            line. Because the file might start with comments or
+ *            blank lines that need to be skipped, we want to deal
+ *            with the peeked data in the context of the
+ *            <ESL_FILEPARSER>. The caller cannot simply close and
+ *            reopen the stream, because the stream may be a pipe
+ *            (<stdin> or <gzip -dc> for example).
+ *            
+ *            The caller passes the bytes it peeked at with <fread()>
+ *            in <prefix>, and the number of bytes it peeked at in
+ *            <plen>.
+ *            
+ *            The parser is advanced to the next non-blank,
+ *            non-comment data line that contains at least one token,
+ *            taking the prepended <prefix> into account.
+ *
+ *            There is a significant flaw in this mechanism, and as a
+ *            result the caller must be able to guarantee the
+ *            following limitation. The first data-containing line
+ *            must be longer than <prefix>. It is sufficient for the
+ *            first data token to be longer than <prefix>.
+ *            (Equivalently, if <prefix> contains any data token, it
+ *            must not contain any newline \verb+\n+ after that data.)  The
+ *            reason is that we need to avoid a situation where the
+ *            concatenated prefix+nextline contains more than one data
+ *            line, because other routines in the module assume that
+ *            <efp->buf> is a single \verb+\n+-terminated line of input.  For
+ *            example: HMMER save files either start with a 4-byte
+ *            binary magic number, or with "HMMER", and "HMMER" is
+ *            longer than 4 bytes.
+ *
+ * Args:      efp      - open fileparser
+ *            prefix   - bytes that caller obtained by peeking with fread()
+ *            plen     - number of bytes in prefix
+ *
+ * Returns:   <eslOK> on success.
+ *            <eslEOF> if no more tokens remain in the file.  
+ *
+ * Throws:    <eslEMEM> on allocation error.
+ *
+ * Xref:      For an example, see HMMER's HMM save file input.
+ */
+int
+esl_fileparser_NextLinePeeked(ESL_FILEPARSER *efp, char *prefix, int plen)
+{
+  int   blen;
+  int   status;
+  
+  /* First, make buf = the first line again, by prepending <prefix>. */
+  if ((status = nextline(efp)) != eslOK)  goto ERROR; /* EOF, EMEM */
+  blen = strlen(efp->buf);
+  
+  if (blen + plen + 1 > efp->buflen) {
+    ESL_REALLOC(efp->buf, sizeof(char) * (blen + plen + 1));
+    efp->buflen = blen + plen + 1;
+  }
+  memmove(efp->buf+plen, efp->buf, blen+1);
+  memcpy(efp->buf, prefix, plen);
+  efp->s = efp->buf;
+
+  while (*(efp->s) != '\0' && isspace(*(efp->s))) efp->s++;
+  if    (*(efp->s) != '\0' && *efp->s != efp->commentchar) return eslOK;
+  else                                                     return esl_fileparser_NextLine(efp);
+
+ ERROR:
+  return status;
+}  
+
+
+
+
+/* Function:  esl_fileparser_GetTokenOnLine()
+ * Incept:    SRE, Tue Apr  3 08:46:59 2007 [Janelia]
+ *
+ * Purpose:   Same as <esl_fileparser_GetToken()>, except that it only
+ *            retrieves tokens from the line that the parser is
+ *            on. When it runs out of tokens on the line, it returns
+ *            <eslEOL>. This allows a caller to count the tokens on a
+ *            line (whereas <GetToken()> reads through newlines
+ *            silently).
+ *            
+ *            The <opt_tok> pointer is into an internal line buffer
+ *            that may be invalidated upon the next call to a
+ *            <fileparser> function. If you want to store it, make a
+ *            copy.
+ *            
+ *            Normally, a call to <esl_fileparser_GetTokenOnLine()>
+ *            would be preceded by <esl_fileparser_NextLine()> to
+ *            position the parser on the next data line with at least
+ *            one token on it. However, you could also conceivably
+ *            call <esl_fileparser_GetTokenOnLine()> after one or more
+ *            calls to <esl_fileparser_GetToken()>, to get remaining
+ *            tokens from a given line. What you can't do is to call
+ *            <esl_fileparser_GetTokenOnLine()> immediately after 
+ *            opening a file; the parser won't have a line loaded yet.
+ *            (In this case, it would return <eslEOL>.)
+ *
+ * Returns:   <eslOK> on success, and the token and its length are
+ *            in <opt_tok> and <opt_toklen>.
+ *            
+ *            Returns <eslEOL> if no more tokens exist on the line;
+ *            in this case <opt_tok> is set to <NULL> and <opt_toklen>
+ *            to 0.
+ */
+int
+esl_fileparser_GetTokenOnLine(ESL_FILEPARSER *efp, char **opt_tok, int *opt_toklen)
+{
+  char *tok    = NULL;
+  int   toklen = 0;
+  int status;
+
+  /* No line loaded? Then we can't find any token on it. */
+  if (efp->buf == NULL) { status = eslEOL;  goto ERROR; }
+
+  /* Find next token in the line that's already loaded in the parser. */
+  status = esl_strtok_adv(&(efp->s), " \t\r\n", &tok, &toklen, NULL);
+  if (status == eslEOL) goto ERROR;
+  if (status != eslOK)  goto ERROR;
+  if (status == eslOK && *tok == efp->commentchar) { status = eslEOL; goto ERROR; }
+
+  if (opt_tok)    *opt_tok    = tok;
+  if (opt_toklen) *opt_toklen = toklen;
+  return eslOK;
+
+ ERROR:
+  if (opt_tok)    *opt_tok    = NULL;
+  if (opt_toklen) *opt_toklen = 0;
+  return status;
+}
+
+
+/* Function:  esl_fileparser_GetRemainingLine()
+ * Synopsis:  Returns pointer to the rest of the current line.
+ * Incept:    SRE, Mon Oct 13 08:59:26 2008 [Janelia]
+ *
+ * Purpose:   Set a pointer <*ret_s> to the rest of the current line
+ *            held by the fileparser <efp>. Trailing newline char,
+ *            if any, is removed.
+ *            
+ *            Because <ret_s> points to internal storage in the
+ *            fileparser, the caller should be finished with it before
+ *            making its next call to any fileparser function.
+ *            
+ *            Any comment characters on the rest of the line are
+ *            ignored: this is designed for a case where the rest of
+ *            the line is to be read as free text.
+ *            
+ * Args:      efp    - fileparser 
+ *            ret_s  - RETURN: pointer to the remainder of the line
+ *
+ * Returns:   <eslOK> on success.
+ *            <eslEOL> if nothing remains on the line, and <*ret_s>
+ *            is <NULL>.
+ *
+ * Throws:    (no abnormal error conditions)
+ */
+int
+esl_fileparser_GetRemainingLine(ESL_FILEPARSER *efp, char **ret_s)
+{
+  /* No line loaded? Then we can't find anything on it. */
+  if (efp->buf == NULL) { *ret_s = NULL; return eslEOL; }
+
+  /* skip leading whitespace */
+  while (isspace(*(efp->s))) efp->s++;  
+
+  /* Return everything to end of line as a "token", stripping newline  */
+  return esl_strtok(&(efp->s), "\r\n", ret_s);
+}
+
+
+/* Function:  esl_fileparser_Destroy()
+ * Incept:    SRE, Fri Jul  9 13:22:36 2004 [St. Louis]
+ *
+ * Purpose:   Frees an open <ESL_FILEPARSER>. The original fp is
+ *            still open - whoever opened it is still
+ *            responsible for closing it.
+ *
+ * Xref:      STL8 p.56.
+ */
+void
+esl_fileparser_Destroy(ESL_FILEPARSER *efp)
+{
+  if (efp) {
+    if (efp->buf != NULL) free(efp->buf);
+    free(efp);
+  }
+}
+
+/* Function:  esl_fileparser_Close()
+ * Incept:    SRE, Tue Apr  3 08:18:11 2007 [Janelia]
+ *
+ * Purpose:   Closes an open <ESL_FILEPARSER>, including the 
+ *            file it opened. 
+ */
+void
+esl_fileparser_Close(ESL_FILEPARSER *efp)
+{
+  if (efp == NULL) return;
+  
+  if (efp->fp != NULL && efp->fp != stdin) fclose(efp->fp);
+  if (efp->filename != NULL) free(efp->filename);
+  esl_fileparser_Destroy(efp);
+}
+
+
+
+/*****************************************************************
+ * 2. Private functions
+ *****************************************************************/
+
+/* nextline()
+ *
+ * Purpose:   Skip the file parser to the next line (for instance,
+ *            if an end-of-line comment is found). The new line might
+ *            have no tokens on it.
+ *
+ * Args:      efp  - open file parser
+ *
+ * Returns:   eslOK:   success
+ *            eslEOF:  normal end of file
+ *
+ * Throws:    <eslEMEM> if a reallocation failed in fgets()
+ *
+ * Xref:      STL8 p.56
+ */
+static int
+nextline(ESL_FILEPARSER *efp)
+{
+  int status;
+
+  /* check if we are reading from a file or a buffer */
+  if (efp->is_buffer) {
+    int   len;
+    int   end;
+    const char *ptr;
+
+    if (efp->mem_pos >= efp->mem_size) return eslEOF;
+
+    len = 0;
+    end = efp->mem_size - efp->mem_pos;
+    ptr = efp->mem_buffer + efp->mem_pos;
+    while (len < end && *ptr++ != '\n') ++len;
+    if (len < end) ++len;
+
+    if (len + 1 > efp->buflen) {
+      ESL_REALLOC(efp->buf, ESL_MAX(64, len * 2));
+      efp->buflen = ESL_MAX(64, len * 2);
+    }
+    memcpy(efp->buf, efp->mem_buffer + efp->mem_pos, len);
+    efp->buf[len] = 0;
+
+    efp->mem_pos += len;
+
+  } else {
+    if ((status = esl_fgets(&(efp->buf), &(efp->buflen), efp->fp)) != eslOK) 
+      { sprintf(efp->errbuf, "esl_fgets() failed"); return status;}
+  }
+  efp->s = efp->buf;
+  efp->linenumber++;
+  return eslOK;
+
+ ERROR:
+  return status;
+}
+
+
+
+/*****************************************************************
+ * 3. Unit tests.
+ *****************************************************************/
+#ifdef eslFILEPARSER_TESTDRIVE
+/* test the interface for getting all tokens in a file, regardless
+ * of newlines. Also, uses the Create/Destroy interface instead of
+ * Open/Close.
+ */
+static void
+utest_GetToken(char *filename)
+{
+  int status;
+  ESL_FILEPARSER *efp = NULL;
+  FILE           *fp  = NULL;
+  char           *tok = NULL;
+  int             toklen = 0;
+  int             ntok   = 0;
+
+  if ((fp  = fopen(filename, "r"))      == NULL)  esl_fatal("File open failed");
+  if ((efp = esl_fileparser_Create(fp)) == NULL)  esl_fatal("Failed to associate stream with fileparser");
+  esl_fileparser_SetCommentChar(efp, '#');
+  
+  while ((status = esl_fileparser_GetToken(efp, &tok, &toklen)) == eslOK)
+    {
+      if (toklen != 6)                   esl_fatal("bad token %s", tok);
+      if (strncmp(tok, "token", 5) != 0) esl_fatal("bad token %s", tok);
+      ntok++;
+    }
+  if (status != eslEOF)  esl_fatal("Abnormal parse termination");
+  if (ntok != 5)         esl_fatal("bad total token number %d\n", ntok);
+  
+  esl_fileparser_Destroy(efp);
+  fclose(fp);
+  return;
+}
+
+/* test the NextLine and GetTokenOnLine interface, as well as the
+ * Open/Close interface.
+ */
+static void
+utest_GetTokenOnLine(char *filename)
+{
+  int status;
+  ESL_FILEPARSER *efp = NULL;
+  char           *tok = NULL;
+  int             toklen = 0;
+  int             ntok   = 0;
+  int             nlines = 0;
+  char            expect[32];
+
+  if (esl_fileparser_Open(filename, NULL, &efp) != eslOK) esl_fatal("File open failed");
+  esl_fileparser_SetCommentChar(efp, '#');
+
+  while ((status = esl_fileparser_NextLine(efp)) == eslOK)
+    {
+      nlines++;
+      while ((status = esl_fileparser_GetTokenOnLine(efp, &tok, &toklen)) == eslOK)
+	{
+	  ntok++;
+	  sprintf(expect, "token%d", ntok);
+	  if (toklen != 6)               esl_fatal("bad token length for %s", tok);
+	  if (strcmp(expect, tok) != 0)  esl_fatal("bad token %s", tok);
+	}
+      if (status != eslEOL) esl_fatal("Unexpected code in place of end-of-line");
+    }
+  if (status != eslEOF) esl_fatal("Unexpected code in place of end-of-file.");
+
+  if (nlines != 3) esl_fatal("expected to parse 3 lines; parsed %d", nlines);
+  if (ntok   != 5) esl_fatal("expected to parse 5 tokens; parsed %d", ntok);
+  
+  esl_fileparser_Close(efp);
+  return;
+}
+
+static void
+utest_GetTokenBuffered(char *buffer)
+{
+  int status;
+  ESL_FILEPARSER *efp = NULL;
+  char           *tok = NULL;
+  int             toklen = 0;
+  int             ntok   = 0;
+
+  if ((efp = esl_fileparser_CreateMapped(buffer, strlen(buffer))) == NULL)  
+    esl_fatal("Failed to associate buffer with fileparser");
+
+  esl_fileparser_SetCommentChar(efp, '#');
+  
+  while ((status = esl_fileparser_GetToken(efp, &tok, &toklen)) == eslOK)
+    {
+      if (toklen != 6)                   esl_fatal("bad token %s", tok);
+      if (strncmp(tok, "token", 5) != 0) esl_fatal("bad token %s", tok);
+      ntok++;
+    }
+  if (status != eslEOF)  esl_fatal("Abnormal parse termination");
+  if (ntok != 5)         esl_fatal("bad total token number %d\n", ntok);
+  
+  esl_fileparser_Destroy(efp);
+
+  return;
+}
+
+#endif /*eslFILEPARSER_TESTDRIVE*/
+
+/*****************************************************************
+ * 4. Test driver.
+ *****************************************************************/
+
+/*
+    gcc -g -Wall -I. -o test -DeslFILEPARSER_TESTDRIVE esl_fileparser.c easel.c
+    ./test
+*/
+#ifdef eslFILEPARSER_TESTDRIVE
+#include <stdio.h>
+#include <string.h>
+#include "easel.h"
+#include "esl_fileparser.h"
+
+int 
+main(int argc, char **argv)
+{
+  char  tmpfile[32] = "esltmpXXXXXX";
+  FILE *fp;
+
+  char stream[] = "# Full line comment\n"
+                  "token1  # Trailing comment\n"
+                  "\n"                                   /* blank line */
+                  "   \n"                                /* whitespace line */
+                  "   # sowing comment/whitespace confusion...\n"
+                  "token2\ttoken3  token4\n"
+                  "token5";                              /* file ends w/ no \n */
+
+  /* Create a test file to read.
+   */
+  if (esl_tmpfile_named(tmpfile, &fp) != eslOK) esl_fatal("File open failed");
+  fprintf(fp, "%s", stream);
+  fclose(fp);
+
+  /* Run unit tests using that file.
+   * Unit tests have hardwired knowledge of what's supposed to be in the file.
+   */
+  utest_GetToken(tmpfile);
+  utest_GetTokenOnLine(tmpfile);
+  utest_GetTokenBuffered(stream);
+
+  remove(tmpfile);
+  return 0;
+}
+#endif /*eslFILEPARSER_TESTDRIVE*/
+
+
+/*****************************************************************
+ * 5. Examples.
+ *****************************************************************/
+
+/* The first example shows the simplest interface: get all tokens
+ * in the file, one at a time.
+ *
+     gcc -g -Wall -I. -o example -DeslFILEPARSER_EXAMPLE esl_fileparser.c easel.c
+     ./example <any file>
+ */
+#ifdef eslFILEPARSER_EXAMPLE
+/*::cexcerpt::fileparser_example::begin::*/
+#include <stdio.h>
+#include "easel.h"
+#include "esl_fileparser.h"
+
+int 
+main(int argc, char **argv)
+{
+  char           *filename = argv[1];
+  int             ntok     = 1;
+  ESL_FILEPARSER *efp;
+  char           *tok;
+  int             toklen;
+
+  if (esl_fileparser_Open(filename, NULL, &efp) != eslOK) esl_fatal("File open failed");
+  esl_fileparser_SetCommentChar(efp, '#');
+  
+  while (esl_fileparser_GetToken(efp, &tok, &toklen) == eslOK) { 
+    printf("%5d %3d %s\n", ntok, toklen, tok); 
+    ntok++;  
+  }
+  esl_fileparser_Close(efp);
+  return 0;
+}
+/*::cexcerpt::fileparser_example::end::*/
+#endif /*eslFILEPARSER_EXAMPLE*/
+
+/* The second example shows the more line-oriented interface
+ * of NextLine(), GetTokenOnLine().
+     gcc -g -Wall -I. -o example -DeslFILEPARSER_EXAMPLE2 esl_fileparser.c easel.c
+     ./example <any file>
+ */
+#ifdef eslFILEPARSER_EXAMPLE2
+/*::cexcerpt::fileparser_example2::begin::*/
+#include <stdio.h>
+#include "easel.h"
+#include "esl_fileparser.h"
+
+int 
+main(int argc, char **argv)
+{
+  char           *filename = argv[1];
+  int             nline    = 1;
+  int             ntok;
+  ESL_FILEPARSER *efp;
+  char           *tok;
+  int             toklen;
+
+  if (esl_fileparser_Open(filename, NULL, &efp) != eslOK) esl_fatal("File open failed");
+  esl_fileparser_SetCommentChar(efp, '#');
+  
+  while (esl_fileparser_NextLine(efp) == eslOK)
+  {
+    ntok = 0;
+    while (esl_fileparser_GetTokenOnLine(efp, &tok, &toklen) == eslOK)
+      ntok++;
+    printf("Line %d in the file (%d non-blank, non-comment) contains %d tokens...\n", 
+	   efp->linenumber, nline, ntok);
+    nline++;
+  }
+  esl_fileparser_Close(efp);
+  return 0;
+}
+/*::cexcerpt::fileparser_example2::end::*/
+#endif /*eslFILEPARSER_EXAMPLE*/
+
+
+
diff -Nur hmmer-3.3.orig/easel/esl_fileparser.h hmmer-3.3/easel/esl_fileparser.h
--- hmmer-3.3.orig/easel/esl_fileparser.h	2019-11-18 14:23:44.000000000 +0100
+++ hmmer-3.3/easel/esl_fileparser.h	2019-12-06 15:39:25.112539155 +0100
@@ -34,6 +34,7 @@
 extern int  esl_fileparser_GetTokenOnLine  (ESL_FILEPARSER *efp, char **opt_tok, int *opt_toklen);
 extern int  esl_fileparser_GetRemainingLine(ESL_FILEPARSER *efp, char **ret_s);
 extern void esl_fileparser_Destroy         (ESL_FILEPARSER *efp);
+extern void esl_fileparser_Reset           (ESL_FILEPARSER *efp);
 extern void esl_fileparser_Close           (ESL_FILEPARSER *efp);
 
 #endif /*eslFILEPARSER_INCLUDED */
diff -Nur hmmer-3.3.orig/easel/esl_fileparser.h.orig hmmer-3.3/easel/esl_fileparser.h.orig
--- hmmer-3.3.orig/easel/esl_fileparser.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ hmmer-3.3/easel/esl_fileparser.h.orig	2019-11-18 14:23:44.000000000 +0100
@@ -0,0 +1,40 @@
+/* A simple token-based file parsing system.
+ */
+#ifndef eslFILEPARSER_INCLUDED
+#define eslFILEPARSER_INCLUDED
+#include "esl_config.h"
+
+#include <stdio.h>
+#include "easel.h"
+
+typedef struct {
+  FILE *fp;			/* open file pointer, for reading                  */
+  char *buf;			/* current line; will be modified by esl_strtok(). */
+  int   buflen;			/* current allocated length of buf                 */
+  char *s;			/* used by esl_strtok(); current position in buf.  */
+  char  commentchar;		/* often '#'                                       */
+
+  char *filename;		/* name of opened file; or NULL (if just a stream) */
+  int   linenumber;		/* what line is loaded into buf; 1..nlines         */
+  char  errbuf[eslERRBUFSIZE];  /* for holding error diagnostics                   */
+
+  int   is_buffer;              /* the file has been buffered into memory          */
+  const char *mem_buffer;       /* pointer to the buffered file                    */
+  int   mem_size;               /* size of the buffered file                       */
+  int   mem_pos;                /* current position in the buffer                  */
+} ESL_FILEPARSER;
+
+extern int  esl_fileparser_Open(const char *filename, const char *envvar, ESL_FILEPARSER **ret_efp);
+extern ESL_FILEPARSER *esl_fileparser_Create(FILE *fp);
+extern ESL_FILEPARSER *esl_fileparser_CreateMapped(const void *buffer, int size);
+extern int  esl_fileparser_SetCommentChar  (ESL_FILEPARSER *efp, char c);
+extern int  esl_fileparser_GetToken        (ESL_FILEPARSER *efp, char **opt_tok, int *opt_toklen);
+extern int  esl_fileparser_NextLine        (ESL_FILEPARSER *efp);
+extern int  esl_fileparser_NextLinePeeked  (ESL_FILEPARSER *efp, char *prefix, int plen);
+extern int  esl_fileparser_GetTokenOnLine  (ESL_FILEPARSER *efp, char **opt_tok, int *opt_toklen);
+extern int  esl_fileparser_GetRemainingLine(ESL_FILEPARSER *efp, char **ret_s);
+extern void esl_fileparser_Destroy         (ESL_FILEPARSER *efp);
+extern void esl_fileparser_Close           (ESL_FILEPARSER *efp);
+
+#endif /*eslFILEPARSER_INCLUDED */
+
diff -Nur hmmer-3.3.orig/easel/esl_ssi.c hmmer-3.3/easel/esl_ssi.c
--- hmmer-3.3.orig/easel/esl_ssi.c	2019-11-18 14:23:44.000000000 +0100
+++ hmmer-3.3/easel/esl_ssi.c	2019-12-06 15:39:25.116539217 +0100
@@ -527,6 +527,21 @@
 }  
 
 
+/* Function:  esl_ssi_Reset()
+ * Synopsis:  Reset an SSI index.
+ *
+ * Purpose:   Reset an open SSI index <ssi>.
+ * 
+ * Args:      <ssi>   - an open SSI index file.
+ */
+void
+esl_ssi_Reset(ESL_SSI *ssi)
+{
+  if (ssi == NULL) return;
+  if (ssi->fp != NULL) fseeko(ssi->fp, 0, SEEK_SET);
+}
+
+
 /* binary_search()
  * Date:     SRE, Sun Dec 31 16:05:03 2000 [St. Louis]
  *
diff -Nur hmmer-3.3.orig/easel/esl_ssi.c.orig hmmer-3.3/easel/esl_ssi.c.orig
--- hmmer-3.3.orig/easel/esl_ssi.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ hmmer-3.3/easel/esl_ssi.c.orig	2019-11-18 14:23:44.000000000 +0100
@@ -0,0 +1,2139 @@
+/* Sequence/subsequence indices: fast lookup in large sequence files by keyword.
+ *
+ * Contents:
+ *  1. Using (reading) an SSI index.
+ *  2. Creating (writing) new SSI files.
+ *  3. Portable binary i/o.
+ *  4. Unit tests.
+ *  5. Test driver.
+ *  6. Example code.
+ */
+#include "esl_config.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include "easel.h"
+#include "esl_ssi.h"
+
+static uint32_t v30magic = 0xd3d3c9b3; /* SSI 3.0: "ssi3" + 0x80808080 */
+static uint32_t v30swap  = 0xb3c9d3d3; /* byteswapped */
+
+
+/*****************************************************************
+ *# 1. Using (reading) an SSI index.
+ *****************************************************************/ 
+
+static int  binary_search(ESL_SSI *ssi, const char *key, uint32_t klen, off_t base, 
+			  uint32_t recsize, uint64_t maxidx);
+
+/* Function:  esl_ssi_Open()
+ * Synopsis:  Open an SSI index as an <ESL_SSI>.
+ *
+ * Purpose:   Open the SSI index file <filename>, and returns a pointer
+ *            to the new <ESL_SSI> object in <ret_ssi>.
+ *            
+ *            Caller is responsible for closing the SSI file with
+ *            <esl_ssi_Close()>.
+ *
+ * Args:      <filename>   - name of SSI index file to open.       
+ *            <ret_ssi>    - RETURN: the new <ESL_SSI>.
+ *                        
+ * Returns:   <eslOK>        on success;
+ *            <eslENOTFOUND> if <filename> cannot be opened for reading;
+ *            <eslEFORMAT>   if it's not in correct SSI file format;
+ *            <eslERANGE>    if it uses 64-bit file offsets, and we're on a system
+ *                           that doesn't support 64-bit file offsets.
+ *            
+ * Throws:    <eslEMEM> on allocation error.
+ */
+int
+esl_ssi_Open(const char *filename, ESL_SSI **ret_ssi)
+{
+  ESL_SSI *ssi = NULL;
+  int      status;
+  uint32_t magic;	/* magic number that starts the SSI file */
+  uint16_t i;		/* counter over files */
+
+  /* Initialize the SSI structure, null'ing so we can autocleanup.
+   */
+  ESL_ALLOC(ssi, sizeof(ESL_SSI));
+  ssi->fp         = NULL;
+  ssi->filename   = NULL;
+  ssi->fileformat = NULL;
+  ssi->fileflags  = NULL;
+  ssi->bpl        = NULL;
+  ssi->rpl        = NULL;
+  ssi->nfiles     = 0;          
+
+  /* Open the file.
+   */
+  status = eslENOTFOUND; 
+  if ((ssi->fp = fopen(filename, "rb")) == NULL) goto ERROR; 
+
+  /* Read the magic number: make sure it's an SSI file, and determine
+   * whether it's byteswapped.
+   */
+  status = eslEFORMAT;
+  if (esl_fread_u32(ssi->fp, &magic)        != eslOK) goto ERROR;
+  if (magic != v30magic && magic != v30swap)          goto ERROR;
+  if (esl_fread_u32(ssi->fp, &(ssi->flags)) != eslOK) goto ERROR;
+  if (esl_fread_u32(ssi->fp, &(ssi->offsz)) != eslOK) goto ERROR;
+
+  status = eslERANGE;
+  if (ssi->offsz != 4 && ssi->offsz != 8) goto ERROR;
+  if (ssi->offsz > sizeof(off_t))         goto ERROR;
+
+  /* The header data. */
+  status = eslEFORMAT;
+  if (esl_fread_u16(ssi->fp, &(ssi->nfiles))     != eslOK) goto ERROR;
+  if (esl_fread_u64(ssi->fp, &(ssi->nprimary))   != eslOK) goto ERROR;
+  if (esl_fread_u64(ssi->fp, &(ssi->nsecondary)) != eslOK) goto ERROR;
+  if (esl_fread_u32(ssi->fp, &(ssi->flen))       != eslOK) goto ERROR;
+  if (esl_fread_u32(ssi->fp, &(ssi->plen))       != eslOK) goto ERROR;
+  if (esl_fread_u32(ssi->fp, &(ssi->slen))       != eslOK) goto ERROR;
+  if (esl_fread_u32(ssi->fp, &(ssi->frecsize))   != eslOK) goto ERROR;
+  if (esl_fread_u32(ssi->fp, &(ssi->precsize))   != eslOK) goto ERROR;
+  if (esl_fread_u32(ssi->fp, &(ssi->srecsize))   != eslOK) goto ERROR;
+  
+  if (esl_fread_offset(ssi->fp, ssi->offsz, &(ssi->foffset)) != eslOK) goto ERROR;
+  if (esl_fread_offset(ssi->fp, ssi->offsz, &(ssi->poffset)) != eslOK) goto ERROR;
+  if (esl_fread_offset(ssi->fp, ssi->offsz, &(ssi->soffset)) != eslOK) goto ERROR;
+
+  /* The file information.
+   * We expect the number of files to be small, so reading it once
+   * should be advantageous overall. If SSI ever had to deal with
+   * large numbers of files, you'd probably want to read file
+   * information on demand.
+   */
+  status = eslEFORMAT;
+  if (ssi->nfiles == 0) goto ERROR;
+
+  ESL_ALLOC(ssi->filename,   sizeof(char *) * ssi->nfiles);
+  for (i = 0; i < ssi->nfiles; i++)  ssi->filename[i] = NULL; 
+  ESL_ALLOC(ssi->fileformat, sizeof(uint32_t) * ssi->nfiles);
+  ESL_ALLOC(ssi->fileflags,  sizeof(uint32_t) * ssi->nfiles);
+  ESL_ALLOC(ssi->bpl,        sizeof(uint32_t) * ssi->nfiles);
+  ESL_ALLOC(ssi->rpl,        sizeof(uint32_t) * ssi->nfiles);
+
+  /* (most) allocations done, now we read. */
+  for (i = 0; i < ssi->nfiles; i++) 
+    {
+      ESL_ALLOC(ssi->filename[i], sizeof(char)* ssi->flen);
+      /* We do have to explicitly position, because header and file 
+       * records may expand in the future; frecsize and foffset 
+       * give us forwards compatibility. 
+       */ 
+      status = eslEFORMAT;
+      if (fseeko(ssi->fp, ssi->foffset + (i * ssi->frecsize), SEEK_SET) != 0) goto ERROR;
+      if (fread(ssi->filename[i],sizeof(char),ssi->flen, ssi->fp)!=ssi->flen) goto ERROR;
+      if (esl_fread_u32(ssi->fp, &(ssi->fileformat[i])))                      goto ERROR;
+      if (esl_fread_u32(ssi->fp, &(ssi->fileflags[i])))                       goto ERROR;
+      if (esl_fread_u32(ssi->fp, &(ssi->bpl[i])))                             goto ERROR;
+      if (esl_fread_u32(ssi->fp, &(ssi->rpl[i])))                             goto ERROR;
+    }
+  *ret_ssi = ssi;
+  return eslOK;
+  
+ ERROR:
+  if (ssi != NULL) esl_ssi_Close(ssi);
+  *ret_ssi = NULL;
+  return status;
+}
+
+
+/* Function: esl_ssi_FindName()
+ * Synopsis: Look up a primary or secondary key.
+ *
+ * Purpose:  Looks up the string <key> in index <ssi>.
+ *           <key> can be either a primary or secondary key. If <key>
+ *           is found, <ret_fh> contains a unique handle on
+ *           the file that contains <key> (suitable for an <esl_ssi_FileInfo()>
+ *           call, or for comparison to the handle of the last file
+ *           that was opened for retrieval), and <ret_offset> contains
+ *           the offset of the sequence record in that file.
+ *           
+ * Args:     <ssi>         - open index file
+ *           <key>         - name to search for
+ *           <ret_fh>      - RETURN: handle on file that key is in
+ *           <ret_roff>    - RETURN: offset of the start of that key's record
+ *           <opt_doff>    - optRETURN: data offset (may be 0 if unset)
+ *           <opt_L>       - optRETURN: length of data record (may be 0 if unset)                
+ *
+ * Returns:  <eslOK>        on success;
+ *           <eslENOTFOUND> if no such key is in the index;
+ *           <eslEFORMAT>   if an fread() or fseeko() fails, which almost
+ *                          certainly reflects some kind of misformatting of
+ *                          the index.
+ *
+ * Throws:   <eslEMEM>      on allocation error.
+ */
+int
+esl_ssi_FindName(ESL_SSI *ssi, const char *key, uint16_t *ret_fh, off_t *ret_roff, off_t *opt_doff, int64_t *opt_L)
+{
+  int       status;
+  off_t     doff;
+  int64_t   L;
+  char     *pkey   = NULL;
+
+  /* Look in the primary keys.
+   */
+  status = binary_search(ssi, key, ssi->plen, ssi->poffset, ssi->precsize,
+			 ssi->nprimary);
+
+  if (status == eslOK) 
+    { /* We found it as a primary key; get our data & return. */
+      status = eslEFORMAT;
+      if (esl_fread_u16(ssi->fp, ret_fh)                  != eslOK) goto ERROR;
+      if (esl_fread_offset(ssi->fp, ssi->offsz, ret_roff) != eslOK) goto ERROR;
+      if (esl_fread_offset(ssi->fp, ssi->offsz, &doff)    != eslOK) goto ERROR;
+      if (esl_fread_i64   (ssi->fp, &L)                   != eslOK) goto ERROR;
+    } 
+  else if (status == eslENOTFOUND) 
+    { /* Not in the primary keys? OK, try the secondary keys. */
+      if (ssi->nsecondary > 0) {
+	if ((status = binary_search(ssi, key, ssi->slen, ssi->soffset, ssi->srecsize, ssi->nsecondary)) != eslOK) goto ERROR;
+
+	/* We have the secondary key; flip to its primary key, then look that up. */
+	ESL_ALLOC(pkey, sizeof(char) * ssi->plen);
+	status = eslEFORMAT;
+	if (fread(pkey, sizeof(char), ssi->plen, ssi->fp) != ssi->plen) goto ERROR;
+	if ((status = esl_ssi_FindName(ssi, pkey, ret_fh, ret_roff, &doff, &L)) != eslOK) goto ERROR;
+      } else goto ERROR;	/* no secondary keys? pass along the ENOTFOUND error. */
+    } else goto ERROR;	/* status from binary search was an error code. */
+
+  if (pkey != NULL) free(pkey);
+  if (opt_doff != NULL) *opt_doff = doff;
+  if (opt_L    != NULL) *opt_L    = L;
+  return eslOK;
+
+ ERROR:
+  if (pkey != NULL) free(pkey);
+  *ret_fh   = 0;
+  *ret_roff = 0;
+  if (opt_doff != NULL) *opt_doff = 0;
+  if (opt_L    != NULL) *opt_L    = 0;
+  return status;
+}
+
+
+
+/* Function:  esl_ssi_FindNumber()
+ * Synopsis:  Look up the n'th primary key.
+ *
+ * Purpose:   Looks up primary key number <nkey> in the open index
+ *            <ssi>.  <nkey> ranges from <0..ssi->nprimary-1>. When
+ *            key <nkey> is found, any/all of several optional
+ *            arguments point to results. <*opt_fh> contains a unique
+ *            handle on the file that contains that key (suitable for
+ *            an <esl_ssi_FileInfo()> call, or for comparison to the
+ *            handle of the last file that was opened for retrieval).
+ *            <*opt_roff> contains the record offset; <*opt_doff>
+ *            contains the data offset; <*opt_L> contains the record
+ *            length; and <*opt_pkey> points to the primary key name
+ *            (a string, allocated here, that the caller becomes
+ *            responsible for free'ing).
+ *           
+ * Args:      <ssi>        - open index file
+ *            <nkey>       - primary key number to retrieve (0..nprimary-1)
+ *            <opt_fh>     - optRETURN: handle on file that key is in
+ *            <opt_roff>   - optRETURN: offset of the start of that key's record
+ *            <opt_doff>   - optRETURN: data offset (may be 0 if unset)
+ *            <opt_L>      - optRETURN: length of data record (may be 0 if unset)                
+ *            <opt_pkey>   - optRETURN: primary key name (allocated here; caller must free)
+ *
+ * Returns:   <eslOK>        on success;
+ *            <eslENOTFOUND> if there is no sequence record <nkey>;
+ *            <eslEFORMAT>   if a read or a seek fails, probably indicating
+ *                           some kind of file misformatting.
+ *
+ * Throws:    <eslEMEM> on allocation error.
+ */
+int
+esl_ssi_FindNumber(ESL_SSI *ssi, int64_t nkey, uint16_t *opt_fh, off_t *opt_roff, off_t *opt_doff, int64_t *opt_L, char **opt_pkey)
+{
+  int      status;
+  uint16_t fh;
+  off_t    doff, roff;
+  uint64_t L;
+  char    *pkey = NULL;
+
+  if (nkey >= ssi->nprimary) { status = eslENOTFOUND; goto ERROR; }
+  ESL_ALLOC(pkey, sizeof(char) * ssi->plen);
+
+  status = eslEFORMAT;
+  if (fseeko(ssi->fp, ssi->poffset+ssi->precsize*nkey, SEEK_SET)!= 0) goto ERROR;
+  if (fread(pkey, sizeof(char), ssi->plen, ssi->fp)   != ssi->plen)   goto ERROR;
+  if (esl_fread_u16(ssi->fp, &fh)                     != eslOK)       goto ERROR;
+  if (esl_fread_offset(ssi->fp, ssi->offsz, &roff)    != eslOK)       goto ERROR;
+  if (esl_fread_offset(ssi->fp, ssi->offsz, &doff)    != eslOK)       goto ERROR;
+  if (esl_fread_u64   (ssi->fp, &L)                   != eslOK)       goto ERROR;
+
+  if (opt_fh   != NULL) *opt_fh   = fh;
+  if (opt_roff != NULL) *opt_roff = roff;
+  if (opt_doff != NULL) *opt_doff = doff;
+  if (opt_L    != NULL) *opt_L    = L;
+  if (opt_pkey != NULL) *opt_pkey = pkey; else free(pkey);
+  return eslOK;
+
+ ERROR:
+  if (pkey     != NULL) free(pkey);
+  if (opt_fh   != NULL) *opt_fh   = 0;
+  if (opt_roff != NULL) *opt_roff = 0;
+  if (opt_doff != NULL) *opt_doff = 0;
+  if (opt_L    != NULL) *opt_L    = 0;
+  if (opt_pkey != NULL) *opt_pkey = NULL;
+  return status;
+}
+
+
+/* Function: esl_ssi_FindSubseq()
+ * Synopsis: Look up a specific subsequence's start.
+ * Date:     SRE, Mon Jan  1 19:49:31 2001 [St. Louis]
+ *
+ * Purpose:  Fast subsequence retrieval: look up a primary or secondary
+ *           <key> in the open index <ssi>, and ask for the nearest data
+ *           offset to a subsequence starting at residue
+ *           <requested_start> in the sequence (numbering the sequence
+ *           <1..L>).  If <key> is found, on return, <ret_fh> contains
+ *           a unique handle on the file that contains <key>;
+ *           <ret_roff> contains the disk offset to the start of the
+ *           sequence record; <ret_doff> contains the disk offset
+ *           (see below); and <ret_actual_start) contains the coordinate
+ *           (1..L) of the first valid residue at or after
+ *           <data_offset>. <ret_actual_start> is $\leq$
+ *           <requested_start>.
+ *           
+ *           Depending on the file's characteristics, there are four
+ *           possible outcomes.
+ *           
+ *           If the file has the <eslSSI_FASTSUBSEQ> flag set, a data
+ *           offset was indexed for this key, and the data can be
+ *           indexed at single residue resolution (because the file's
+ *           lines contain only residues, no spaces), then <ret_doff>
+ *           is exactly the position of residue <requested_start> on
+ *           disk, and <ret_actual_start> is <requested_start>.
+ *           
+ *           If the file has the <eslSSI_FASTSUBSEQ> flag set, a data
+ *           offset was indexed for this key, but the data can only be
+ *           indexed at line resolution (because at least some of the
+ *           file's lines contain spaces), then <ret_doff> is the
+ *           position of the start of the line that <requested_start>
+ *           is on, and <ret_actual_start> is the coord <1..L> of the
+ *           first residue on that line.
+ *           
+ *           If the file does not have the <eslSSI_FASTSUBSEQ> flag
+ *           set (because lines contain a variable number of residues
+ *           and/or bytes), but a data offset was indexed for this
+ *           key, then we can still at least return that data offset,
+ *           but the caller is going to have to start from the
+ *           beginning of the data and read residues until it reaches
+ *           the desired <requested_start>. Now <ret_doff> is the
+ *           offset to the start of the first line of the sequence
+ *           data, and <ret_actual_start> is 1.
+ *           
+ *           If the key does not have a data offset indexed at all,
+ *           then regardless of the file's <eslSSI_FASTSUBSEQ>
+ *           setting, we can't calculate even the position of the
+ *           first line. In this case, <ret_doff> is 0 (for
+ *           unset/unknown), and <ret_actual_start> is <1>.
+ *           
+ *           A caller that's going to position the disk and read a
+ *           subseq must check for all four possible outcomes (pardon
+ *           redundancy with the above, but just to be clear, from the
+ *           caller's perspective now):
+ *           
+ *           If <ret_doff> is 0, no data offset information can be
+ *           calculated; the caller can still use <ret_roff> to
+ *           position the disk to the start of <key>'s record, but it
+ *           will need to parse the header to find the start of the
+ *           sequence data; then it will need to parse the sequence
+ *           data, skipping to residue <requested start>.
+ *           
+ *           If <ret_doff> is valid ($>0$), and <ret_actual_start> is
+ *           1, then caller may use <ret_doff> to position the disk to
+ *           the start of the first sequence data line, but will still
+ *           need to parse all the sequence data, counting and
+ *           skipping to residue <requested start>. This is equivalent
+ *           to (and in practice, not much more efficient than)
+ *           positioning to the record start and parsing the header to
+ *           locate the sequence data start. 
+ *           
+ *           If <ret_doff> is valid ($>0$), and <ret_actual_start> is
+ *           $>1$ but $<$ <requested_start>, then <ret_doff> is the
+ *           offset to the first byte of a line on which the
+ *           subsequence begins. The caller can position the disk
+ *           there, then start parsing, skipping <requested_start -
+ *           *ret_actual_start> residues to reach the
+ *           <requested_start>. (In the case where the subsequence
+ *           begins on the first line, then <ret_actual_start> will be
+ *           1, and the caller will have to handle this as the case
+ *           above.)
+ *           
+ *           If <<ret_doff> is valid ($>0$), and <ret_actual_start> is
+ *           $=$ <requested_start>, then <ret_doff> is the offset to a
+ *           byte in the file, such that the requested subsequence
+ *           starts at the next valid residue at or after that
+ *           position.  (The <ret_doff> would usually be exactly the
+ *           first residue of the subsequence, because we used single
+ *           residue resolution arithmetic to find it, but there's a
+ *           case where <requested_start> happens to be the first
+ *           residue of a line and we calculated <ret_doff> using
+ *           line-resolution arithmetic; in this latter case,
+ *           <ret_doff> could be pointing at a space before the first
+ *           subseq residue.) The caller may position the disk there
+ *           and start parsing immediately; the first valid residue
+ *           will be the start of the subsequence.
+ *
+ * Args:     <ssi>             - open index file
+ *           <key>             - primary or secondary key to find
+ *           <requested_start> - residue we'd like to start at (1..L)
+ *           <ret_fh>          - RETURN: handle for file the key is in
+ *           <ret_roff>        - RETURN: offset to start of sequence record
+ *           <ret_doff>        - RETURN: offset to closest start of subseq data, or 0. 
+ *           <ret_L>           - RETURN: length of <key> in residues (may be 0 if unset)
+ *           <ret_actual_start>- RETURN: coord (1..L) of residue at <ret_doff>
+ *
+ * Returns:  <eslOK>         on any of the four successful outcomes.
+ *           <eslENOTFOUND>  if no such key is found in the index;
+ *           <eslEFORMAT> on a read or seek failure, presumably meaning that
+ *                        the file is misformatted somehow;
+ *           <eslERANGE>  if <requested_start> isn't somewhere in the range
+ *                        <1..len> for the target sequence.
+ *                        
+ * Throws:   <eslEMEM> on allocation error.                       
+ */
+int
+esl_ssi_FindSubseq(ESL_SSI *ssi, const char *key, int64_t requested_start,
+		   uint16_t *ret_fh, off_t *ret_roff, off_t *ret_doff, int64_t *ret_L, int64_t *ret_actual_start)
+{
+  int      status;
+  uint64_t r, b, i, l;	/* tmp variables for "clarity", to match docs */
+  
+  /* Look up the key by name.
+   */
+  if ((status = esl_ssi_FindName(ssi, key, ret_fh, ret_roff, ret_doff, ret_L)) != eslOK) goto ERROR;
+  if (requested_start < 0 || requested_start > *ret_L) { status = eslERANGE; goto ERROR; }
+
+  /* Do we have a data offset for this key? If not, we're case 4.    */
+  /* Can we do fast subseq lookup on this file? If no, we're case 3. */
+  if (*ret_doff == 0 || ! (ssi->fileflags[*ret_fh] & eslSSI_FASTSUBSEQ))
+    {
+      *ret_actual_start = 1;
+      return eslOK;
+    }
+
+  /* Set up tmp variables for clarity of equations below,
+   * and to make them match tex documentation 
+   */
+  r = ssi->rpl[*ret_fh];         /* residues per line */
+  b = ssi->bpl[*ret_fh];         /* bytes per line    */
+  i = requested_start;	         /* start position 1..L */
+  l = (i-1)/r;		         /* data line # (0..) that the residue is on */
+  if (r == 0 || b == 0) { status = eslEINVAL; goto ERROR; }
+  
+  /* When b = r+1, there's nothing but sequence on each data line (and the \0).
+   * In this case, we know we can find each residue precisely: outcome #1.
+   */
+  if (b == r+1) 
+    {
+      *ret_doff        += l*b + (i-1)%r;
+      *ret_actual_start = requested_start;
+    } 
+  /* else, there's other stuff on seq lines - probably spaces - so the best
+   * we can do (without figuring out the spacing pattern and checking that
+   * it's consistent everywhere) is to position at start of relevant line.
+   */
+  else
+    { 
+      *ret_doff         += l*b;
+      *ret_actual_start = 1 + l*r;
+    }
+  return eslOK;
+
+ ERROR:
+  *ret_fh           = 0;
+  *ret_roff         = 0;
+  *ret_doff         = 0;
+  *ret_L            = 0;
+  *ret_actual_start = 0;
+  return status;
+}
+
+
+/* Function: esl_ssi_FileInfo()
+ * Synopsis: Retrieve a file name and format code.
+ * Date:     SRE, Tue Jan  2 10:31:01 2001 [St. Louis]
+ *
+ * Purpose:  Given a file number <fh> in an open index file
+ *           <ssi>, retrieve file name <ret_filename> and
+ *           the file format <ret_format>. 
+ *           
+ *           <ret_filename> is a pointer to a string maintained
+ *           internally by <ssi>. It should not be free'd; 
+ *           <esl_ssi_Close(ssi)> will take care of it.
+ *
+ * Args:     <ssi>          - open index file
+ *           <fh>           - handle on file to look up
+ *           <ret_filename> - RETURN: name of file n
+ *           <ret_format>   - RETURN: format code for file n
+ *
+ * Returns:  <eslOK> on success.
+ * 
+ * Throws:   <eslEINVAL> if there is no such file number <fh>.
+ */
+int
+esl_ssi_FileInfo(ESL_SSI *ssi, uint16_t fh, char **ret_filename, int *ret_format)
+{
+  int status;
+
+  if (fh >= ssi->nfiles) ESL_XEXCEPTION(eslEINVAL, "no such file number");
+  *ret_filename = ssi->filename[fh];
+  *ret_format   = ssi->fileformat[fh];
+  return eslOK;
+
+ ERROR:
+  *ret_filename = NULL;
+  *ret_format   = 0;
+  return status;
+}
+
+
+/* Function:  esl_ssi_Close()
+ * Synopsis:  Close an SSI index.
+ *
+ * Purpose:   Close an open SSI index <ssi>.
+ * 
+ * Args:      <ssi>   - an open SSI index file.
+ */
+void
+esl_ssi_Close(ESL_SSI *ssi)
+{
+  int i;
+
+  if (ssi == NULL) return;
+
+  if (ssi->fp != NULL) fclose(ssi->fp);
+  if (ssi->filename != NULL) {
+    for (i = 0; i < ssi->nfiles; i++) 
+      if (ssi->filename[i] != NULL) free(ssi->filename[i]);
+    free(ssi->filename);
+  }
+  if (ssi->fileformat != NULL) free(ssi->fileformat);
+  if (ssi->fileflags  != NULL) free(ssi->fileflags);
+  if (ssi->bpl        != NULL) free(ssi->bpl);
+  if (ssi->rpl        != NULL) free(ssi->rpl);
+  free(ssi);
+}  
+
+
+/* binary_search()
+ * Date:     SRE, Sun Dec 31 16:05:03 2000 [St. Louis]
+ *
+ * Purpose:  Find <key> in an SSI index, by a binary search
+ *           in an alphabetically sorted list of keys. If successful,
+ *           return <eslOK>, and the index file is positioned to read
+ *           the rest of the data for that key. If unsuccessful, 
+ *           return <eslFAIL>, and the positioning of the index file
+ *           is left in an undefined state.
+ *
+ * Args:     <ssi>     - an open ESL_SSI
+ *           <key>     - key to find
+ *           <klen>    - key length to allocate (plen or slen from ssi)
+ *           <base>    - base offset (poffset or soffset)
+ *           <recsize> - size of each key record in bytes (precsize or srecsize)
+ *           <maxidx>  - # of keys (nprimary or nsecondary)
+ *
+ * Returns:  <eslOK> on success, and leaves file positioned for reading remaining
+ *           data for the key. 
+ *           
+ *           <eslENOTFOUND> if <key> is not found.
+ *           <eslEFORMAT>   if an fread() or fseeko() fails, probably indicating
+ *                          some kind of misformatting of the index file.
+ *
+ * Throws:   <eslEMEM> on allocation failure.
+ *           
+ */
+static int
+binary_search(ESL_SSI *ssi, const char *key, uint32_t klen, off_t base, 
+	      uint32_t recsize, uint64_t maxidx)
+{
+  char        *name;
+  uint64_t     left, right, mid;
+  int          cmp;
+  int          status;
+  
+  if (maxidx == 0) return eslENOTFOUND; /* special case: empty index */
+
+  ESL_ALLOC(name, (sizeof(char)*klen));
+
+  left  = 0;
+  right = maxidx-1;
+  while (1) {			/* A binary search: */
+    mid   = (left+right) / 2;	/* careful here. left+right potentially overflows if
+				   we didn't limit unsigned vars to signed ranges. */
+    status = eslEFORMAT;
+    if (fseeko(ssi->fp, base + recsize*mid, SEEK_SET) != 0)    goto ERROR;
+    if (fread(name, sizeof(char), klen, ssi->fp)      != klen) goto ERROR;
+
+    status = eslENOTFOUND;
+    cmp = strcmp(name, key);
+    if      (cmp == 0) break;	             /* found it!               */
+    else if (left >= right) goto ERROR;      /* no such key             */
+    else if (cmp < 0)       left  = mid+1;   /* it's still right of mid */
+    else if (cmp > 0) {
+      if (mid == 0) goto ERROR;              /* beware left edge case   */
+      else right = mid-1;                    /* it's left of mid        */
+    }
+  }
+
+  if (name != NULL) free(name);
+  return eslOK;  /* and ssi->fp is positioned to read the record. */
+
+ ERROR:
+  if (name != NULL) free(name);
+  return status; 
+}
+
+
+/*****************************************************************
+ *# 2. Creating (writing) new SSI files.
+ *****************************************************************/ 
+static int current_newssi_size(const ESL_NEWSSI *ns);
+static int activate_external_sort(ESL_NEWSSI *ns);
+static int parse_pkey(char *buf, ESL_PKEY *pkey);
+static int parse_skey(char *buf, ESL_SKEY *skey);
+static int pkeysort(const void *k1, const void *k2);
+static int skeysort(const void *k1, const void *k2);
+
+/* Function:  esl_newssi_Open()
+ * Synopsis:  Create a new <ESL_NEWSSI>.
+ *
+ * Purpose:   Creates and returns a <ESL_NEWSSI>, in order to create a 
+ *            new SSI index file.
+ *
+ * Returns:   <eslOK> on success, and <*ret_newssi> is a pointer to a
+ *            new <ESL_NEWSSI> structure.
+ *            
+ *            Returns <eslENOTFOUND> if <ssifile> can't be opened.
+ *
+ *            Returns <eslEOVERWRITE> if <allow_overwrite> is <FALSE>
+ *            and <ssifile> (or any necessary tmp files) already
+ *            exist, to block overwriting of an existing SSI file.
+ *            
+ * Throws:    <eslEMEM> on allocation error.
+ */
+int
+esl_newssi_Open(const char *ssifile, int allow_overwrite, ESL_NEWSSI **ret_newssi)
+{
+  ESL_NEWSSI *ns = NULL;
+  int i;
+  int status;
+
+  ESL_ALLOC(ns, sizeof(ESL_NEWSSI));
+  ns->ssifile    = NULL;
+  ns->ssifp      = NULL;
+  ns->external   = FALSE;	    /* we'll switch to external sort if...       */
+  ns->max_ram    = eslSSI_MAXRAM;   /* ... if we exceed this memory limit in MB. */
+  ns->filenames  = NULL;
+  ns->fileformat = NULL;
+  ns->bpl        = NULL;
+  ns->rpl        = NULL;
+  ns->flen       = 0;
+  ns->nfiles     = 0;
+  ns->pkeys      = NULL;
+  ns->plen       = 0;
+  ns->nprimary   = 0;
+  ns->ptmpfile   = NULL;
+  ns->ptmp       = NULL;
+  ns->skeys      = NULL;
+  ns->slen       = 0;
+  ns->nsecondary = 0;
+  ns->stmpfile   = NULL;
+  ns->stmp       = NULL;
+  ns->errbuf[0]  = '\0';    
+
+  if ((status = esl_strdup(ssifile, -1, &(ns->ssifile)))    != eslOK) goto ERROR;
+  if ((status = esl_strdup(ssifile, -1, &(ns->ptmpfile)))   != eslOK) goto ERROR;
+  if ((status = esl_strdup(ssifile, -1, &(ns->stmpfile)))   != eslOK) goto ERROR;
+  if ((status = esl_strcat(&ns->ptmpfile, -1, ".1", 2))     != eslOK) goto ERROR;
+  if ((status = esl_strcat(&ns->stmpfile, -1, ".2", 2))     != eslOK) goto ERROR;
+
+  if (! allow_overwrite)
+    {
+      if (esl_FileExists(ssifile)      ||
+	  esl_FileExists(ns->ptmpfile) ||
+	  esl_FileExists(ns->stmpfile)) 
+	{ status = eslEOVERWRITE; goto ERROR; }
+    }
+
+  if ((ns->ssifp = fopen(ssifile, "w")) == NULL)  { status = eslENOTFOUND; goto ERROR; }
+
+  ESL_ALLOC(ns->filenames,  sizeof(char *)   * eslSSI_FCHUNK);
+  for (i = 0; i < eslSSI_FCHUNK; i++) 
+    ns->filenames[i] = NULL;
+  ESL_ALLOC(ns->fileformat, sizeof(uint32_t) * eslSSI_FCHUNK);
+  ESL_ALLOC(ns->bpl,        sizeof(uint32_t) * eslSSI_FCHUNK);
+  ESL_ALLOC(ns->rpl,        sizeof(uint32_t) * eslSSI_FCHUNK);
+  ESL_ALLOC(ns->pkeys,      sizeof(ESL_PKEY) * eslSSI_KCHUNK);
+  for (i = 0; i < eslSSI_KCHUNK; i++) 
+    ns->pkeys[i].key = NULL;
+  ESL_ALLOC(ns->skeys,      sizeof(ESL_SKEY) * eslSSI_KCHUNK);
+  for (i = 0; i < eslSSI_KCHUNK; i++) {
+    ns->skeys[i].key  = NULL;
+    ns->skeys[i].pkey = NULL;
+  }
+  *ret_newssi = ns;
+  return eslOK;
+
+ ERROR:
+  esl_newssi_Close(ns);	/* free the damaged structure */
+  return status;
+}
+
+
+/* Function:  esl_newssi_AddFile()
+ * Synopsis:  Add a filename to a growing index.
+ *
+ * Purpose:   Registers the file <filename> into the new index <ns>,
+ *            along with its format code <fmt>. The index assigns it
+ *            a unique handle, which it returns in <ret_fh>. This
+ *            handle is needed when registering primary keys.
+ *
+ *            Caller should make sure that the same file isn't registered
+ *            twice; this function doesn't check.
+ *            
+ * Args:      <ns>         - new ssi index under construction.
+ *            <filename>   - filename to add to the index.
+ *            <fmt>        - format code to associate with <filename> (or 0)
+ *            <ret_fh>     - RETURN: filehandle associated with <filename>        
+ *
+ * Returns:   <eslOK> on success;
+ *            <eslERANGE> if registering this file would exceed the
+ *                        maximum number of indexed files.
+ *
+ * Throws:    <eslEMEM> on allocation or reallocation error.
+ */
+int
+esl_newssi_AddFile(ESL_NEWSSI *ns, const char *filename, int fmt, uint16_t *ret_fh)
+{
+  int      status;
+  uint16_t fh;
+  int      i;
+  int      n;
+
+  if (ns->nfiles >= eslSSI_MAXFILES) ESL_XFAIL(eslERANGE, ns->errbuf, "exceeded the maximum number of files an SSI index can store");
+
+  n = strlen(filename);
+  if ((n+1) > ns->flen) ns->flen = n+1;
+
+  if ((status = esl_FileTail(filename, FALSE, &(ns->filenames[ns->nfiles]))) != eslOK) goto ERROR;
+  
+  ns->fileformat[ns->nfiles] = fmt;
+  ns->bpl[ns->nfiles]        = 0;
+  ns->rpl[ns->nfiles]        = 0;
+  fh                         = ns->nfiles;   /* handle is simply = file number */
+  ns->nfiles++;
+
+  if (ns->nfiles % eslSSI_FCHUNK == 0) {
+    ESL_REALLOC(ns->filenames,  sizeof(char *)   * (ns->nfiles+eslSSI_FCHUNK));
+    for (i = ns->nfiles; i < ns->nfiles+eslSSI_FCHUNK; i++) ns->filenames[i] = NULL;
+    ESL_REALLOC(ns->fileformat, sizeof(uint32_t) * (ns->nfiles+eslSSI_FCHUNK));
+    ESL_REALLOC(ns->bpl,        sizeof(uint32_t) * (ns->nfiles+eslSSI_FCHUNK));
+    ESL_REALLOC(ns->rpl,        sizeof(uint32_t) * (ns->nfiles+eslSSI_FCHUNK));
+  } 
+
+  *ret_fh = fh;
+  return eslOK;
+
+ ERROR:
+  *ret_fh = 0;
+  return status;
+}
+
+
+
+/* Function:  esl_newssi_SetSubseq()
+ * Synopsis:  Declare that file is suitable for fast subseq lookup.
+ *
+ * Purpose:   Declare that the file associated with handle <fh> is
+ *            suitable for fast subsequence lookup, because it has
+ *            a constant number of residues and bytes per (nonterminal)
+ *            data line, <rpl> and <bpl>, respectively.
+ *            
+ *            Caller is responsible for this being true: <rpl> and
+ *            <bpl> must be constant for every nonterminal line of 
+ *            every sequence in this file.
+ *            
+ * Args:      <ns>   - ssi index under construction
+ *            <fh>   - handle on file to set fast subseq lookup on
+ *            <bpl>  - constant bytes per nonterminal line in <fh>                   
+ *            <rpl>  - constant residues per nonterminal line in <fh>
+ *
+ * Returns:   <eslOK> on success.
+ *
+ * Throws:    <eslEINVAL> on invalid argument(s).
+ */
+int
+esl_newssi_SetSubseq(ESL_NEWSSI *ns, uint16_t fh, uint32_t bpl, uint32_t rpl)
+{
+  int status;
+
+  if (fh >= ns->nfiles)      ESL_XEXCEPTION(eslEINVAL, "invalid file number");
+  if (bpl <= 0 || rpl <= 0)  ESL_XEXCEPTION(eslEINVAL, "invalid bpl or rpl");
+  ns->bpl[fh] = bpl;
+  ns->rpl[fh] = rpl;
+  return eslOK;
+
+ ERROR:
+  return status;
+}
+
+
+/* Function: esl_newssi_AddKey()
+ * Synopsis: Add a primary key to a growing index.
+ * Date:     SRE, Tue Jan  2 11:50:54 2001 [St. Louis]
+ *
+ * Purpose:  Register primary key <key> in new index <ns>, while telling
+ *           the index that this primary key is in the file associated
+ *           with filehandle <fh> (the handle returned by a previous call
+ *           to <esl_newssi_AddFile()>); that its record starts at 
+ *           offset <r_off> in the file; that its data (usually
+ *           sequence data) starts at offset <d_off> in the file (i.e.
+ *           after any record header); and that the record's data is
+ *           of length <L> (usually, the record is a sequence, and <L> 
+ *           is its length in residues).
+ *           
+ *           The data length <L> is technically optional as far as SSI
+ *           is concerned; <L> may be passed as 0 to leave it
+ *           unset. However, functions in the <sqio> module that use
+ *           SSI indices will assume that <L> is available.
+ *           
+ *           <d_off> is also optional; it may be passed as <0> to
+ *           leave it unset. If provided, <d_off> gives an offset to
+ *           the data portion of the record. The interpretation of
+ *           this data offset may be implementation-defined and may
+ *           depend on the format of the datafile; for example, in how
+ *           <sqio> uses SSI indices, <d_off> is the offset to the
+ *           start of the first sequence line.
+ *           
+ *           Both <d_off> and <L> must be provided, and additionally
+ *           <eslSSI_FASTSUBSEQ> must be set for this file, for fast
+ *           subsequence lookup to work.
+ *           
+ * Args:     <ns>     - active index
+ *           <key>    - primary key to add
+ *           <fh>     - handle on file that this key's in 
+ *           <r_off>  - offset to start of record
+ *           <d_off>  - offset to start of sequence data, or 0
+ *           <L>      - length of sequence, or 0
+ *
+ * Returns:  <eslOK>        on success;
+ *           <eslERANGE>    if registering this key would exceed the maximum
+ *                          number of primary keys;
+ *           <eslENOTFOUND> if we needed to open external tmp files, but
+ *                          the attempt to open them failed.
+ *           
+ * Throws:   <eslEINVAL> on an invalid argument;
+ *           <eslEMEM>   on allocation failure;
+ *           <eslEWRITE> on any system error writing to tmp file, such
+ *                       as filling the filesystem.
+ */
+int
+esl_newssi_AddKey(ESL_NEWSSI *ns, const char *key, uint16_t fh, 
+		  off_t r_off, off_t d_off, int64_t L)
+{
+  int status;
+  int i;
+  int n;			/* a string length */
+  
+  if (fh >= eslSSI_MAXFILES)           ESL_XEXCEPTION(eslEINVAL, "invalid fh");
+  if (ns->nprimary >= eslSSI_MAXKEYS)  ESL_XFAIL(eslERANGE, ns->errbuf, "exceeded maximum number of primary keys allowed");
+
+  /* Before adding the key: check how big our index is.
+   * If it's getting too large, switch to external mode.
+   */
+  if (!ns->external && current_newssi_size(ns) >= ns->max_ram) 
+    if ((status = activate_external_sort(ns)) != eslOK) goto ERROR;
+
+  /* Update maximum pkey length, if needed. (Inclusive of '\0').
+   */
+  n = strlen(key)+1;
+  if (n > ns->plen) ns->plen = n;
+
+  /* External mode? Simply append to disk... 
+   */
+  if (ns->external) 
+    {
+      if (sizeof(off_t) == 4) {
+	if (fprintf(ns->ptmp, "%s\t%d\t%" PRIu32 "\t%" PRIu32 "\t%" PRIi64 "\n", 
+		    key, fh, (uint32_t) r_off, (uint32_t) d_off, L) <= 0) 
+	  ESL_XEXCEPTION_SYS(eslEWRITE, "ssi key tmp file write failed");
+      } else {
+	if (fprintf(ns->ptmp, "%s\t%d\t%" PRIu64 "\t%" PRIu64 "\t%" PRIi64 "\n", 
+		    key, fh, (uint64_t) r_off, (uint64_t) d_off, L) <= 0)
+	  ESL_XEXCEPTION_SYS(eslEWRITE, "ssi key tmp file write failed");
+      }
+      ns->nprimary++;
+    }
+  else
+    {
+      /* Else: internal mode, keep keys in memory...
+       */
+      if ((status = esl_strdup(key, n, &(ns->pkeys[ns->nprimary].key))) != eslOK) goto ERROR;
+      ns->pkeys[ns->nprimary].fnum  = fh;
+      ns->pkeys[ns->nprimary].r_off = r_off;
+      ns->pkeys[ns->nprimary].d_off = d_off;
+      ns->pkeys[ns->nprimary].len   = L;
+      ns->nprimary++;
+
+      /* Reallocate as needed. */
+      if (ns->nprimary % eslSSI_KCHUNK == 0) {
+	ESL_REALLOC(ns->pkeys, sizeof(ESL_PKEY) * (ns->nprimary+eslSSI_KCHUNK));
+	for (i = ns->nprimary; i < ns->nprimary + eslSSI_KCHUNK; i++)
+	  ns->pkeys[i].key = NULL;
+      }
+    }
+  return eslOK;
+
+ ERROR:
+  return status;
+}
+
+/* Function:  esl_newssi_AddAlias()
+ * Synopsis:  Add a secondary key (alias) to a growing index.
+ *
+ * Purpose:   Registers secondary key <alias> in index <ns>, and 
+ *            map it to the primary key <key>. <key> must already
+ *            have been registered. That is, when someone looks up <alias>,
+ *            we'll retrieve record <key>. 
+ *            
+ * Args:      <ns>    - ssi index being constructed
+ *            <alias> - secondary key to register
+ *            <key>   - primary key to associate with <skey>.                  
+ *
+ * Returns:   <eslOK>        on success;
+ *            <eslERANGE>    if registering this key would exceed the maximum
+ *                           number of secondary keys that can be stored;
+ *            <eslENOTFOUND> if we needed to open external tmp files, but
+ *                           the attempt to open them failed.
+ *
+ * Throws:    <eslEWRITE>   on any system error writing to tmp file, such 
+ *                          as running out of space on the device.
+ */
+int
+esl_newssi_AddAlias(ESL_NEWSSI *ns, const char *alias, const char *key)
+{
+  int status;
+  int i;
+  int n;			/* a string length */
+  
+  if (ns->nsecondary >= eslSSI_MAXKEYS) ESL_XFAIL(eslERANGE, ns->errbuf, "exceeded maximum number of secondary keys allowed");
+
+  /* Before adding the key: check how big our index is.
+   * If it's getting too large, switch to external mode.
+   */
+  if (!ns->external && current_newssi_size(ns) >= ns->max_ram) 
+    if ((status = activate_external_sort(ns)) != eslOK) goto ERROR;
+
+  /* Update maximum secondary key length, if necessary. */
+  n = strlen(alias)+1;
+  if (n > ns->slen) ns->slen = n;
+
+  /* if external mode: write info to disk. */
+  if (ns->external) 
+    {
+      if (fprintf(ns->stmp, "%s\t%s\n", alias, key) <= 0) ESL_XEXCEPTION_SYS(eslEWRITE, "ssi alias tmp file write failed");
+      ns->nsecondary++;
+    }
+  else
+    { /* else, internal mode... store info in memory. */
+      if ((status = esl_strdup(alias, n, &(ns->skeys[ns->nsecondary].key))) != eslOK) goto ERROR;
+      if ((status = esl_strdup(key, -1, &(ns->skeys[ns->nsecondary].pkey))) != eslOK) goto ERROR;
+      ns->nsecondary++;
+
+      if (ns->nsecondary % eslSSI_KCHUNK == 0) {
+	ESL_REALLOC(ns->skeys, sizeof(ESL_SKEY) * (ns->nsecondary+eslSSI_KCHUNK));
+	for (i = ns->nsecondary; i < ns->nsecondary+eslSSI_KCHUNK; i++) {
+	  ns->skeys[i].key  = NULL;
+	  ns->skeys[i].pkey = NULL;
+	}
+      }
+    }
+  return eslOK;
+
+ ERROR:
+  return status;
+}
+
+
+/* Function:  esl_newssi_Write()
+ * Synopsis:  Save a new index to an SSI file.
+ *
+ * Purpose:   Writes the complete index <ns> in SSI format to its file,
+ *            and closes the file.
+ *
+ *            Handles all necessary overhead of sorting the primary and
+ *            secondary keys, including any externally sorted tmpfiles that
+ *            may have been needed for large indices.
+ *            
+ *            You only <_Write()> once. The open SSI file is closed.
+ *            After calling <_Write()>, you should <_Close()> the
+ *            <ESL_NEWSSI>.
+ *            
+ *            Verifies that all primary and secondary keys are unique.
+ *            If not, returns <eslEDUP>.
+ *            
+ *            On any error, the SSI file <ns->ssifile> is deleted.
+ *            
+ * Args:      <ns>  - new SSI index to write                   
+ *            
+ * Returns:   <eslOK>       on success;
+ *            <eslEDUP>     if primary or secondary keys aren't all unique
+ *            <eslERANGE>   if index size exceeds system's maximum file size;
+ *            <eslESYS>     if any of the steps of an external sort fail.
+ *
+ * Throws:    <eslEINVAL> on invalid argument, including too-long tmpfile names,
+ *                        or trying to _Write() the <ESL_NEWSSI> more than once;
+ *            <eslEMEM>   on buffer allocation failure;
+ *            <eslEWRITE> on any system write failure, including filled disk.  
+ *            
+ * Note:      It's O(1) memory to check for key duplications
+ *            here, after keys are sorted, compared to O(N) in
+ *            <esl_newssi_AddKey()>, where we would have to maintain a
+ *            hash of all previous N keys in memory.
+ */
+int
+esl_newssi_Write(ESL_NEWSSI *ns)
+{
+  int      status, 		/* convention                               */
+           i;			/* counter over files, keys                 */
+  uint32_t header_flags,	/* bitflags in the header                   */
+           file_flags,		/* bitflags for a file record               */
+           frecsize, 		/* size of a file record (bytes)            */
+           precsize, 		/* size of a primary key record (bytes)     */
+           srecsize;		/* size of a secondary key record (bytes)   */
+  off_t    foffset, 		/* offset to file section                   */
+           poffset, 		/* offset to primary key section            */
+           soffset;		/* offset to secondary key section          */
+  char    *fk       = NULL,     /* fixed-width (flen) file name             */
+          *pk       = NULL, 	/* fixed-width (plen) primary key string    */
+          *sk       = NULL,	/* fixed-width (slen) secondary key string  */
+          *buf      = NULL;	/* esl_fgets() growable buffer              */
+  int      n        = 0;	/* esl_fgets() buffer size                  */
+  ESL_PKEY pkey;		/* primary key info from external tmpfile   */
+  ESL_SKEY skey;		/* secondary key info from external tmpfile */
+
+  if (ns->nsecondary > 0 && ns->slen == 0)
+    ESL_EXCEPTION(eslEINVAL, "zero secondary key length: shouldn't happen");
+  if (ns->ssifp == NULL)
+    ESL_EXCEPTION(eslEINVAL, "SSI data were already written.");
+
+  /* We need fixed-width buffers to get our keys fwrite()'ten in their
+   * full binary lengths; pkey->key (for instance) is not guaranteed
+   * to be allocated for the final maximum plen. We use strncpy(), not
+   * strcpy(), to fill these buffers, because strncpy() pads unused
+   * bytes as NUL's, and valgrind will flag you if you attempt to
+   * write uninitialized bytes from these buffers.
+   */
+  ESL_ALLOC(fk,   sizeof(char) * ns->flen);
+  ESL_ALLOC(pk,   ESL_MAX(1, sizeof(char) * ns->plen));
+  if (ns->nsecondary > 0) ESL_ALLOC(sk, sizeof(char) * ns->slen);
+
+  /* How big is the index? If it's going to be > 2GB, we better have
+   * 64-bit offsets. (2047 (instead of 2048) gives us
+   * some slop room.) If not, abort here.
+   *
+   * aborting here is pretty brutal - we've processed hundreds of
+   * millions of keys for nothing. Ah well.
+   */
+  if (current_newssi_size(ns) >= 2047 && sizeof(off_t) != 8)
+    ESL_XFAIL(eslERANGE, ns->errbuf, "SSI index file file would be > 2G; your filesystem isn't capable of handling it");
+
+  /* Magic-looking numbers come from adding up sizes 
+   * of things in bytes: they match current_newssi_size().
+   */
+  frecsize     = 4*sizeof(uint32_t) + ns->flen;
+  precsize     = 2*sizeof(off_t) + sizeof(uint16_t) + sizeof(uint64_t) + ns->plen;
+  srecsize     = ns->slen + ns->plen;
+  header_flags = 0;
+
+  /* Magic-looking numbers again come from adding up sizes 
+   * of things in bytes: matches current_newssi_size()
+   */
+  foffset = 9*sizeof(uint32_t)+2*sizeof(uint64_t)+sizeof(uint16_t)+3*sizeof(off_t);
+  poffset = foffset + frecsize*ns->nfiles;
+  soffset = poffset + precsize*ns->nprimary;
+  
+  /* Sort the keys.
+   * If external mode, make system calls to UNIX/POSIX "sort" in place, then
+   * open new sorted files for reading thru ptmp and stmp handles.
+   * If internal mode, call qsort. 
+   * 
+   * Note that you'd better force a POSIX locale for the sort; else,
+   * some silly distro (e.g. Mandrake Linux >=8.1) may have specified
+   * LC_COLLATE=en_US, and this'll give a sort "bug" in which it doesn't
+   * sort by byte order.
+   */
+  if (ns->external) 
+    {
+      char cmd[1024];
+
+      /* A last minute security check: make sure we won't overflow
+       * sprintf() with the tmpfile names. They're hardcoded now, so
+       * we know they don't overflow, but they might be configurable 
+       * in the future, and we wouldn't want a security hole to open
+       * up.
+       */
+      if (strlen(ns->ptmpfile) > 256 || strlen(ns->ptmpfile) > 256) 
+	ESL_XEXCEPTION(eslEINVAL, "tmpfile name too long"); 
+
+      fclose(ns->ptmp);
+      ns->ptmp = NULL;	
+      sprintf(cmd, "env LC_ALL=POSIX sort -o %s %s\n", ns->ptmpfile, ns->ptmpfile);
+      if (system(cmd) != 0)                              ESL_XFAIL(eslESYS, ns->errbuf, "external sort of primary keys failed");
+      if ((ns->ptmp = fopen(ns->ptmpfile, "r")) == NULL) ESL_XFAIL(eslESYS, ns->errbuf, "failed to reopen primary key tmp file after sort");
+
+      fclose(ns->stmp);
+      ns->stmp = NULL;
+      sprintf(cmd, "env LC_ALL=POSIX sort -o %s %s\n", ns->stmpfile, ns->stmpfile);
+      if (system(cmd) != 0)                              ESL_XFAIL(eslESYS, ns->errbuf, "external sort of secondary keys failed");
+      if ((ns->stmp = fopen(ns->stmpfile, "r")) == NULL) ESL_XFAIL(eslESYS, ns->errbuf, "failed to reopen secondary key tmp file after sort");
+    }
+  else 
+    {
+      qsort((void *) ns->pkeys, ns->nprimary,   sizeof(ESL_PKEY), pkeysort); 
+      qsort((void *) ns->skeys, ns->nsecondary, sizeof(ESL_SKEY), skeysort); 
+    }
+
+  /* Write the header
+   */
+  if (esl_fwrite_u32(ns->ssifp, v30magic)      != eslOK || 
+      esl_fwrite_u32(ns->ssifp, header_flags)  != eslOK || 
+      esl_fwrite_u32(ns->ssifp, sizeof(off_t)) != eslOK ||
+      esl_fwrite_u16(ns->ssifp, ns->nfiles)    != eslOK ||
+      esl_fwrite_u64(ns->ssifp, ns->nprimary)  != eslOK ||
+      esl_fwrite_u64(ns->ssifp, ns->nsecondary)!= eslOK ||
+      esl_fwrite_u32(ns->ssifp, ns->flen)      != eslOK ||
+      esl_fwrite_u32(ns->ssifp, ns->plen)      != eslOK ||
+      esl_fwrite_u32(ns->ssifp, ns->slen)      != eslOK ||
+      esl_fwrite_u32(ns->ssifp, frecsize)      != eslOK ||
+      esl_fwrite_u32(ns->ssifp, precsize)      != eslOK ||
+      esl_fwrite_u32(ns->ssifp, srecsize)      != eslOK ||
+      esl_fwrite_offset(ns->ssifp, foffset)    != eslOK ||
+      esl_fwrite_offset(ns->ssifp, poffset)    != eslOK ||
+      esl_fwrite_offset(ns->ssifp, soffset)    != eslOK) 
+    ESL_XEXCEPTION_SYS(eslEWRITE, "ssi write failed");
+
+  /* Write the file section
+   */
+  for (i = 0; i < ns->nfiles; i++)
+    {
+      file_flags = 0;
+      if (ns->bpl[i] > 0 && ns->rpl[i] > 0) file_flags |= eslSSI_FASTSUBSEQ;
+      strncpy(fk, ns->filenames[i], ns->flen);
+
+      if (fwrite(fk, sizeof(char), ns->flen, ns->ssifp) != ns->flen ||
+	  esl_fwrite_u32(ns->ssifp, ns->fileformat[i])  != eslOK    ||
+	  esl_fwrite_u32(ns->ssifp, file_flags)         != eslOK    ||
+	  esl_fwrite_u32(ns->ssifp, ns->bpl[i])         != eslOK    ||
+	  esl_fwrite_u32(ns->ssifp, ns->rpl[i])         != eslOK)
+	ESL_XEXCEPTION_SYS(eslEWRITE, "ssi write failed");
+    }
+
+  /* Write the primary key section
+   */
+  if (ns->external) 
+    {
+      if (ns->nprimary) strncpy(pk, "", ns->plen);
+      for (i = 0; i < ns->nprimary; i++) 
+	{
+	  if (esl_fgets(&buf, &n, ns->ptmp)  != eslOK)    ESL_XFAIL(eslESYS, ns->errbuf, "read from sorted primary key tmpfile failed");
+	  if (parse_pkey(buf, &pkey)         != eslOK)    ESL_XFAIL(eslESYS, ns->errbuf, "parse failed for a line of sorted primary key tmpfile failed");
+          if (strcmp(pk, pkey.key)           == 0)        ESL_XFAIL(eslEDUP, ns->errbuf, "primary keys not unique: '%s' occurs more than once", pkey.key);
+	  strncpy(pk, pkey.key, ns->plen);   // strncpy() pads w/ nulls, and we count on that behavior.
+
+	  if (fwrite(pk,sizeof(char),ns->plen,ns->ssifp) != ns->plen ||
+	      esl_fwrite_u16(   ns->ssifp, pkey.fnum)    != eslOK    ||
+	      esl_fwrite_offset(ns->ssifp, pkey.r_off)   != eslOK    ||
+	      esl_fwrite_offset(ns->ssifp, pkey.d_off)   != eslOK    ||
+	      esl_fwrite_i64(   ns->ssifp, pkey.len)     != eslOK)
+	    ESL_XEXCEPTION_SYS(eslEWRITE, "ssi write failed");
+	}
+    } 
+  else 
+    {
+      if (ns->nprimary) strncpy(pk, "", ns->plen);
+      for (i = 0; i < ns->nprimary; i++)
+	{
+          if (strcmp(pk, ns->pkeys[i].key)  == 0)  ESL_XFAIL(eslEDUP, ns->errbuf, "primary keys not unique: '%s' occurs more than once", ns->pkeys[i].key);
+	  strncpy(pk, ns->pkeys[i].key, ns->plen);
+
+	  if (fwrite(pk,sizeof(char),ns->plen,ns->ssifp)       != ns->plen ||
+	      esl_fwrite_u16(   ns->ssifp, ns->pkeys[i].fnum)  != eslOK    ||
+	      esl_fwrite_offset(ns->ssifp, ns->pkeys[i].r_off) != eslOK    ||
+	      esl_fwrite_offset(ns->ssifp, ns->pkeys[i].d_off) != eslOK    ||
+	      esl_fwrite_i64(   ns->ssifp, ns->pkeys[i].len)   != eslOK)
+	    ESL_XEXCEPTION_SYS(eslEWRITE, "ssi write failed");
+	}
+    }
+
+
+  /* Write the secondary key section
+   */
+  if (ns->external) 
+    {
+      if (ns->nsecondary) strncpy(sk, "", ns->slen);
+      for (i = 0; i < ns->nsecondary; i++)
+	{
+	  if (esl_fgets(&buf, &n, ns->stmp) != eslOK) ESL_XFAIL(eslESYS, ns->errbuf, "read from sorted secondary key tmpfile failed");
+	  if (parse_skey(buf, &skey)        != eslOK) ESL_XFAIL(eslESYS, ns->errbuf, "parse failed for a line of sorted secondary key tmpfile failed");
+          if (strcmp(sk, skey.key)          == 0)     ESL_XFAIL(eslEDUP, ns->errbuf, "secondary keys not unique: '%s' occurs more than once", skey.key);
+	  strncpy(sk, skey.key,  ns->slen);  // slen > 0 if there are any secondary keys.
+	  strncpy(pk, skey.pkey, ns->plen);
+
+	  if (fwrite(sk, sizeof(char), ns->slen, ns->ssifp) != ns->slen ||
+	      fwrite(pk, sizeof(char), ns->plen, ns->ssifp) != ns->plen) 
+	    ESL_XEXCEPTION_SYS(eslEWRITE, "ssi write failed");
+	}
+    } 
+  else 
+    {
+      /* if ns->nsecondary=0, ns->slen=0 and sk=NULL */
+      if (ns->nsecondary) strncpy(sk, "", ns->slen);
+      for (i = 0; i < ns->nsecondary; i++)
+	{
+          if (strcmp(sk, ns->skeys[i].key) == 0) ESL_XFAIL(eslEDUP, ns->errbuf, "secondary keys not unique: '%s' occurs more than once", ns->skeys[i].key);
+	  strncpy(sk, ns->skeys[i].key,  ns->slen);
+	  strncpy(pk, ns->skeys[i].pkey, ns->plen);
+
+	  if (fwrite(sk, sizeof(char), ns->slen, ns->ssifp) != ns->slen ||
+	      fwrite(pk, sizeof(char), ns->plen, ns->ssifp) != ns->plen)
+	    ESL_XEXCEPTION_SYS(eslEWRITE, "ssi write failed");
+	} 
+    }
+
+  fclose(ns->ssifp);                // Closing <ssifp> makes it so we can only _Write() once.
+  ns->ssifp = NULL;
+  if (fk)       free(fk);
+  if (pk)       free(pk);
+  if (sk)       free(sk);
+  if (buf)      free(buf);
+  if (ns->ptmp) { fclose(ns->ptmp); ns->ptmp = NULL; }
+  if (ns->stmp) { fclose(ns->stmp); ns->stmp = NULL; }
+  return eslOK;
+
+ ERROR:
+  remove(ns->ssifile);               // Cleanup: delete failed <ssifile> on any error.
+  if (ns->ssifp) { fclose(ns->ssifp); ns->ssifp = NULL; }
+  if (fk)        free(fk);
+  if (pk)        free(pk);
+  if (sk)        free(sk);
+  if (buf)       free(buf);
+  if (ns->ptmp)  { fclose(ns->ptmp); ns->ptmp = NULL; }
+  if (ns->stmp)  { fclose(ns->stmp); ns->stmp = NULL; }
+  return status;
+}
+
+/* Function:  esl_newssi_Close()
+ * Synopsis:  Free an <ESL_NEWSSI>.
+ *
+ * Purpose:   Frees a <ESL_NEWSSI>.
+ */
+void
+esl_newssi_Close(ESL_NEWSSI *ns)
+{
+  int i;
+  if (ns == NULL) return;
+
+  if (ns->external == FALSE) 
+    {
+      if (ns->pkeys != NULL) 
+	{
+	  for (i = 0; i < ns->nprimary; i++) 
+	    if (ns->pkeys[i].key != NULL) free(ns->pkeys[i].key);
+	  free(ns->pkeys);       	
+	}
+      if (ns->skeys != NULL) 
+	{
+	  for (i = 0; i < ns->nsecondary; i++) 
+	    {
+	      if (ns->skeys[i].key  != NULL) free(ns->skeys[i].key);
+	      if (ns->skeys[i].pkey != NULL) free(ns->skeys[i].pkey);
+	    }
+	  free(ns->skeys);       
+	}
+    }
+  else 
+    {
+      remove(ns->ptmpfile);
+      remove(ns->stmpfile);
+    }
+
+  if (ns->filenames   != NULL)  
+    {
+      for (i = 0; i < ns->nfiles; i++) 
+	if (ns->filenames[i] != NULL) free(ns->filenames[i]);
+      free(ns->filenames);
+    }
+
+  if (ns->stmp)       fclose(ns->stmp);
+  if (ns->stmpfile)   free(ns->stmpfile);
+  if (ns->ptmp)       fclose(ns->ptmp);
+  if (ns->ptmpfile)   free(ns->ptmpfile);
+  if (ns->fileformat) free(ns->fileformat);
+  if (ns->bpl)        free(ns->bpl);       
+  if (ns->rpl)        free(ns->rpl);       
+  if (ns->ssifile)    free(ns->ssifile);
+  if (ns->ssifp)      fclose(ns->ssifp);
+  free(ns);
+}
+
+
+
+
+/* current_newssi_size()
+ *
+ * Calculates the size of the current index, in megabytes, in
+ * its disk version (which is essentially the same as the
+ * RAM it takes, modulo some small overhead for the structures
+ * and ptrs).
+ *  
+ * The header costs 10 uint32, 1 uint16, and 3 off_t's: 42 + (12 | 24).
+ * Each file record costs 4 uint32 and flen chars;
+ * each primary key costs us 2 off_t, 1 uint16, 1 uint32, and plen chars;
+ * each sec key costs us  plen+slen chars.
+ */
+static int
+current_newssi_size(const ESL_NEWSSI *ns) 
+{
+  uint64_t frecsize, precsize, srecsize;
+  uint64_t total;
+
+  /* Magic-looking numbers come from adding up sizes 
+   * of things in bytes
+   */
+  frecsize = 4*sizeof(uint32_t) + ns->flen;
+  precsize = 2*sizeof(off_t) + sizeof(uint16_t) + sizeof(uint64_t) + ns->plen;
+  srecsize = ns->slen + ns->plen;
+  total = (9*sizeof(uint32_t)+2*sizeof(uint64_t)+sizeof(uint16_t)+3*sizeof(off_t)+
+	   frecsize * ns->nfiles +      /* file section size                   */
+	   precsize * ns->nprimary +    /* primary key section size            */
+	   srecsize * ns->nsecondary) / /* secondary key section size          */
+          1048576L;
+  return (int) total;
+}
+
+/* activate_external_sort()
+ * 
+ * Switch to external sort mode.
+ * Open file handles for external index files (ptmp, stmp).
+ * Flush current index information to these files.
+ * Free current memory, turn over control to the tmpfiles.
+ *           
+ * Return <eslOK>        on success; 
+ *        <eslENOTFOUND> if we can't open a tmpfile for writing.
+ * 
+ * Throw  <eslEWRITE>    if a write fails.
+ */
+static int
+activate_external_sort(ESL_NEWSSI *ns)
+{
+  int status;
+  int i;
+
+  if (ns->external)                   return eslOK; /* we already are external, fool */
+  
+  if ((ns->ptmp = fopen(ns->ptmpfile, "w")) == NULL) ESL_XFAIL(eslENOTFOUND, ns->errbuf, "Failed to open primary key tmpfile for external sort");
+  if ((ns->stmp = fopen(ns->stmpfile, "w")) == NULL) ESL_XFAIL(eslENOTFOUND, ns->errbuf, "Failed to open secondary key tmpfile for external sort");
+
+  /* Flush the current indices. */
+  for (i = 0; i < ns->nprimary; i++) {
+    if (sizeof(off_t) == 4) {
+      if (fprintf(ns->ptmp, "%s\t%u\t%lu\t%lu\t%lu\n", 
+		  ns->pkeys[i].key, 
+		  (unsigned int)  ns->pkeys[i].fnum,
+		  (unsigned long) ns->pkeys[i].r_off, 
+		  (unsigned long) ns->pkeys[i].d_off, 
+		  (unsigned long) ns->pkeys[i].len) <= 0)
+	ESL_XEXCEPTION_SYS(eslEWRITE, "ssi key tmp file write failed");
+    } else {
+      if (fprintf(ns->ptmp, "%s\t%u\t%llu\t%llu\t%lu\n", 
+		  ns->pkeys[i].key, 
+		  (unsigned int)       ns->pkeys[i].fnum,
+		  (unsigned long long) ns->pkeys[i].r_off, 
+		  (unsigned long long) ns->pkeys[i].d_off, 
+		  (unsigned long)      ns->pkeys[i].len) <= 0)
+	ESL_XEXCEPTION_SYS(eslEWRITE, "ssi key tmp file write failed");
+    }
+  }
+  for (i = 0; i < ns->nsecondary; i++)
+    if (fprintf(ns->stmp, "%s\t%s\n", ns->skeys[i].key, ns->skeys[i].pkey) <= 0)
+      ESL_XEXCEPTION_SYS(eslEWRITE, "ssi alias tmp file write failed");
+  
+  /* Free the memory now that we've flushed our lists to disk
+   */
+  for (i = 0; i < ns->nprimary;   i++) free(ns->pkeys[i].key);
+  for (i = 0; i < ns->nsecondary; i++) free(ns->skeys[i].key);
+  for (i = 0; i < ns->nsecondary; i++) free(ns->skeys[i].pkey);
+  if (ns->pkeys != NULL) free(ns->pkeys);       	
+  if (ns->skeys != NULL) free(ns->skeys);       
+  ns->pkeys    = NULL;
+  ns->skeys    = NULL;
+  ns->external = TRUE;
+  return eslOK;
+
+ ERROR:
+  if (ns->ptmp != NULL) { fclose(ns->ptmp); ns->ptmp = NULL; }
+  if (ns->stmp != NULL) { fclose(ns->stmp); ns->stmp = NULL; }
+  return status;
+}
+
+/* parse_pkey(), parse_skey()
+ * 
+ * Given a <buf> containing a line read from the external
+ * primary-key or secondary-key tmpfile; parse it, and fill in the fields of
+ * <pkey> or <skey>
+ * 
+ * <?key> is a ptr to a structure on the stack. It is assumed
+ * to be in use only transiently.
+ * <?key>'s strings become ptrs into <buf>'s space, so we don't have to
+ * allocate new space for them. This means that the transient <?key> structure
+ * is only usable until <buf> is modified or free'd.
+ * 
+ * Returns <eslOK> on success.
+ * 
+ * Throws  <eslEFORMAT>        on parse error (shouldn't happen; we created it!)
+ *         <eslEINCONCEIVABLE> if we can't deal with off_t's size.     
+ */
+static int
+parse_pkey(char *buf, ESL_PKEY *pkey)
+{
+  int   status;
+  char *s, *tok;
+  
+  s = buf;
+  if (esl_strtok(&s, "\t\n", &(pkey->key)) != eslOK) ESL_XEXCEPTION(eslEFORMAT, "parse failed");
+  if (esl_strtok(&s, "\t\n", &tok)         != eslOK) ESL_XEXCEPTION(eslEFORMAT, "parse failed");
+
+  pkey->fnum = (uint16_t) atoi(tok);
+  if (esl_strtok(&s, "\t\n", &tok)         != eslOK) ESL_XEXCEPTION(eslEFORMAT, "parse failed");
+  if      (sizeof(off_t) == 4) pkey->r_off  = (off_t) strtoul (tok, NULL, 10);
+  else if (sizeof(off_t) == 8) pkey->r_off  = (off_t) strtoull(tok, NULL, 10);
+  else                         ESL_XEXCEPTION(eslEINCONCEIVABLE, "whoa - weird off_t");
+
+  if (esl_strtok(&s, "\t\n", &tok)         != eslOK) ESL_XEXCEPTION(eslEFORMAT, "parse failed");
+  if      (sizeof(off_t) == 4) pkey->d_off  = (off_t) strtoul (tok, NULL, 10);
+  else if (sizeof(off_t) == 8) pkey->d_off  = (off_t) strtoull(tok, NULL, 10);
+  else                         ESL_XEXCEPTION(eslEINCONCEIVABLE, "whoa - weird off_t");
+
+  if (esl_strtok(&s, "\t\n", &tok)         != eslOK) ESL_XEXCEPTION(eslEFORMAT, "parse failed");
+  pkey->len = (uint64_t) strtoull(tok, NULL, 10);
+  return eslOK;
+
+ ERROR:
+  return status;
+}
+static int
+parse_skey(char *buf, ESL_SKEY *skey)
+{
+  int   status;
+  char *s;
+  
+  s = buf;
+  if (esl_strtok(&s, "\t\n", &(skey->key))  != eslOK) ESL_XEXCEPTION(eslEFORMAT, "parse failed");
+  if (esl_strtok(&s, "\t\n", &(skey->pkey)) != eslOK) ESL_XEXCEPTION(eslEFORMAT, "parse failed");
+  return eslOK;
+
+ ERROR:
+  return status;
+}
+
+/* ordering functions needed for qsort() */
+static int 
+pkeysort(const void *k1, const void *k2)
+{
+  ESL_PKEY *key1;
+  ESL_PKEY *key2;
+  key1 = (ESL_PKEY *) k1;
+  key2 = (ESL_PKEY *) k2;
+  return strcmp(key1->key, key2->key);
+}
+static int 
+skeysort(const void *k1, const void *k2)
+{
+  ESL_SKEY *key1;
+  ESL_SKEY *key2;
+  key1 = (ESL_SKEY *) k1;
+  key2 = (ESL_SKEY *) k2;
+  return strcmp(key1->key, key2->key);
+}
+
+
+/*****************************************************************
+ *# 3. Portable binary i/o
+ *****************************************************************/ 
+
+/* Function:  esl_byteswap()
+ * Synopsis:  Swap between big-endian and little-endian, in place.
+ *
+ * Purpose:   Swap between big-endian and little-endian, in place.
+ */
+void
+esl_byteswap(char *swap, int nbytes)
+{
+  int  x;
+  char byte;
+  
+  for (x = 0; x < nbytes / 2; x++)
+    {
+      byte = swap[nbytes - x - 1];
+      swap[nbytes - x - 1] = swap[x];
+      swap[x] = byte;
+    }
+}
+
+/* Function:  esl_ntoh16()
+ * Synopsis:  Convert 2-byte integer from network-order to host-order.
+ *
+ * Purpose:   Convert a 2-byte integer from network-order to host-order,
+ *            and return it.
+ *            
+ *            <esl_ntoh32()> and <esl_ntoh64()> do the same, but for 4-byte
+ *            and 8-byte integers, respectively.
+ */
+uint16_t
+esl_ntoh16(uint16_t netshort)
+{
+#ifdef WORDS_BIGENDIAN
+  return netshort;
+#else
+  esl_byteswap((char *) &netshort, 2);
+  return netshort;
+#endif
+}
+uint32_t
+esl_ntoh32(uint32_t netlong)
+{
+#ifdef WORDS_BIGENDIAN
+  return netlong;
+#else
+  esl_byteswap((char *) &netlong, 4);
+  return netlong;
+#endif
+}
+uint64_t
+esl_ntoh64(uint64_t net_int64)
+{
+#ifdef WORDS_BIGENDIAN
+  return net_int64;
+#else
+  esl_byteswap((char *) &net_int64, 8);
+  return net_int64;
+#endif
+}
+
+/* Function:  esl_hton16()
+ * Synopsis:  Convert 2-byte integer from host-order to network-order.
+ *
+ * Purpose:   Convert a 2-byte integer from host-order to network-order, and
+ *            return it.
+ * 
+ *            <esl_hton32()> and <esl_hton64()> do the same, but for 4-byte
+ *            and 8-byte integers, respectively.
+ */
+uint16_t
+esl_hton16(uint16_t hostshort)
+{
+#ifdef WORDS_BIGENDIAN
+  return hostshort;
+#else
+  esl_byteswap((char *) &hostshort, 2);
+  return hostshort;
+#endif
+}
+uint32_t
+esl_hton32(uint32_t hostlong)
+{
+#ifdef WORDS_BIGENDIAN
+  return hostlong;
+#else
+  esl_byteswap((char *) &hostlong, 4);
+  return hostlong;
+#endif
+}
+uint64_t
+esl_hton64(uint64_t host_int64)
+{
+#ifdef WORDS_BIGENDIAN
+  return host_int64;
+#else
+  esl_byteswap((char *) &host_int64, 8);
+  return host_int64;
+#endif
+}
+
+
+/* Function:  esl_fread_u16()
+ * Synopsis:  Read network-order integer from a stream.
+ *
+ * Purpose:   Read a 2-byte network-order integer from <fp>, convert to
+ *            host order, leave it in <ret_result>.
+ *            
+ *            <esl_fread_u32()> and <esl_fread_u64()> do the same, but
+ *            for 4-byte and 8-byte integers, respectively.
+ *
+ * Returns:   <eslOK> on success, and <eslFAIL> on <fread()> failure.
+ */
+int
+esl_fread_u16(FILE *fp, uint16_t *ret_result)
+{
+  uint16_t result;
+  if (fread(&result, sizeof(uint16_t), 1, fp) != 1) return eslFAIL;
+  *ret_result = esl_ntoh16(result);
+  return eslOK;
+}
+int
+esl_fread_u32(FILE *fp, uint32_t *ret_result)
+{
+  uint32_t result;
+  if (fread(&result, sizeof(uint32_t), 1, fp) != 1) return eslFAIL;
+  *ret_result = esl_ntoh32(result);
+  return eslOK;
+}
+int
+esl_fread_u64(FILE *fp, uint64_t *ret_result)
+{
+  uint64_t result;
+  if (fread(&result, sizeof(uint64_t), 1, fp) != 1) return eslFAIL;
+  *ret_result = esl_ntoh64(result);
+  return eslOK;
+}
+int
+esl_fread_i16(FILE *fp, int16_t *ret_result)
+{
+  int16_t result;
+  if (fread(&result, sizeof(int16_t), 1, fp) != 1) return eslFAIL;
+  *ret_result = (int16_t) esl_ntoh16((uint16_t) result);
+  return eslOK;
+}
+int
+esl_fread_i32(FILE *fp, int32_t *ret_result)
+{
+  int32_t result;
+  if (fread(&result, sizeof(int32_t), 1, fp) != 1) return eslFAIL;
+  *ret_result = (int32_t) esl_ntoh32((uint32_t) result);
+  return eslOK;
+}
+int
+esl_fread_i64(FILE *fp, int64_t *ret_result)
+{
+  int64_t result;
+  if (fread(&result, sizeof(int64_t), 1, fp) != 1) return eslFAIL;
+  *ret_result = (int64_t) esl_ntoh64((uint64_t) result);
+  return eslOK;
+}
+
+
+/* Function:  esl_fwrite_u16()
+ * Synopsis:  Write an integer to a stream in network-order.
+ *
+ * Purpose:   Write a 2-byte host-order integer <n> to stream <fp>
+ *            in network order.
+ *            
+ *            <esl_fwrite_u32()> and <esl_fwrite_u64()> do the same, but
+ *            for 4-byte and 8-byte integers, respectively.
+ *
+ * Returns:   <eslOK> on success, and <eslFAIL> on <fwrite()> failure.
+ */
+int
+esl_fwrite_u16(FILE *fp, uint16_t n)
+{
+  n = esl_hton16(n);
+  if (fwrite(&n, sizeof(uint16_t), 1, fp) != 1) return eslFAIL;
+  return eslOK;
+}
+int
+esl_fwrite_u32(FILE *fp, uint32_t n)
+{
+  n = esl_hton32(n);
+  if (fwrite(&n, sizeof(uint32_t), 1, fp) != 1) return eslFAIL;
+  return eslOK;
+}
+int
+esl_fwrite_u64(FILE *fp, uint64_t n)
+{
+  n = esl_hton64(n);
+  if (fwrite(&n, sizeof(uint64_t), 1, fp) != 1) return eslFAIL;
+  return eslOK;
+}
+int
+esl_fwrite_i16(FILE *fp, int16_t n)
+{
+  n = (int16_t) esl_hton16((uint16_t) n);
+  if (fwrite(&n, sizeof(int16_t), 1, fp) != 1) return eslFAIL;
+  return eslOK;
+}
+int
+esl_fwrite_i32(FILE *fp, int32_t n)
+{
+  n = (int32_t) esl_hton32((uint32_t) n);
+  if (fwrite(&n, sizeof(int32_t), 1, fp) != 1) return eslFAIL;
+  return eslOK;
+}
+int
+esl_fwrite_i64(FILE *fp, int64_t n)
+{
+  n = (int64_t) esl_hton64((uint64_t) n);
+  if (fwrite(&n, sizeof(int64_t), 1, fp) != 1) return eslFAIL;
+  return eslOK;
+}
+
+
+/* Function:  esl_fread_offset()
+ * Synopsis:  Read an offset portably.
+ *
+ * Purpose:   Read a file offset from the stream <fp> (which would usually
+ *            be a save file), and store it in <ret_offset>.
+ *            
+ *            Offsets may have been saved by a different machine
+ *            than the machine that reads them. The writer and the reader
+ *            may differ in byte order and in width (<sizeof(off_t)>). 
+ *            
+ *            Byte order is dealt with by saving offsets in 
+ *            network byte order, and converting them to host byte order
+ *            when they are read (if necessary). 
+ *            
+ *            Width is dealt with by the <sz> argument, which must be
+ *            either 4 or 8, specifying that the saved offset is a
+ *            32-bit versus 64-bit <off_t>. If the reading host
+ *            <off_t> width matches the <sz> of the writer, no
+ *            problem. If <sz> is 4 but the reading host has 64-bit
+ *            <off_t>'s, this is also no problem; the conversion
+ *            always works. If <sz> is 64 but the reading host has
+ *            only 32-bit <off_t>, we cannot guarantee that we have
+ *            sufficient dynamic range to represent the offset; if
+ *            the stored offset is too large to represent in a 32-bit
+ *            offset, we throw a fatal <eslEINCOMPAT> error.
+ *
+ * Returns:   <eslOK> on success; <eslFAIL> on a read failure.
+ *
+ * Throws:    <eslEINVAL> if <sz> is something other than 4 or 8;
+ *            <eslEINCOMPAT> if the stored offset is too large for
+ *            the reader to represent (the machine that wrote the
+ *            SSI file used 64 bit offsets, the reader uses 32
+ *            bit offsets, and this offset is too large to represent
+ *            in a 32 bit offset).
+ */
+int			
+esl_fread_offset(FILE *fp, int sz, off_t *ret_offset)
+{
+  int       status;
+  uint32_t  x32;
+  uint64_t  x64;
+
+  if      (sz == 8)
+    {
+      if (esl_fread_u64(fp, &x64) != eslOK) { status = eslFAIL; goto ERROR; }
+      if (sizeof(off_t) == 4 && x64 > INT32_MAX) 
+	ESL_XEXCEPTION(eslEINCOMPAT, "can't read 64-bit off_t on this 32-bit host");
+      *ret_offset = (off_t) x64; 
+    }
+  else if (sz == 4)
+    {
+      if (esl_fread_u32(fp, &x32) != eslOK) { status = eslFAIL; goto ERROR; }
+      *ret_offset = (off_t) x32;
+    }
+  else ESL_XEXCEPTION(eslEINVAL, "offsets must be 32 or 64 bits");
+  return eslOK;
+
+ ERROR:
+  *ret_offset = 0;
+  return status;
+}
+
+/* Function:  esl_fwrite_offset()
+ * Synopsis:  Write an offset portably.
+ *
+ * Purpose:   Portably write (save) <offset> to the stream <fp>, in network
+ *            byte order. 
+ *
+ * Returns:   <eslOK> on success; <eslFAIL> on write failure.
+ *
+ * Throws:    <eslEINVAL> if <off_t> is something other than a 32-bit or
+ *            64-bit integer on this machine, in which case we don't know
+ *            how to deal with it portably.
+ */
+int
+esl_fwrite_offset(FILE *fp, off_t offset)
+{
+  if      (sizeof(off_t) == 4) return esl_fwrite_u32(fp, offset);
+  else if (sizeof(off_t) == 8) return esl_fwrite_u64(fp, offset);
+  else ESL_EXCEPTION(eslEINVAL, "off_t is neither 32-bit nor 64-bit");
+  /*UNREACHED*/
+  return eslEINCONCEIVABLE;
+}
+
+
+/*****************************************************************
+ * 5. Unit tests
+ *****************************************************************/
+#ifdef eslSSI_TESTDRIVE
+
+#include "esl_arr2.h"
+#include "esl_getopts.h"
+#include "esl_sq.h"
+#include "esl_sqio.h"
+#include "esl_random.h"
+#include "esl_randomseq.h"
+
+struct ssi_testdata {
+  int    nfiles;        // generate this many files...
+  int    nseq;          //  ... with this many sequences per file ...
+  int    maxL;          //  ... with sequence lengths 1..maxL.
+
+  char **sqfile;        // seq file names,   [0..nfiles-1]
+  char **seqname;       // seq names,        [0..nfiles*nseq-1] = "seq%d-file%d"
+  char **seqdesc;       // seq descriptions, [0..nfiles*nseq-1] = "desc%d-file%d", used as secondary keys
+  int   *seqlen;        // seq lengths,      [0..nfiles*nseq-1] 
+  char **seq;
+};
+
+static struct ssi_testdata *
+ssi_testdata_create(ESL_RANDOMNESS *rng, int max_nfiles, int max_nseq, int maxL, int do_dupname)
+{
+  char   msg[] = "esl_ssi test data creation failed";
+  struct ssi_testdata *td;
+  double  p[4] = { 0.25, 0.25, 0.25, 0.25 };   // composition of random generated DNA seqs 
+  FILE   *fp;
+  ESL_SQ *sq;
+  int     i,j;
+
+  if ( (td = malloc(sizeof(struct ssi_testdata))) == NULL) esl_fatal(msg);
+  td->nfiles        = 1 + esl_rnd_Roll(rng, max_nfiles); // 1..max_nfiles
+  td->nseq          = 2 + esl_rnd_Roll(rng, max_nseq-1); // 2..max_nseq   Need at least 2 for dup test to always be valid
+  td->maxL          = maxL;
+
+   /* Create <td->nfiles> sequence tmpfile names. */
+  if ( (td->sqfile = malloc(sizeof(char *) * td->nfiles)) == NULL) esl_fatal(msg);
+  for (j = 0; j < td->nfiles; j++)
+    if ( esl_sprintf(&(td->sqfile[j]), "esltmpXXXXXX"  ) != eslOK) esl_fatal(msg);
+
+  /* Create <td->nfiles*td->nseq> sequences with random lengths up to <maxL> */
+  if ( (td->seq     = malloc(sizeof(char *) * td->nseq * td->nfiles)) == NULL) esl_fatal(msg);
+  if ( (td->seqname = malloc(sizeof(char *) * td->nseq * td->nfiles)) == NULL) esl_fatal(msg);
+  if ( (td->seqlen  = malloc(sizeof(int)    * td->nseq * td->nfiles)) == NULL) esl_fatal(msg);
+  if ( (td->seqdesc = malloc(sizeof(char *) * td->nseq * td->nfiles)) == NULL) esl_fatal(msg); 
+  for (i = 0; i < td->nseq*td->nfiles; i++)
+    {
+      td->seqlen[i] = 1 + esl_rnd_Roll(rng, td->maxL); /* 1..maxL */
+      if ( (td->seq[i] = malloc(sizeof(char) * (td->seqlen[i]+1)))        == NULL)  esl_fatal(msg);
+      if ( esl_rsq_IID(rng, "ACGT", p, 4, td->seqlen[i], td->seq[i])      != eslOK) esl_fatal(msg);
+      if ( esl_sprintf(&(td->seqname[i]), "seq%d-file%d",  i, i/td->nseq) != eslOK) esl_fatal(msg);
+      if ( esl_sprintf(&(td->seqdesc[i]), "desc%d-file%d", i, i/td->nseq) != eslOK) esl_fatal(msg);
+    }
+
+  /* If we were asked to poison with a duplicate key, do it (randomly duplicating a primary or secondary key) */
+  if (do_dupname)
+    {
+      i = esl_rnd_Roll(rng, td->nseq * td->nfiles - 1);             // 0..n-2
+      j = i + 1 + esl_rnd_Roll(rng, td->nseq * td->nfiles - i - 1); // i+1..n-1
+      if (esl_rnd_Roll(rng, 2) == 0)  {
+        strcpy(td->seqname[i], "DUP");  // Allocated space is guaranteed to be enough,
+        strcpy(td->seqname[j], "DUP");  //   because the original name was "seq%d-file%d"
+      } else {
+        strcpy(td->seqdesc[i], "DUP");
+        strcpy(td->seqdesc[j], "DUP");
+      }
+    }
+
+  /* Save them to files. */
+  for (j = 0; j < td->nfiles; j++)
+    {
+      if (esl_tmpfile_named(td->sqfile[j], &fp) != eslOK) esl_fatal(msg);
+      for (i = j*td->nseq; i < (j+1)*td->nseq; i++)
+	{
+	  if ( (sq = esl_sq_CreateFrom(td->seqname[i], td->seq[i], td->seqdesc[i], NULL, NULL)) == NULL)  esl_fatal(msg);
+	  if ( esl_sqio_Write(fp, sq, eslSQFILE_FASTA, FALSE) != eslOK) esl_fatal(msg);
+	  esl_sq_Destroy(sq);
+	}
+      fclose(fp);
+    }
+
+  return td;
+}
+
+static void
+ssi_testdata_destroy(struct ssi_testdata *td)
+{
+  int j;
+  for (j = 0; j < td->nfiles; j++) remove(td->sqfile[j]);
+  esl_arr2_Destroy((void **) td->sqfile,  td->nfiles);
+  esl_arr2_Destroy((void **) td->seqname, td->nseq*td->nfiles);
+  esl_arr2_Destroy((void **) td->seqdesc, td->nseq*td->nfiles);
+  esl_arr2_Destroy((void **) td->seq,     td->nseq*td->nfiles);
+  free(td->seqlen);
+  free(td);
+}
+
+static void
+utest_enchilada(ESL_GETOPTS *go, ESL_RANDOMNESS *rng, int do_external, int do_dupkeys)
+{
+  char         msg[]      = "esl_ssi whole enchilada test failed";
+  struct ssi_testdata *td = NULL;
+  int          nq         = 10;      // number of SSI-based retrievals to test
+  char        *ssifile    = NULL;    // Index creation: ssifile to create.
+  ESL_NEWSSI  *ns         = NULL;    //   new SSI index data
+  ESL_SQFILE  *sqfp       = NULL;    //   open FASTA file that we're indexing
+  ESL_SQ      *sq         = NULL;    //   a sequence from <sqfp>
+  uint16_t     fh;                   //   handle on an indexed fasta file, from _AddFile, for _AddKey
+  ESL_SSI     *ssi        = NULL;    // Retrieval testing: open SSI index to use
+  char         query[32];            //   name of sequence to retrieve
+  char        *qfile;                //   retrieved name of file it's in
+  int          qfmt;                 //   retrieved format of that file (fasta)
+  off_t        roff;                 //   retrieved record offset of it
+  int          i,j;
+  int          status;
+  
+  td = ssi_testdata_create(rng, 
+                           esl_opt_GetInteger(go, "-F"),  // max # of seq files
+                           esl_opt_GetInteger(go, "-N"),  // max # of seqs per file
+                           esl_opt_GetInteger(go, "-L"),  // max seq length
+                           do_dupkeys);                   // if you poison w/ dup keys, _Write should fail.
+
+  /* Create an ssi index of all the FASTA files. */
+  if (esl_strdup(td->sqfile[0], -1, &ssifile) != eslOK) esl_fatal(msg);
+  if (esl_strcat(&ssifile,  -1, ".ssi", 4)    != eslOK) esl_fatal(msg);
+  if (esl_newssi_Open(ssifile, TRUE, &ns)     != eslOK) esl_fatal(msg);
+  if ((sq = esl_sq_Create())                  == NULL)  esl_fatal(msg);
+  if (do_external)
+    if (activate_external_sort(ns)            != eslOK) esl_fatal(msg);
+  for (j = 0; j < td->nfiles; j++)
+    {
+      if (esl_sqfile_Open(td->sqfile[j], eslSQFILE_UNKNOWN, NULL, &sqfp) != eslOK) esl_fatal(msg);
+      if (esl_newssi_AddFile(ns, td->sqfile[j], sqfp->format, &fh)       != eslOK) esl_fatal(msg);
+      while ((status = esl_sqio_Read(sqfp, sq)) == eslOK)
+	{
+	  if (esl_newssi_AddKey  (ns, sq->name, fh, sq->roff, sq->doff, sq->L) != eslOK) esl_fatal(msg);
+	  if (esl_newssi_AddAlias(ns, sq->desc, sq->name)                      != eslOK) esl_fatal(msg);
+	  esl_sq_Reuse(sq);
+	}
+      if (status != eslEOF) esl_fatal(msg);
+      esl_sqfile_Close(sqfp);
+    }
+  esl_sq_Destroy(sq);
+
+  /* Save the SSI index to a file. */
+  status = esl_newssi_Write(ns);
+  if (  do_dupkeys && status != eslEDUP) esl_fatal(msg);
+  if (! do_dupkeys && status != eslOK)   esl_fatal(msg);
+  esl_newssi_Close(ns);
+  
+  /* Open the SSI index - now we'll use it to retrieve <nq> random sequences. */
+  if (! do_dupkeys)
+    {
+      if (esl_ssi_Open(ssifile, &ssi) != eslOK) esl_fatal(msg);
+      sq = esl_sq_Create();
+      while (nq--)
+        {
+          /* Choose a seq and file */
+          i = esl_rnd_Roll(rng, td->nseq*td->nfiles);
+          j = i/td->nseq;
+          if (esl_rnd_Roll(rng, 2) == 0) sprintf(query, "seq%d-file%d",  i, j);  // by primary key
+          else                           sprintf(query, "desc%d-file%d", i, j);  // by secondary key
+
+          /* Retrieve it */
+          if ( esl_ssi_FindName(ssi, query, &fh, &roff, NULL, NULL) != eslOK) esl_fatal(msg);
+          if ( esl_ssi_FileInfo(ssi, fh, &qfile, &qfmt)             != eslOK) esl_fatal(msg);      
+          if ( esl_sqfile_Open(qfile, qfmt, NULL, &sqfp)            != eslOK) esl_fatal(msg);
+          if ( esl_sqfile_Position(sqfp, roff)                      != eslOK) esl_fatal(msg);
+          if ( esl_sqio_Read(sqfp, sq)                              != eslOK) esl_fatal(msg);
+
+          /* Check that it's the right one */
+          if (strcmp(sq->name, query) != 0 && strcmp(sq->desc, query) != 0) esl_fatal(msg);
+          if (sq->n != td->seqlen[i])            esl_fatal(msg);
+          if (strcmp(sq->seq, td->seq[i])  != 0) esl_fatal(msg);
+          if (strcmp(qfile, td->sqfile[j]) != 0) esl_fatal(msg);
+
+          esl_sq_Reuse(sq);
+          esl_sqfile_Close(sqfp);
+        }
+      remove(ssifile);  // in the dup keys test, ssifile is removed by _Write().
+      esl_sq_Destroy(sq);
+      esl_ssi_Close(ssi);
+    }
+
+  ssi_testdata_destroy(td);
+  free(ssifile);
+}
+#endif /*eslSSI_TESTDRIVE*/
+
+
+/*****************************************************************
+ * 5. Test driver
+ *****************************************************************/ 
+
+#ifdef eslSSI_TESTDRIVE
+#include "esl_config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "easel.h"
+#include "esl_getopts.h"
+#include "esl_sq.h"
+#include "esl_sqio.h"
+#include "esl_ssi.h"
+#include "esl_random.h"
+#include "esl_randomseq.h"
+
+static ESL_OPTIONS options[] = {
+  /* name           type      default  env  range toggles reqs incomp  help                                       docgroup*/
+  { "-h",        eslARG_NONE,   FALSE,  NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",             0 },
+  { "-F",        eslARG_INT,      "3",  NULL, NULL,  NULL,  NULL, NULL, "max number of test files",                         0 },
+  { "-L",        eslARG_INT,   "1000",  NULL, NULL,  NULL,  NULL, NULL, "max length of test sequences",                     0 },
+  { "-N",        eslARG_INT,     "10",  NULL, NULL,  NULL,  NULL, NULL, "max number of test sequences per file",            0 },
+  { "-s",        eslARG_INT,      "0",  NULL, NULL,  NULL,  NULL, NULL, "set random number seed to <n>",                    0 },
+  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+};
+static char usage[]  = "[-options]";
+static char banner[] = "test driver for ssi module";
+
+int 
+main(int argc, char **argv)
+{
+  ESL_GETOPTS    *go  = esl_getopts_CreateDefaultApp(options, 0, argc, argv, banner, usage);
+  ESL_RANDOMNESS *rng = esl_randomness_Create(esl_opt_GetInteger(go, "-s"));
+
+  fprintf(stderr, "## %s\n", argv[0]);
+  fprintf(stderr, "#  rng seed = %" PRIu32 "\n", esl_randomness_GetSeed(rng));
+
+  /*                       do_external  do_dupkeys */
+  utest_enchilada(go, rng, FALSE,       FALSE);
+  utest_enchilada(go, rng, TRUE,        FALSE);
+  utest_enchilada(go, rng, FALSE,       TRUE);
+  utest_enchilada(go, rng, TRUE,        TRUE);
+
+  esl_randomness_Destroy(rng);
+  esl_getopts_Destroy(go);
+
+  fprintf(stderr, "#  status = ok\n");
+  return eslOK;
+}
+#endif /*eslSSI_TESTDRIVE*/
+
+
+
+/*****************************************************************
+ * 5. Example code.
+ ****************************************************************/
+#ifdef eslSSI_EXAMPLE
+/* gcc -o example -g -Wall -DeslSSI_EXAMPLE esl_ssi.c easel.c
+ * esl-shuffle -o foo.fa -N 1000 -G --amino -L 400 
+ * ./example foo.fa
+ */
+/*::cexcerpt::ssi_example::begin::*/
+#include <stdio.h>
+#include "easel.h"
+#include "esl_ssi.h"
+
+int 
+main(int argc, char **argv)
+{
+  ESL_NEWSSI *ns;
+  char    *fafile;              /* name of FASTA file                   */
+  FILE    *fp;                  /* opened FASTA file for reading        */
+  char    *ssifile;             /* name of SSI file                     */
+  uint16_t fh;                  /* file handle SSI associates w/ fafile */
+  char    *buf = NULL;          /* growable buffer for esl_fgets()      */
+  int      n   = 0;             /* length of buf                        */
+  char    *s, *seqname;		
+  off_t    seq_offset;
+  int      status;
+
+  /* Open a new SSI index named <fafile>.ssi */
+  fafile = argv[1];
+  esl_strdup(fafile,   -1, &ssifile);  
+  esl_strcat(&ssifile, -1, ".ssi", 4); 
+  status = esl_newssi_Open(ssifile, FALSE, &ns);
+  if      (status == eslENOTFOUND)   esl_fatal("failed to open SSI index %s", ssifile);
+  else if (status == eslEOVERWRITE)  esl_fatal("SSI index %s already exists; delete or rename it", ssifile);
+  else if (status != eslOK)          esl_fatal("failed to create a new SSI index");
+
+  /* Collect the sequence names from a FASTA file into an index */
+  if ((fp = fopen(fafile, "r"))              == NULL)  esl_fatal("failed to open %s", fafile);
+  if (esl_newssi_AddFile(ns, fafile, 1, &fh) != eslOK) esl_fatal("failed to add %s to index: %s", fafile, ns->errbuf);
+  seq_offset = ftello(fp);
+  while (esl_fgets(&buf, &n, fp) == eslOK)
+    {
+      if (*buf == '>') {
+	s = buf+1;                           /* skip past >                */
+	esl_strtok(&s, " \t\n", &seqname);   /* name = 1st token on > line */
+	if (esl_newssi_AddKey(ns, seqname, fh, seq_offset, 0, 0) != eslOK)
+	  esl_fatal("failed to add key %s to index: %s", seqname, ns->errbuf);
+      }
+      seq_offset = ftello(fp);				 
+    }
+  free(buf);
+  fclose(fp);
+
+  /* Save the index to disk */
+  status = esl_newssi_Write(ns);
+  if      (status == eslEDUP)     esl_fatal("SSI index construction failed:\n  %s", ns->errbuf);
+  else if (status == eslERANGE)   esl_fatal("SSI index file size exceeds maximum allowed by your filesystem");
+  else if (status == eslESYS)     esl_fatal("SSI index sort failed:\n  %s", ns->errbuf);
+  else if (status != eslOK)       esl_fatal("SSI indexing failed:\n  %s", ns->errbuf);
+  esl_newssi_Close(ns);  
+  free(ssifile);
+  return 0;
+}
+/*::cexcerpt::ssi_example::end::*/
+#endif /*eslSSI_EXAMPLE*/
+
+
+#ifdef eslSSI_EXAMPLE2
+/* gcc -o example2 -g -Wall -DeslSSI_EXAMPLE2 esl_ssi.c easel.c
+ * ./example2 random77 foo.fa.ssi 
+ */
+/*::cexcerpt::ssi_example2::begin::*/
+#include <stdio.h>
+#include "easel.h"
+#include "esl_ssi.h"
+
+int main(int argc, char **argv)
+{
+  ESL_SSI *ssi;
+  char    *seqname;             /* name of sequence to retrieve         */
+  char    *ssifile;             /* name of SSI file                     */
+  uint16_t fh;                  /* file handle SSI associates w/ fafile */
+  char    *fafile;              /* name of FASTA file                   */
+  int      fmt;                 /* format code (1, in this example)     */
+  off_t    offset;              /* disk offset of seqname in fafile     */
+  FILE    *fp;                  /* opened FASTA file for reading        */
+  char    *buf = NULL;          /* growable buffer for esl_fgets()      */
+  int      n = 0;               /* size of buffer                       */
+
+  seqname = argv[1];
+  ssifile = argv[2];
+
+  if (esl_ssi_Open(ssifile, &ssi)                              != eslOK) esl_fatal("open failed");
+  if (esl_ssi_FindName(ssi, seqname, &fh, &offset, NULL, NULL) != eslOK) esl_fatal("find failed");
+  if (esl_ssi_FileInfo(ssi, fh, &fafile, &fmt)                 != eslOK) esl_fatal("info failed");
+  /* you can't close the ssi file yet - fafile is pointing into it! */
+
+  if ((fp = fopen(fafile, "r"))     == NULL)  esl_fatal("failed to open %s", fafile);
+  if (fseeko(fp, offset, SEEK_SET)  != 0)     esl_fatal("failed to position %s", fafile);
+  if (esl_fgets(&buf, &n, fp)       != eslOK) esl_fatal("failed to get name/desc line");
+  do {
+    printf("%s", buf); 
+  } while (esl_fgets(&buf, &n, fp) == eslOK && *buf != '>');
+  
+  esl_ssi_Close(ssi);  
+  fclose(fp);  
+  free(buf);
+  return 0;
+}
+/*::cexcerpt::ssi_example2::end::*/
+#endif /*eslSSI_EXAMPLE2*/
+
diff -Nur hmmer-3.3.orig/easel/esl_ssi.h hmmer-3.3/easel/esl_ssi.h
--- hmmer-3.3.orig/easel/esl_ssi.h	2019-11-18 14:23:44.000000000 +0100
+++ hmmer-3.3/easel/esl_ssi.h	2019-12-06 15:39:25.116539217 +0100
@@ -110,6 +110,8 @@
 /* 1. Using (reading) SSI indices */
 extern int  esl_ssi_Open(const char *filename, ESL_SSI **ret_ssi);
 extern void esl_ssi_Close(ESL_SSI *ssi);
+extern void esl_ssi_Reset(ESL_SSI *ssi);
+
 extern int  esl_ssi_FindName(ESL_SSI *ssi, const char *key,
 			     uint16_t *ret_fh, off_t *ret_roff, off_t *opt_doff, int64_t *opt_L);
 extern int  esl_ssi_FindNumber(ESL_SSI *ssi, int64_t nkey,
diff -Nur hmmer-3.3.orig/src/hmmer.h hmmer-3.3/src/hmmer.h
--- hmmer-3.3.orig/src/hmmer.h	2019-11-18 14:23:12.000000000 +0100
+++ hmmer-3.3/src/hmmer.h	2019-12-06 15:39:25.116539217 +0100
@@ -1596,6 +1596,7 @@
 extern int  p7_hmmfile_OpenNoDB (const char *filename, char *env, P7_HMMFILE **ret_hfp); /* deprecated */
 extern int  p7_hmmfile_OpenBuffer(const char *buffer, int size, P7_HMMFILE **ret_hfp);
 extern void p7_hmmfile_Close(P7_HMMFILE *hfp);
+extern int  p7_hmmfile_Reset(char* env, P7_HMMFILE *hfp, char *errbuf);
 #ifdef HMMER_THREADS
 extern int  p7_hmmfile_CreateLock(P7_HMMFILE *hfp);
 #endif
diff -Nur hmmer-3.3.orig/src/hmmer.h.orig hmmer-3.3/src/hmmer.h.orig
--- hmmer-3.3.orig/src/hmmer.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ hmmer-3.3/src/hmmer.h.orig	2019-11-18 14:23:12.000000000 +0100
@@ -0,0 +1,1815 @@
+/* The all-encompassing include file for HMMER.
+ * All-encompassing because there's a lot of crossdependency.
+ * There's some opportunity for modularity, but not a lot.
+ *
+ *    1. P7_HMM:         a core model.
+ *    2. P7_PROFILE:     a scoring profile, and its implicit model.
+ *    3. P7_BG:          a null (background) model.
+ *    4. P7_TRACE:       a traceback path (alignment of seq to profile).
+ *    5. P7_HMMFILE:     an HMM save file or database, open for reading.
+ *    6. P7_GMX:         a "generic" dynamic programming matrix
+ *    7. P7_PRIOR:       mixture Dirichlet prior for profile HMMs
+ *    8. P7_SPENSEMBLE:  segment pair ensembles for domain locations
+ *    9. P7_ALIDISPLAY:  an alignment formatted for printing
+ *   10. P7_DOMAINDEF:   reusably managing workflow in annotating domains
+ *   11. P7_TOPHITS:     ranking lists of top-scoring hits
+ *   12. P7_SCOREDATA:     data used in diagonal recovery and extension
+ *   13. P7_HMM_WINDOW:  data used to track lists of sequence windows
+ *   14. Inclusion of the architecture-specific optimized implementation.
+ *   16. P7_PIPELINE:    H3's accelerated seq/profile comparison pipeline
+ *   17. P7_BUILDER:     configuration options for new HMM construction.
+ *   18. Declaration of functions in HMMER's exposed API.
+ *   
+ * Also, see impl_{sse,vmx}/impl_{sse,vmx}.h for additional API
+ * specific to the acceleration layer; in particular, the P7_OPROFILE
+ * structure for an optimized profile.
+ */
+#ifndef P7_HMMERH_INCLUDED
+#define P7_HMMERH_INCLUDED
+#include "p7_config.h"
+
+#include <stdio.h>		/* FILE */
+
+#ifdef HMMER_MPI
+#include "mpi.h"
+#endif
+
+#ifdef HMMER_THREADS
+#include <pthread.h>
+#endif
+
+#include "easel.h"
+#include "esl_alphabet.h"	/* ESL_DSQ, ESL_ALPHABET */
+#include "esl_dmatrix.h"	/* ESL_DMATRIX           */
+#include "esl_getopts.h"	/* ESL_GETOPTS           */
+#include "esl_histogram.h"      /* ESL_HISTOGRAM         */
+#include "esl_hmm.h"	        /* ESL_HMM               */
+#include "esl_keyhash.h"        /* ESL_KEYHASH           */
+#include "esl_mixdchlet.h"	/* ESL_MIXDCHLET         */
+#include "esl_msa.h"		/* ESL_MSA               */
+#include "esl_random.h"		/* ESL_RANDOMNESS        */
+#include "esl_rand64.h" /* ESL_RAND64 */
+#include "esl_sq.h"		/* ESL_SQ                */
+#include "esl_scorematrix.h"    /* ESL_SCOREMATRIX       */
+#include "esl_stopwatch.h"      /* ESL_STOPWATCH         */
+
+
+
+/* Search modes. */
+#define p7_NO_MODE   0
+#define p7_LOCAL     1		/* multihit local:  "fs" mode   */
+#define p7_GLOCAL    2		/* multihit glocal: "ls" mode   */
+#define p7_UNILOCAL  3		/* unihit local: "sw" mode      */
+#define p7_UNIGLOCAL 4		/* unihit glocal: "s" mode      */
+
+#define p7_IsLocal(mode)  (mode == p7_LOCAL || mode == p7_UNILOCAL)
+#define p7_IsMulti(mode)  (mode == p7_LOCAL || mode == p7_GLOCAL)
+
+#define p7_NEVPARAM 6	/* number of statistical parameters stored in models                      */
+#define p7_NCUTOFFS 6	/* number of Pfam score cutoffs stored in models                          */
+#define p7_NOFFSETS 3	/* number of disk offsets stored in models for hmmscan's fast model input */
+enum p7_evparams_e {    p7_MMU  = 0, p7_MLAMBDA = 1,     p7_VMU = 2,  p7_VLAMBDA = 3, p7_FTAU = 4, p7_FLAMBDA = 5 };
+enum p7_cutoffs_e  {     p7_GA1 = 0,     p7_GA2 = 1,     p7_TC1 = 2,      p7_TC2 = 3,  p7_NC1 = 4,     p7_NC2 = 5 };
+enum p7_offsets_e  { p7_MOFFSET = 0, p7_FOFFSET = 1, p7_POFFSET = 2 };
+
+#define p7_EVPARAM_UNSET -99999.0f  /* if evparam[0] is unset, then all unset                         */
+#define p7_CUTOFF_UNSET  -99999.0f  /* if cutoff[XX1] is unset, then cutoff[XX2] unset, XX={GA,TC,NC} */
+#define p7_COMPO_UNSET   -1.0f      /* if compo[0] is unset, then all unset                           */
+
+/* Option flags when creating multiple alignments with p7_tracealign_*() */
+#define p7_DEFAULT             0
+#define p7_DIGITIZE            (1<<0)
+#define p7_ALL_CONSENSUS_COLS  (1<<1)
+#define p7_TRIM                (1<<2)
+
+/* Option flags when creating faux traces with p7_trace_FauxFromMSA() */
+#define p7_MSA_COORDS	       (1<<0) /* default: i = unaligned seq residue coords     */
+
+/* Which strand(s) should be searched */
+enum p7_strands_e {    p7_STRAND_TOPONLY  = 0, p7_STRAND_BOTTOMONLY = 1,  p7_STRAND_BOTH = 2};
+
+/*****************************************************************
+ * 1. P7_HMM: a core model.
+ *****************************************************************/
+
+/* Bit flags used in <hmm->flags>: optional annotation in an HMM
+ * 
+ * Flags marked with ! may not be changed nor used for other meanings,
+ * because they're codes used by HMMER2 (and earlier) that must be
+ * preserved for reverse compatibility with old HMMER files.
+ * 
+ * Why use flags? (So I don't ask this question of myself again:)
+ *   1. The way we allocate an HMM, we need to know if we're allocating
+ *      M-width annotation fields (RF, CS, CA, MAP) before we read the
+ *      annotation from the file.
+ *   2. Historically, H2 used flags, so we still need to read H2 flags
+ *      for backwards compatibility; so we may as well keep using them.
+ */
+#define p7H_HASBITS (1<<0)    /* obsolete (was: model has log-odds scores)       !*/
+#define p7H_DESC    (1<<1)    /* description exists (legacy; xref SRE:J5/114)    !*/
+#define p7H_RF      (1<<2)    /* #RF annotation available                        !*/
+#define p7H_CS      (1<<3)    /* #CS annotation available                        !*/
+#define p7H_XRAY    (1<<4)    /* obsolete (was: structural data available)       !*/
+#define p7H_HASPROB (1<<5)    /* obsolete (was: model in probability form)       !*/
+#define p7H_HASDNA  (1<<6)    /* obsolete (was: protein HMM->DNA seq params set) !*/
+#define p7H_STATS   (1<<7)    /* model has E-value statistics calibrated         !*/
+#define p7H_MAP     (1<<8)    /* alignment map is available                      !*/
+#define p7H_ACC     (1<<9)    /* accession is available (legacy; xref SRE:J5/114)!*/
+#define p7H_GA      (1<<10)   /* gathering thresholds available                  !*/
+#define p7H_TC      (1<<11)   /* trusted cutoffs available                       !*/
+#define p7H_NC      (1<<12)   /* noise cutoffs available                         !*/
+#define p7H_CA      (1<<13)   /* surface accessibilities available               !*/
+#define p7H_COMPO   (1<<14)   /* model-specific residue composition available     */
+#define p7H_CHKSUM  (1<<15)   /* model has an alignment checksum                  */
+#define p7H_CONS    (1<<16)   /* consensus residue line available                 */
+#define p7H_MMASK   (1<<17)   /* #MM annotation available                        !*/
+
+/* Indices of Plan7 main model state transitions, hmm->t[k][] */
+enum p7h_transitions_e {
+  p7H_MM = 0,
+  p7H_MI = 1,
+  p7H_MD = 2,
+  p7H_IM = 3,
+  p7H_II = 4,
+  p7H_DM = 5,
+  p7H_DD = 6 
+};
+#define p7H_NTRANSITIONS 7
+
+/* How the hmm->t[k] vector is interpreted as separate probability vectors. */
+#define P7H_TMAT(hmm, k) ((hmm)->t[k])
+#define P7H_TINS(hmm, k) ((hmm)->t[k]+3)
+#define P7H_TDEL(hmm, k) ((hmm)->t[k]+5)
+#define p7H_NTMAT 3
+#define p7H_NTDEL 2
+#define p7H_NTINS 2
+
+/* Some notes:
+ *   0. The model might be either in counts or probability form.
+ *   1. t[0] is special: t[0][TMM,TMI,TMD] are the begin->M_1,I_0,D_1 entry probabilities,
+ *      t[0][TIM,TII] are the I_0 transitions, and delete state 0 doesn't
+ *      exist. Therefore D[0] transitions and mat[0] emissions are unused.
+ *      To simplify some normalization code, we adopt a convention that these are set
+ *      to valid probability distributions: 1.0 for t[0][TDM] and mat[0][0],
+ *      and 0 for the rest.
+ *   2. t[M] is also special: TMD and TDD are 0 because there is no next delete state;
+ *      TDM is therefore 1.0 by definition. TMM and TDM are interpreted as the
+ *      M->E and D->E end transitions. t[M][TDM] must be 1.0, therefore.
+ */
+typedef struct p7_hmm_s {
+  /*::cexcerpt::plan7_core::begin::*/
+  int     M;                    /* length of the model (# nodes)                           */
+  float **t;                    /* transition prob's. t[(0),1..M][0..p7H_NTRANSITIONS-1]   */
+  float **mat;                  /* match emissions.  mat[1..M][0..K-1]                     */ 
+  float **ins;                  /* insert emissions. ins[1..M][0..K-1]                     */
+  /*::cexcerpt::plan7_core::end::*/
+
+  /* Annotation. Everything but <name> is optional. Flags are set when
+   * optional values are set. All the char *'s are proper nul-terminated
+   * strings, not just arrays. (hmm->map is an int array).
+   */
+  char    *name;                 /* name of the model                     (mandatory)      */ /* String, \0-terminated   */
+  char    *acc;	                 /* accession number of model (Pfam)      (optional: NULL) */ /* String, \0-terminated   */
+  char    *desc;                 /* brief (1-line) description of model   (optional: NULL) */ /* String, \0-terminated   */
+  char    *rf;                   /* reference line from alignment 1..M    (p7H_RF)         */ /* String; 0=' ', M+1='\0' */
+  char    *mm;                   /* model mask line from alignment 1..M   (p7H_MM)         */ /* String; 0=' ', M+1='\0' */
+  char    *consensus;		         /* consensus residue line        1..M    (p7H_CONS)       */ /* String; 0=' ', M+1='\0' */
+  char    *cs;                   /* consensus structure line      1..M    (p7H_CS)         */ /* String; 0=' ', M+1='\0' */
+  char    *ca;	                 /* consensus accessibility line  1..M    (p7H_CA)         */ /* String; 0=' ', M+1='\0' */
+
+  char    *comlog;               /* command line(s) that built model      (optional: NULL) */ /* String, \0-terminated   */
+  int      nseq;	         /* number of training sequences          (optional: -1)   */
+  float    eff_nseq;             /* effective number of seqs (<= nseq)    (optional: -1)   */
+  int	   max_length;           /* upper bound length, all but 1e-7 prob (optional: -1)   */
+  char    *ctime;	         /* creation date                         (optional: NULL) */
+  int     *map;	                 /* map of alignment cols onto model 1..M (p7H_MAP)        */ /* Array; map[0]=0 */
+  uint32_t checksum;             /* checksum of training sequences        (p7H_CHKSUM)     */
+  float    evparam[p7_NEVPARAM]; /* E-value params                        (p7H_STATS)      */
+  float    cutoff[p7_NCUTOFFS];  /* Pfam score cutoffs                    (p7H_{GA,TC,NC}) */
+  float    compo[p7_MAXABET];    /* model bg residue comp                 (p7H_COMPO)      */
+
+  off_t    offset;               /* HMM record offset on disk                              */
+  const ESL_ALPHABET *abc;       /* ptr to alphabet info (hmm->abc->K is alphabet size)    */
+  int      flags;                /* status flags                                           */
+} P7_HMM;
+
+
+/*****************************************************************
+ * 2. P7_PROFILE: a scoring profile, and its implicit model.
+ *****************************************************************/
+
+/* Indices for special state types in the length model, gm->xsc[x][]
+ */
+enum p7p_xstates_e { 
+  p7P_E = 0,
+  p7P_N = 1,
+  p7P_J = 2,
+  p7P_C = 3
+};
+#define p7P_NXSTATES 4
+
+/* Indices for transitions from the length modeling scores gm->xsc[][x]
+ */
+enum p7p_xtransitions_e {
+  p7P_LOOP = 0,
+  p7P_MOVE = 1
+};
+#define p7P_NXTRANS 2
+
+/* Indices for transition scores gm->tsc[k][] */
+/* order is optimized for dynamic programming */
+enum p7p_tsc_e {
+  p7P_MM = 0, 
+  p7P_IM = 1, 
+  p7P_DM = 2, 
+  p7P_BM = 3, 
+  p7P_MD = 4, 
+  p7P_DD = 5, 
+  p7P_MI = 6, 
+  p7P_II = 7, 
+};
+#define p7P_NTRANS 8
+
+/* Indices for residue emission score vectors
+ */
+enum p7p_rsc_e {
+  p7P_MSC = 0, 
+  p7P_ISC = 1
+};
+#define p7P_NR 2
+
+/* Accessing transition, emission scores */
+/* _BM is specially stored off-by-one: [k-1][p7P_BM] is score for entering at Mk */
+#define p7P_TSC(gm, k, s) ((gm)->tsc[(k) * p7P_NTRANS + (s)])
+#define p7P_MSC(gm, k, x) ((gm)->rsc[x][(k) * p7P_NR + p7P_MSC])
+#define p7P_ISC(gm, k, x) ((gm)->rsc[x][(k) * p7P_NR + p7P_ISC])
+
+
+typedef struct p7_profile_s {
+  float  *tsc;          /* transitions  [0.1..M-1][0..p7P_NTRANS-1], hand-indexed  */
+  float **rsc;          /* emissions [0..Kp-1][0.1..M][p7P_NR], hand-indexed       */
+  float   xsc[p7P_NXSTATES][p7P_NXTRANS]; /* special transitions [NECJ][LOOP,MOVE] */
+
+  int     mode;        	/* configured algorithm mode (e.g. p7_LOCAL)               */ 
+  int     L;		/* current configured target seq length                    */
+  int     allocM;	/* max # of nodes allocated in this structure              */
+  int     M;		/* number of nodes in the model                            */
+  int     max_length;	/* calculated upper bound on emitted seq length            */
+  float   nj;		/* expected # of uses of J; precalculated from loop config */
+
+  /* Info, most of which is a copy from parent HMM:                                       */
+  char  *name;			/* unique name of model                                   */
+  char  *acc;			/* unique accession of model, or NULL                     */
+  char  *desc;                  /* brief (1-line) description of model, or NULL           */
+  char  *rf;                    /* reference line from alignment 1..M; *rf=0 means unused */
+  char  *mm;                    /* modelmask line           1..M; *ref=0: unused     */
+  char  *cs;                    /* consensus structure line      1..M, *cs=0 means unused */
+  char  *consensus;		/* consensus residues to display in alignments, 1..M      */
+  float  evparam[p7_NEVPARAM]; 	/* parameters for determining E-values, or UNSET          */
+  float  cutoff[p7_NCUTOFFS]; 	/* per-seq/per-domain bit score cutoffs, or UNSET         */
+  float  compo[p7_MAXABET];	/* per-model HMM filter composition, or UNSET             */
+
+  /* Disk offset information for hmmpfam's fast model retrieval                           */
+  off_t  offs[p7_NOFFSETS];     /* p7_{MFP}OFFSET, or -1                                  */
+
+  off_t  roff;                  /* record offset (start of record); -1 if none            */
+  off_t  eoff;                  /* offset to last byte of record; -1 if unknown           */
+
+  const ESL_ALPHABET *abc;	/* copy of pointer to appropriate alphabet                */
+} P7_PROFILE;
+
+
+
+/*****************************************************************
+ * 3. P7_BG: a null (background) model.
+ *****************************************************************/
+
+/* This really contains three different things: 
+ *     
+ *   - the "null1" model, a one-state HMM consisting of background
+ *     frequencies <f> and a parameter <p1> for a target-length
+ *     dependent geometric;
+ *     
+ *   - the "bias filter" <fhmm> a two-state HMM composed from null1's
+ *     background <f> and the model's mean composition <compo>. This
+ *     model is constructed dynamically, every time a new profile is 
+ *     considered;
+ *     
+ *   - a single term <omega> that's needed by the "null2" model to set
+ *     a balance between the null1 and null2 scoring terms.  The null2
+ *     model is otherwise defined by construction, in p7_domaindef.c.
+ *
+ * Someday we might pull this apart into two or three separate
+ * objects.
+ */
+typedef struct p7_bg_s {
+  float   *f;		/* null1 background residue frequencies [0..K-1]: set at initialization    */
+  float    p1;		/* null1's transition prob: p7_bg_SetLength() sets this from target seq L  */
+
+  ESL_HMM *fhmm;	/* bias filter: p7_bg_SetFilter() sets this, from model's mean composition */
+
+  float    omega;	/* the "prior" on null2/null3: set at initialization (one omega for both null types)  */
+
+  const ESL_ALPHABET *abc;	/* reference to alphabet in use: set at initialization             */
+} P7_BG;
+
+/*****************************************************************
+ * 4. P7_TRACE:  a traceback (alignment of seq to profile).
+ *****************************************************************/
+
+/* Traceback structure for alignment of a model to a sequence.
+ *
+ * A traceback only makes sense in a triplet (tr, gm, dsq), for a
+ * given profile or HMM (with nodes 1..M) and a given digital sequence
+ * (with positions 1..L).
+ * 
+ * A traceback may be relative to a profile (usually) or to a core
+ * model (as a special case in model construction; see build.c). You
+ * can tell the difference by looking at the first statetype,
+ * tr->st[0]; if it's a p7T_S, it's for a profile, and if it's p7T_B,
+ * it's for a core model.
+ * 
+ * A "profile" trace uniquely has S,N,C,T,J states and their
+ * transitions; it also can have B->Mk and Mk->E internal entry/exit
+ * transitions for local alignments. It may not contain X states.
+ *
+ * A "core" trace may contain I0, IM, and D1 states and their
+ * transitions. A "core" trace can also have B->X->{MDI}k and
+ * {MDI}k->X->E transitions as a special hack in a build procedure, to
+ * deal with the case of a local alignment fragment implied by an
+ * input alignment, which is "impossible" for a core model.
+ * X "states" only appear in core traces, and only at these
+ * entry/exit places; some code depends on this.
+ *   
+ * A profile's N,C,J states emit on transition, not on state, so a
+ * path of N emits 0 residues, NN emits 1 residue, NNN emits 2
+ * residues, and so on. By convention, the trace always associates an
+ * emission-on-transition with the trailing (destination) state, so
+ * the first N, C, or J is stored in a trace as a nonemitter (i=0).
+ *
+ * A i coords in a traceback are usually 1..L with respect to an
+ * unaligned digital target sequence, but in the special case of
+ * traces faked from existing MSAs (as in hmmbuild), the coords may
+ * be 1..alen relative to an MSA's columns.
+ */
+
+/* State types */
+enum p7t_statetype_e {
+  p7T_BOGUS =  0,
+  p7T_M     =  1,
+  p7T_D     =  2,
+  p7T_I     =  3,
+  p7T_S     =  4,
+  p7T_N     =  5,
+  p7T_B     =  6, 
+  p7T_E     =  7,
+  p7T_C     =  8, 
+  p7T_T     =  9, 
+  p7T_J     = 10,
+  p7T_X     = 11, 	/* missing data: used esp. for local entry/exits */
+};
+#define p7T_NSTATETYPES 12
+
+typedef struct p7_trace_s {
+  int    N;		/* length of traceback                       */
+  int    nalloc;        /* allocated length of traceback             */
+  char  *st;		/* state type code                   [0..N-1]*/
+  int   *k;		/* node index; 1..M if M,D,I; else 0 [0..N-1]*/
+  int   *i;		/* pos emitted in dsq, 1..L; else 0  [0..N-1]*/
+  float *pp;		/* posterior prob of x_i; else 0     [0..N-1]*/
+  int    M;		/* model length M (maximum k)                */
+  int    L;		/* sequence length L (maximum i)             */
+
+  /* The following section is data generated by "indexing" a trace's domains */
+  int   ndom;		/* number of domains in trace (= # of B or E states) */
+  int  *tfrom,   *tto;	/* locations of B/E states in trace (0..tr->N-1)     */
+  int  *sqfrom,  *sqto;	/* first/last M-emitted residue on sequence (1..L)   */
+  int  *hmmfrom, *hmmto;/* first/last M state on model (1..M)                */
+  int   ndomalloc;	/* current allocated size of these stacks            */
+
+} P7_TRACE;
+
+
+
+/*****************************************************************
+ * 5. P7_HMMFILE:  an HMM save file or database, open for reading.
+ *****************************************************************/
+
+/* These tags need to be in temporal order, so we can do tests
+ * like "if (format >= p7_HMMFILE_3b) ..."
+ */
+enum p7_hmmfile_formats_e {
+  p7_HMMFILE_20 = 0,
+  p7_HMMFILE_3a = 1,
+  p7_HMMFILE_3b = 2,
+  p7_HMMFILE_3c = 3,
+  p7_HMMFILE_3d = 4,
+  p7_HMMFILE_3e = 5,
+  p7_HMMFILE_3f = 6,
+};
+
+typedef struct p7_hmmfile_s {
+  FILE         *f;		 /* pointer to stream for reading models                 */
+  char         *fname;	         /* (fully qualified) name of the HMM file; [STDIN] if - */
+  ESL_SSI      *ssi;		 /* open SSI index for model file <f>; NULL if none.     */
+
+  int           do_gzip;	/* TRUE if f is "gzip -dc |" (will pclose(f))           */ 
+  int           do_stdin;       /* TRUE if f is stdin (won't close f)                   */
+  int           newly_opened;	/* TRUE if we just opened the stream (and parsed magic) */
+  int           is_pressed;	/* TRUE if a pressed HMM database file (Pfam or equiv)  */
+
+  int            format;	/* HMM file format code */
+  int           (*parser)(struct p7_hmmfile_s *, ESL_ALPHABET **, P7_HMM **);  
+  ESL_FILEPARSER *efp;
+
+  /* If <is_pressed>, we can read optimized profiles directly, via:  */
+  FILE         *ffp;		/* MSV part of the optimized profile */
+  FILE         *pfp;		/* rest of the optimized profile     */
+
+#ifdef HMMER_THREADS
+  int              syncRead;
+  pthread_mutex_t  readMutex;
+#endif
+
+  char          errbuf[eslERRBUFSIZE];
+} P7_HMMFILE;
+
+/* note on <fname>, above:
+ * this is the actual name of the HMM file being read.
+ * 
+ * The way p7_hmmfile_Open() works, it will preferentially look for
+ * hmmpress'ed binary files. If you open "foo", it will first try to
+ * open "foo.h3m" and <fname> will be "foo.h3m". "foo" does not even
+ * have to exist. If a parsing error occurs, you want <fname> to
+ * be "foo.h3m", so error messages report blame correctly.
+ * In the special case of reading from stdin, <fname> is "[STDIN]".
+ */
+
+
+/*****************************************************************
+ * 6. P7_GMX: a "generic" dynamic programming matrix
+ *****************************************************************/
+
+enum p7g_scells_e {
+  p7G_M = 0,
+  p7G_I = 1,
+  p7G_D = 2,
+};
+#define p7G_NSCELLS 3
+
+enum p7g_xcells_e {
+  p7G_E  = 0,
+  p7G_N  = 1,
+  p7G_J  = 2,
+  p7G_B  = 3,
+  p7G_C  = 4
+};
+#define p7G_NXCELLS 5
+
+
+typedef struct p7_gmx_s {
+  int  M;		/* actual model dimension (model 1..M)    */
+  int  L;		/* actual sequence dimension (seq 1..L)   */
+  
+  int      allocR;      /* current allocated # of rows : L+1 <= validR <= allocR                */
+  int      validR;	/* # of rows actually pointing at DP memory                             */
+  int      allocW;	/* current set row width :  M+1 <= allocW                               */
+  uint64_t ncells;	/* total # of allocated cells in 2D matrix : ncells >= (validR)(allocW) */
+
+  float **dp;           /* logically [0.1..L][0.1..M][0..p7G_NSCELLS-1]; indexed [i][k*p7G_NSCELLS+s] */
+  float  *xmx;          /* logically [0.1..L][0..p7G_NXCELLS-1]; indexed [i*p7G_NXCELLS+s]            */
+
+  float  *dp_mem;
+} P7_GMX;
+
+/* Macros below implement indexing idioms for generic DP routines.
+ * They require the following setup, for profile <gm> and matrix <gx>:
+ *   float const *tsc = gm->tsc;
+ *   float      **dp  = gx->dp;
+ *   float       *xmx = gx->xmx;
+ * and for each row i (target residue x_i in digital seq <dsq>):
+ *   float const *rsc = gm->rsc[dsq[i]];
+ */
+#define MMX(i,k) (dp[(i)][(k) * p7G_NSCELLS + p7G_M])
+#define IMX(i,k) (dp[(i)][(k) * p7G_NSCELLS + p7G_I])
+#define DMX(i,k) (dp[(i)][(k) * p7G_NSCELLS + p7G_D])
+#define XMX(i,s) (xmx[(i) * p7G_NXCELLS + (s)])
+
+#define TSC(s,k) (tsc[(k) * p7P_NTRANS + (s)])
+#define MSC(k)   (rsc[(k) * p7P_NR     + p7P_MSC])
+#define ISC(k)   (rsc[(k) * p7P_NR     + p7P_ISC])
+
+/* Flags that control P7_GMX debugging dumps */
+#define p7_HIDE_SPECIALS (1<<0)
+#define p7_SHOW_LOG      (1<<1)
+
+
+/*****************************************************************
+ * 7. P7_PRIOR: mixture Dirichlet prior for profile HMMs
+ *****************************************************************/
+
+typedef struct p7_prior_s {
+  ESL_MIXDCHLET *tm;		/*  match transitions */
+  ESL_MIXDCHLET *ti;		/* insert transitions */
+  ESL_MIXDCHLET *td;		/* delete transitions */
+  ESL_MIXDCHLET *em;		/*  match emissions   */
+  ESL_MIXDCHLET *ei;		/* insert emissions   */
+} P7_PRIOR;
+
+
+
+
+/*****************************************************************
+ * 8. P7_SPENSEMBLE: segment pair ensembles for domain locations
+ *****************************************************************/
+
+/* struct p7_spcoord_s:
+ *    a coord quad defining a segment pair. 
+ */
+struct p7_spcoord_s { 
+  int idx; 	/* backreference index: which trace a seg came from, or which cluster a domain came from */
+  int i, j;	/* start,end in a target sequence (1..L)  */
+  int k, m;     /* start,end in a query model (1..M)      */
+  float prob;	/* posterior probability of segment       */
+};
+
+/* Structure: P7_SPENSEMBLE
+ *
+ * Collection and clustering of an ensemble of sampled segment pairs,
+ * in order to define domain locations using their posterior
+ * probability distribution (as opposed to Viterbi MAP tracebacks).
+ */
+typedef struct p7_spensemble_s {
+  /* Section 1: a collected ensemble of segment pairs                                       */
+  int                  nsamples;    /* number of sampled traces                             */
+  struct p7_spcoord_s *sp;	    /* array of sampled seg pairs; [0..n-1]                 */
+  int                  nalloc;	    /* allocated size of <sp>                               */
+  int                  n;	    /* number of seg pairs in <sp>                          */
+
+  /* Section 2: then the ensemble is clustered by single-linkage clustering                 */
+  int *workspace;                   /* temp space for Easel SLC algorithm: 2*n              */
+  int *assignment;                  /* each seg pair's cluster index: [0..n-1] = (0..nc-1)  */
+  int  nc;	                    /* number of different clusters                         */
+
+  /* Section 3: then endpoint distribution is examined within each large cluster            */
+  int *epc;	                    /* array counting frequency of each endpoint            */
+  int  epc_alloc;	            /* allocated width of <epc>                             */
+  
+  /* Section 4: finally each large cluster is resolved into domain coords                   */
+  struct p7_spcoord_s *sigc;	    /* array of coords for each domain, [0..nsigc-1]        */
+  int                  nsigc;	    /* number of "significant" clusters, domains            */
+  int                  nsigc_alloc; /* current allocated max for nsigc                      */
+} P7_SPENSEMBLE;
+
+
+
+/*****************************************************************
+ * 9. P7_ALIDISPLAY: an alignment formatted for printing
+ *****************************************************************/
+
+/* Structure: P7_ALIDISPLAY
+ * 
+ * Alignment of a sequence domain to an HMM, formatted for printing.
+ * 
+ * For an alignment of L residues and names C chars long, requires
+ * 6L + 2C + 30 bytes; for typical case of L=100,C=10, that's
+ * <0.7 Kb.
+ */
+typedef struct p7_alidisplay_s {
+  char *rfline;                 /* reference coord info; or NULL        */
+  char *mmline;                 /* modelmask coord info; or NULL        */
+  char *csline;                 /* consensus structure info; or NULL    */
+  char *model;                  /* aligned query consensus sequence     */
+  char *mline;                  /* "identities", conservation +'s, etc. */
+  char *aseq;                   /* aligned target sequence              */
+  char *ntseq;                  /* nucleotide target sequence if nhmmscant */
+  char *ppline;		        /* posterior prob annotation; or NULL   */
+  int   N;		        /* length of strings                    */
+
+  char *hmmname;		/* name of HMM                          */
+  char *hmmacc;			/* accession of HMM; or [0]='\0'        */
+  char *hmmdesc;		/* description of HMM; or [0]='\0'      */
+  int   hmmfrom;		/* start position on HMM (1..M, or -1)  */
+  int   hmmto;			/* end position on HMM (1..M, or -1)    */
+  int   M;			/* length of model                      */
+
+  char *sqname;			/* name of target sequence              */
+  char *sqacc;			/* accession of target seq; or [0]='\0' */
+  char *sqdesc;			/* description of targ seq; or [0]='\0' */
+  int64_t  sqfrom;		/* start position on sequence (1..L)    */
+  int64_t  sqto;  	        /* end position on sequence   (1..L)    */
+  int64_t  L;			/* length of sequence                   */
+
+  int   memsize;                /* size of allocated block of memory    */
+  char *mem;			/* memory used for the char data above  */
+} P7_ALIDISPLAY;
+
+
+/*****************************************************************
+ * 10. P7_DOMAINDEF: reusably managing workflow in defining domains
+ *****************************************************************/
+
+typedef struct p7_dom_s { 
+  int64_t        ienv, jenv;
+  int64_t        iali, jali;
+  int64_t        iorf, jorf; /*Used in translated search to capture the range in the DNA sequence of the ORF containing the match to a protein query */
+  float          envsc;  	/* Forward score in envelope ienv..jenv; NATS; without null2 correction       */
+  float          domcorrection;	/* null2 score when calculating a per-domain score; NATS                      */
+  float          dombias;	/* FLogsum(0, log(bg->omega) + domcorrection): null2 score contribution; NATS */
+  float          oasc;		/* optimal accuracy score (units: expected # residues correctly aligned)      */
+  float          bitscore;	/* overall score in BITS, null corrected, if this were the only domain in seq */
+  double         lnP;	        /* log(P-value) of the bitscore                                               */
+  int            is_reported;	/* TRUE if domain meets reporting thresholds                                  */
+  int            is_included;	/* TRUE if domain meets inclusion thresholds                                  */
+  float         *scores_per_pos; /* score in BITS that each position in the alignment contributes to an overall viterbi score */
+  P7_ALIDISPLAY *ad; 
+} P7_DOMAIN;
+
+/* Structure: P7_DOMAINDEF
+ * 
+ * This is a container for all the necessary information for domain
+ * definition procedures in <p7_domaindef.c>, including a bunch of
+ * heuristic thresholds. The structure is reusable to minimize the
+ * number of allocation/free cycles that need to be done when
+ * processing a large number of sequences. You create the structure
+ * with <p7_domaindef_Create()>; after you're done with defining
+ * domains on a sequence, you call <p7_domaindef_Reuse()> before using
+ * it on the next sequence; and when you're completely done, you free
+ * it with <p7_domaindef_Destroy()>. All memory management is handled
+ * internally; you don't need to reallocate anything yourself.
+ */
+typedef struct p7_domaindef_s {
+  /* for posteriors of being in a domain, B, E */
+  float *mocc;			/* mocc[i=1..L] = prob that i is emitted by core model (is in a domain)       */
+  float *btot; 			/* btot[i=1..L] = cumulative expected times that domain starts at or before i */
+  float *etot;			/* etot[i=1..L] = cumulative expected times that domain ends at or before i   */
+  int    L;
+  int    Lalloc;
+
+  /* the ad hoc null2 model: 1..L nat scores for each residue, log f'(x_i) / f(x_i) */
+  float *n2sc;
+
+  /* rng and reusable memory for stochastic tracebacks */
+  ESL_RANDOMNESS *r;		/* random number generator                                 */
+  int             do_reseeding;	/* TRUE to reset the RNG, make results reproducible        */
+  P7_SPENSEMBLE  *sp;		/* an ensemble of sampled segment pairs (domain endpoints) */
+  P7_TRACE       *tr;		/* reusable space for a trace of a domain                  */
+  P7_TRACE       *gtr;		/* reusable space for a traceback of the entire target seq */
+
+  /* Heuristic thresholds that control the region definition process */
+  /* "rt" = "region threshold", for lack of better term  */
+  float  rt1;   	/* controls when regions are called. mocc[i] post prob >= dt1 : triggers a region around i */
+  float  rt2;		/* controls extent of regions. regions extended until mocc[i]-{b,e}occ[i] < dt2            */
+  float  rt3;		/* controls when regions are flagged for split: if expected # of E preceding B is >= dt3   */
+  
+  /* Heuristic thresholds that control the stochastic traceback/clustering process */
+  int    nsamples;	/* collect ensemble of this many stochastic traces */
+  float  min_overlap;	/* 0.8 means >= 80% overlap of (smaller/larger) segment to link, both in seq and hmm            */
+  int    of_smaller;	/* see above; TRUE means overlap denom is calc'ed wrt smaller segment; FALSE means larger       */
+  int    max_diagdiff;	/* 4 means either start or endpoints of two segments must be within <=4 diagonals of each other */
+  float  min_posterior;	/* 0.25 means a cluster must have >= 25% posterior prob in the sample to be reported            */
+  float  min_endpointp;	/* 0.02 means choose widest endpoint with post prob of at least 2%                              */
+
+  /* storage of the results; domain locations, scores, alignments          */
+  P7_DOMAIN *dcl;
+  int        ndom;	 /* number of domains defined, in the end.         */
+  int        nalloc;     /* number of domain structures allocated in <dcl> */
+
+  /* Additional results storage */
+  float  nexpected;     /* posterior expected number of domains in the sequence (from posterior arrays) */
+  int    nregions;	/* number of regions evaluated */
+  int    nclustered;	/* number of regions evaluated by clustering ensemble of tracebacks */
+  int    noverlaps;	/* number of envelopes defined in ensemble clustering that overlap w/ prev envelope */
+  int    nenvelopes;	/* number of envelopes handed over for domain definition, null2, alignment, and scoring. */
+
+} P7_DOMAINDEF;
+
+
+/*****************************************************************
+ * 11. P7_TOPHITS: ranking lists of top-scoring hits
+ *****************************************************************/
+
+#define p7_HITFLAGS_DEFAULT 0
+#define p7_IS_INCLUDED      (1<<0)
+#define p7_IS_REPORTED      (1<<1)
+#define p7_IS_NEW           (1<<2)
+#define p7_IS_DROPPED       (1<<3)
+#define p7_IS_DUPLICATE     (1<<4)
+
+
+/* Structure: P7_HIT
+ * 
+ * Info about a high-scoring database hit, kept so we can output a
+ * sorted list of high hits at the end.
+ *
+ * sqfrom and sqto are the coordinates that will be shown
+ * in the results, not coords in arrays... therefore, reverse
+ * complements have sqfrom > sqto
+ */
+typedef struct p7_hit_s {
+  char   *name;			/* name of the target               (mandatory)           */
+  char   *acc;			/* accession of the target          (optional; else NULL) */
+  char   *desc;			/* description of the target        (optional; else NULL) */
+  int    window_length;         /* for later use in e-value computation, when splitting long sequences */
+  double sortkey;		/* number to sort by; big is better                       */
+
+  float  score;			/* bit score of the sequence (all domains, w/ correction) */
+  float  pre_score;		/* bit score of sequence before null2 correction          */
+  float  sum_score;		/* bit score reconstructed from sum of domain envelopes   */
+
+  double lnP;		        /* log(P-value) of the score               */
+  double pre_lnP;		/* log(P-value) of the pre_score           */
+  double sum_lnP;		/* log(P-value) of the sum_score           */
+
+  float  nexpected;     /* posterior expected number of domains in the sequence (from posterior arrays) */
+  int    nregions;	/* number of regions evaluated */
+  int    nclustered;	/* number of regions evaluated by clustering ensemble of tracebacks */
+  int    noverlaps;	/* number of envelopes defined in ensemble clustering that overlap w/ prev envelope */
+  int    nenvelopes;	/* number of envelopes handed over for domain definition, null2, alignment, and scoring. */
+  int    ndom;		/* total # of domains identified in this seq   */
+
+  uint32_t flags;      	/* p7_IS_REPORTED | p7_IS_INCLUDED | p7_IS_NEW | p7_IS_DROPPED */
+  int      nreported;	/* # of domains satisfying reporting thresholding  */
+  int      nincluded;	/* # of domains satisfying inclusion thresholding */
+  int      best_domain;	/* index of best-scoring domain in dcl */
+
+  int64_t  seqidx;          /*unique identifier to track the database sequence from which this hit came*/
+  int64_t  subseq_start; /*used to track which subsequence of a full_length target this hit came from, for purposes of removing duplicates */
+
+  P7_DOMAIN *dcl;	/* domain coordinate list and alignment display */
+  esl_pos_t  offset;	/* used in socket communications, in serialized communication: offset of P7_DOMAIN msg for this P7_HIT */
+} P7_HIT;
+
+
+/* Structure: P7_TOPHITS
+ * merging when we prepare to output results. "hit" list is NULL and
+ * unavailable until after we do a sort.  
+ */
+typedef struct p7_tophits_s {
+  P7_HIT **hit;         /* sorted pointer array                     */
+  P7_HIT  *unsrt;	/* unsorted data storage                    */
+  uint64_t Nalloc;	/* current allocation size                  */
+  uint64_t N;		/* number of hits in list now               */
+  uint64_t nreported;	/* number of hits that are reportable       */
+  uint64_t nincluded;	/* number of hits that are includable       */
+  int      is_sorted_by_sortkey; /* TRUE when hits sorted by sortkey and th->hit valid for all N hits */
+  int      is_sorted_by_seqidx; /* TRUE when hits sorted by seq_idx, position, and th->hit valid for all N hits */
+} P7_TOPHITS;
+
+
+
+
+
+/*****************************************************************
+ * 12. P7_SCOREDATA: data used in diagonal recovery and extension
+ *****************************************************************/
+
+enum p7_scoredatatype_e {
+  p7_sd_std  = 0,
+  p7_sd_fm   = 1,
+};
+
+
+/* This contains a compact representation of 8-bit bias-shifted scores for use in
+ * diagonal recovery (standard SSV) and extension (standard and FM-SSV),
+ * along with MAXL-associated prefix- and suffix-lengths, and optimal extensions
+ * for FM-SSV.
+ */
+typedef struct p7_scoredata_s {
+  int         type;
+  int         M;
+  union {//implicit (M+1)*K matrix, where M = # states, and K = # characters in alphabet
+    uint8_t  *ssv_scores;    // this 2D array is used in the default nhmmer pipeline
+    float    *ssv_scores_f;  // this 2D array is used in the FM-index based pipeline
+  };
+  float      *prefix_lengths;
+  float      *suffix_lengths;
+  float      *fwd_scores;
+  float     **fwd_transitions;
+  float     **opt_ext_fwd; // Used only for FM-index based pipeline
+  float     **opt_ext_rev; // Used only for FM-index based pipeline
+} P7_SCOREDATA;
+
+
+/*****************************************************************
+ * 13. P7_HMM_WINDOW: data used to track lists of sequence windows
+ *****************************************************************/
+
+
+typedef struct p7_hmm_window_s {
+  float      score;
+  float      null_sc;
+  int32_t    id;          //sequence id of the database sequence hit
+  int64_t    n;           //position in database sequence at which the diagonal/window starts
+  int64_t    fm_n;        //position in the concatenated fm-index sequence at which the diagonal starts
+  int32_t    length;      // length of the diagonal/window
+  int16_t    k;           //position of the model at which the diagonal ends
+  int64_t    target_len;  //length of the target sequence
+  int8_t     complementarity;
+  int8_t     used_to_extend;
+} P7_HMM_WINDOW;
+
+typedef struct p7_hmm_window_list_s {
+  P7_HMM_WINDOW *windows;
+  int       count;
+  int       size;
+} P7_HMM_WINDOWLIST;
+
+
+
+/*****************************************************************
+ * 14. Choice of vector implementation.
+ *****************************************************************/
+#if   defined (eslENABLE_SSE)
+#include "impl_sse/impl_sse.h"
+#elif defined (eslENABLE_VMX)
+#include "impl_vmx/impl_vmx.h"
+#else
+#error "No vector implementation enabled"
+#endif
+
+
+/*****************************************************************
+ * 15. The FM-index acceleration to the SSV filter.  Only works for SSE
+ *****************************************************************/
+#define FM_MAX_LINE 256
+
+/* Structure the 2D occ array into a single array.  "type" is either b or sb.
+ * Note that one extra count value is required by RLE, one 4-byte int for
+ * each superblock count vector, and one 2-byte short for each block count
+ * vector. This is small overhead, even for a small alphabet like dna.
+ */
+#define FM_OCC_CNT( type, i, c)  ( occCnts_##type[(meta->alph_size)*(i) + (c)])
+
+enum fm_alphabettypes_e {
+  fm_DNA        = 0,  //acgt,  2 bit
+  //fm_DNA_full   = 1,  //includes ambiguity codes, 4 bit.
+  fm_AMINO      = 4,  // 5 bit
+};
+/*TODO: fm_DNA_full has currently been disabled because of problems with how the
+ * FM index handles very long runs of the same character (in this case, Ns).
+ * See wheelert/notebook/2013/12-11-FM-alphabet-speed notes on 12/12.
+ */
+
+enum fm_direction_e {
+  fm_forward    = 0,
+  fm_backward   = 1,
+};
+
+
+typedef struct fm_interval_s {
+  int   lower;
+  int   upper;
+} FM_INTERVAL;
+
+typedef struct fm_hit_s {
+  uint64_t  start;
+  uint32_t  block;
+  int       direction;
+  int       length;
+  int       sortkey;
+} FM_HIT;
+
+
+
+typedef struct fm_ambiglist_s {
+  FM_INTERVAL *ranges;
+  uint32_t     count;
+  uint32_t     size;
+} FM_AMBIGLIST;
+
+
+typedef struct fm_seqdata_s {
+
+  uint32_t target_id;      // Which sequence in the target database did this segment come from (can be multiple segment per sequence, if a sequence has Ns)
+  uint64_t target_start;   // The position in sequence {id} in the target database at which this sequence-block starts (usually 1, unless its a long sequence split out over multiple FMs)
+  uint32_t fm_start;       // The position in the FM block at which this sequence begins
+  uint32_t length;         // Length of this sequence segment  (usually the length of the target sequence, unless its a long sequence split out over multiple FMs)
+
+
+  //meta data taken from the sequence this segment was taken from
+  uint16_t name_length;
+  uint16_t source_length;
+  uint16_t acc_length;
+  uint16_t desc_length;
+  char     *name;
+  char     *source;
+  char     *acc;
+  char     *desc;
+} FM_SEQDATA;
+
+
+typedef struct fm_metadata_s {
+  uint8_t  fwd_only;
+  uint8_t  alph_type;
+  uint8_t  alph_size;
+  uint8_t  charBits;
+  uint32_t freq_SA; //frequency with which SA is sampled
+  uint32_t freq_cnt_sb; //frequency with which full cumulative counts are captured
+  uint32_t freq_cnt_b; //frequency with which intermittent counts are captured
+  uint16_t block_count;
+  uint32_t seq_count;
+  uint64_t char_count; //total count of characters including those in and out of the alphabet
+  char     *alph;
+  char     *inv_alph;
+  int      *compl_alph;
+  FILE         *fp;
+  FM_SEQDATA   *seq_data;
+  FM_AMBIGLIST *ambig_list;
+} FM_METADATA;
+
+
+typedef struct fm_data_s {
+  uint64_t N; //length of text
+  uint32_t term_loc; // location in the BWT at which the '$' char is found (replaced in the sequence with 'a')
+  uint32_t seq_offset;
+  uint32_t ambig_offset;
+  uint32_t seq_cnt;
+  uint32_t ambig_cnt;
+  uint32_t overlap; // number of bases at the beginning that overlap the FM-index for the preceding block
+  uint8_t  *T;  //text corresponding to the BWT
+  uint8_t  *BWT_mem;
+  uint8_t  *BWT;
+  uint32_t *SA; // sampled suffix array
+  int64_t  *C; //the first position of each letter of the alphabet if all of T is sorted.  (signed, as I use that to keep tract of presence/absence)
+  uint32_t *occCnts_sb;
+  uint16_t *occCnts_b;
+} FM_DATA;
+
+typedef struct fm_dp_pair_s {
+  uint16_t    pos;  // position of the diagonal in the model.
+  float       score;
+  float       max_score;
+  uint8_t     score_peak_len; // how long was the diagonal when the most recent peak (within fm_drop_lim of the max score) was seen?
+  uint8_t     consec_pos;
+  uint8_t     max_consec_pos;
+  uint8_t     consec_consensus;
+  uint8_t     model_direction;
+  uint8_t     complementarity;
+} FM_DP_PAIR;
+
+
+typedef struct fm_diag_s {
+  uint64_t    n;  //position of the database sequence at which the diagonal starts
+  union {
+    double    sortkey;
+    double    score;
+  };
+  uint16_t    k;  //position of the model at which the diagonal starts
+  uint16_t    length;
+  uint8_t     complementarity;
+} FM_DIAG;
+
+typedef struct fm_diaglist_s {
+  FM_DIAG   *diags;
+  int       count;
+  int       size;
+} FM_DIAGLIST;
+
+/* Effectively global variables, to be initialized once in fm_initConfig(),
+ * then passed around among threads to avoid recomputing them
+ *
+ * When allocated, must be 16-byte aligned, and all _m128i elements
+ * must precede other types
+ */
+typedef struct {
+#if   defined (eslENABLE_SSE)
+  /* mask arrays, and 16-byte-offsets into them */
+  __m128i *fm_masks_mem;
+  __m128i *fm_masks_v;
+  __m128i *fm_reverse_masks_mem;
+  __m128i *fm_reverse_masks_v;
+  __m128i *fm_chars_mem;
+  __m128i *fm_chars_v;
+
+  /*various precomputed vectors*/
+  __m128i fm_allones_v;
+  __m128i fm_zeros_v;
+  __m128i fm_neg128_v;
+  __m128i fm_m0f;  //00 00 11 11
+  __m128i fm_m01;  //01 01 01 01
+  __m128i fm_m11;  //00 00 00 11
+
+  /* no non-__m128i- elements above this line */
+#endif //#if   defined (eslENABLE_SSE)
+
+  /*counter, to compute FM-index speed*/
+  int occCallCnt;
+
+  /*bounding cutoffs*/
+  int max_depth;
+  float drop_lim;  // 0.2 ; in seed, max drop in a run of length [fm_drop_max_len]
+  int drop_max_len; // 4 ; maximum run length with score under (max - [fm_drop_lim])
+  int consec_pos_req; //5
+  int consensus_match_req; //10
+  float score_density_req; //.5
+  int ssv_length;
+  float scthreshFM;
+  float sc_thresh_ratio; //information content deficit,  actual_relent/target_relent
+
+  /*pointer to FM-index metadata*/
+  FM_METADATA *meta;
+
+} FM_CFG;
+
+
+#if   defined (eslENABLE_SSE)
+//used to convert from a byte array to an __m128i
+typedef union {
+        uint8_t bytes[16];
+        __m128i m128;
+        } byte_m128;
+
+
+/* Gather the sum of all counts in a 16x8-bit element into a single 16-bit
+ *  element of the register (the 0th element)
+ *
+ *  the _mm_sad_epu8  accumulates 8-bit counts into 16-bit counts:
+ *      left 8 counts (64-bits) accumulate in counts_v[0],
+ *      right 8 counts in counts_v[4]  (the other 6 16-bit ints are 0)
+ *  the _mm_shuffle_epi32  flips the 4th int into the 0th slot
+ */
+#define FM_GATHER_8BIT_COUNTS( in_v, mid_v, out_v  ) do {\
+    mid_v = _mm_sad_epu8 (in_v, cfg->fm_zeros_v);\
+    tmp_v = _mm_shuffle_epi32(mid_v, _MM_SHUFFLE(1, 1, 1, 2));\
+    out_v = _mm_add_epi16(mid_v, tmp_v);\
+  } while (0)
+
+
+/* Macro for SSE operations to turn 2-bit character values into 2-bit binary
+ * (00 or 01) match/mismatch values representing occurrences of a character in a
+ * 4-char-per-byte packed BWT.
+ *
+ * Typically followed by a call to FM_COUNT_SSE_4PACKED, possibly with a
+ * mask in between to handle the case where we don't want to add over all
+ * positions in the vector
+ *
+ * tmp_v and tmp2_v are used as temporary vectors throughout, and hold meaningless values
+ * at the end
+ *
+ * xor(in_v, c_v)        : each 2-bit value will be 00 if a match, and non-0 if a mismatch
+ * and(in_v, 01010101)   : look at the right bit of each 2-bit value,
+ * srli(1)+and()         : look at the left bit of each 2-bit value,
+ * or()                  : if either left bit or right bit is non-0, 01, else 00 (match is 00)
+ *
+ * subs()                : invert, so match is 01, mismatch is 00
+ *
+ */
+#define FM_MATCH_2BIT(in_v, c_v, a_v, b_v, out_v) do {\
+    a_v = _mm_xor_si128(in_v, c_v);\
+    \
+    b_v  = _mm_srli_epi16(a_v, 1);\
+    a_v  = _mm_or_si128(a_v, b_v);\
+    b_v  = _mm_and_si128(a_v, cfg->fm_m01);\
+    \
+    out_v  = _mm_subs_epi8(cfg->fm_m01,b_v);\
+  } while (0)
+
+
+/*Macro for SSE operations to count bits produced by FM_MATCH_SSE_4PACKED
+ *
+ * tmp_v and tmp2_v are used as temporary vectors throughout, and hold meaningless values
+ * at the end
+ *
+ * then add up the 2-bit values:
+ * srli(4)+add()         : left 4 bits shifted right, added to right 4 bits
+ *
+ * srli(2)+and(00000011) : left 2 bits (value 0..2) shifted right, masked, so no other bits active
+ * and(00000011)         : right 2 bits (value 0..2) masked so no other bits active
+ *
+ * final 2 add()s        : tack current counts on to already-tabulated counts.
+ */
+#define FM_COUNT_2BIT(a_v, b_v, cnts_v) do {\
+        b_v = _mm_srli_epi16(a_v, 4);\
+        a_v  = _mm_add_epi16(a_v, b_v);\
+        \
+        b_v = _mm_srli_epi16(a_v, 2);\
+        a_v  = _mm_and_si128(a_v,cfg->fm_m11);\
+        b_v = _mm_and_si128(b_v,cfg->fm_m11);\
+        \
+        cnts_v = _mm_add_epi16(cnts_v, a_v);\
+        cnts_v = _mm_add_epi16(cnts_v, b_v);\
+  } while (0)
+
+
+
+/* Macro for SSE operations that turns a vector of 4-bit character values into
+ * 2 vectors representing matches. Each byte in the input vector consists of
+ * a left half (4 bits) and a right half (4 bits). The 16 left-halves produce
+ * one vector, which contains all-1s for bytes in which the left half matches
+ * the c_v character (and 0s if it doesn't), while the 16 right-halves produce
+ * the other vector, again with each byte either all-1s or all-0s.
+ *
+ * The expectation is that FM_COUNT_4BIT will be called after this, to
+ * turn these binary values into sums over a series of vectors. The macros
+ * are split up to allow one end or other to be trimmed in the case that
+ * counting is not expected to include the full vector.
+ *
+ * srli(4)+and() : capture the left 4-bit value   (need the mask because 16-bit shift leaves garbage in left-4-bit chunks)
+ * and()         : capture the right 4-bit value
+ *
+ * cmpeq()x2     : test if both left and right == c.  For each, if ==c , value = 11111111 (-1)
+ */
+#define FM_MATCH_4BIT(in_v, c_v, out1_v, out2_v) do {\
+    out1_v    = _mm_srli_epi16(in_v, 4);\
+    out2_v    = _mm_and_si128(in_v, cfg->fm_m0f);\
+    out1_v    = _mm_and_si128(out1_v, cfg->fm_m0f);\
+    \
+    out1_v    = _mm_cmpeq_epi8(out1_v, c_v);\
+    out2_v    = _mm_cmpeq_epi8(out2_v, c_v);\
+  } while (0)
+
+
+/* Macro for SSE operations that turns a vector of 4-bit character values into
+ * 2 vectors representing matches. Each byte in the input vector consists of
+ * a left half (4 bits) and a right half (4 bits). The 16 left-halves produce
+ * one vector, which contains all-1s for bytes in which the left half is less than
+ * the c_v character (and 0s if it doesn't), while the 16 right-halves produce
+ * the other vector, again with each byte either all-1s or all-0s.
+ *
+ * The expectation is that FM_COUNT_4BIT will be called after this, to
+ * turn these binary values into sums over a series of vectors. The macros
+ * are split up to allow one end or other to be trimmed in the case that
+ * counting is not expected to include the full vector.
+ *
+ * srli(4)+and() : capture the left 4-bit value   (need the mask because 16-bit shift leaves garbage in left-4-bit chunks)
+ * and()         : capture the right 4-bit value
+ *
+ * cmplt()x2     : test if both left and right < c.  For each, if <c , value = 11111111 (-1)
+ */
+#define FM_LT_4BIT(in_v, c_v, out1_v, out2_v) do {\
+    out1_v    = _mm_srli_epi16(in_v, 4);\
+    out2_v    = _mm_and_si128(in_v, cfg->fm_m0f);\
+    out1_v    = _mm_and_si128(out1_v, cfg->fm_m0f);\
+    \
+    out1_v    = _mm_cmplt_epi8(out1_v, c_v);\
+    out2_v    = _mm_cmplt_epi8(out2_v, c_v);\
+  } while (0)
+
+
+
+/* Macro for SSE operations to add occurrence counts to the tally vector counts_v,
+ * in the 4-bits-per-character case
+ *
+ * The expectation is that in[12]_v will contain bytes that are either
+ *   00000000  =  0
+ *  or
+ *   11111111  = -1
+ * so subtracting the value of the byte is the same as adding 0 or 1.
+ */
+#define FM_COUNT_4BIT(in1_v, in2_v, cnts_v) do {\
+    cnts_v = _mm_subs_epi8(cnts_v, in1_v);\
+    cnts_v = _mm_subs_epi8(cnts_v, in2_v);\
+  } while (0)
+
+
+#endif  // if  defined (eslENABLE_SSE)
+
+/*****************************************************************
+ * 16. P7_PIPELINE: H3's accelerated seq/profile comparison pipeline
+ *****************************************************************/
+
+enum p7_pipemodes_e { p7_SEARCH_SEQS = 0, p7_SCAN_MODELS = 1 };
+enum p7_zsetby_e    { p7_ZSETBY_NTARGETS = 0, p7_ZSETBY_OPTION = 1, p7_ZSETBY_FILEINFO = 2 };
+enum p7_complementarity_e { p7_NOCOMPLEMENT    = 0, p7_COMPLEMENT   = 1 };
+
+typedef struct p7_pipeline_s {
+  /* Dynamic programming matrices                                           */
+  P7_OMX     *oxf;		/* one-row Forward matrix, accel pipe       */
+  P7_OMX     *oxb;		/* one-row Backward matrix, accel pipe      */
+  P7_OMX     *fwd;		/* full Fwd matrix for domain envelopes     */
+  P7_OMX     *bck;		/* full Bck matrix for domain envelopes     */
+
+  /* Domain postprocessing                                                  */
+  ESL_RANDOMNESS *r;		/* random number generator                  */
+  int             do_reseeding; /* TRUE: reseed for reproducible results    */
+  int             do_alignment_score_calc;
+  P7_DOMAINDEF   *ddef;		/* domain definition workflow               */
+
+
+  /* Reporting threshold settings                                           */
+  int     by_E;		        /* TRUE to cut per-target report off by E   */
+  double  E;	                /* per-target E-value threshold             */
+  double  T;	                /* per-target bit score threshold           */
+  int     dom_by_E;             /* TRUE to cut domain reporting off by E    */
+  double  domE;	                /* domain E-value threshold                 */
+  double  domT;	                /* domain bit score threshold               */
+  int     use_bit_cutoffs;      /* (FALSE | p7H_GA | p7H_TC | p7H_NC)       */
+
+  /* Inclusion threshold settings                                           */
+  int     inc_by_E;		/* TRUE to threshold inclusion by E-values  */
+  double  incE;			/* per-target inclusion E-value threshold   */
+  double  incT;			/* per-target inclusion score threshold     */
+  int     incdom_by_E;		/* TRUE to threshold domain inclusion by E  */
+  double  incdomE;		/* per-domain inclusion E-value threshold   */
+  double  incdomT;		/* per-domain inclusion E-value threshold   */
+
+  /* Tracking search space sizes for E value calculations                   */
+  double  Z;			/* eff # targs searched (per-target E-val)  */
+  double  domZ;			/* eff # signific targs (per-domain E-val)  */
+  enum p7_zsetby_e Z_setby;   	/* how Z was set                            */
+  enum p7_zsetby_e domZ_setby;	/* how domZ was set                         */
+  
+  /* Threshold settings for pipeline                                        */
+  int     do_max;	        /* TRUE to run in slow/max mode             */
+  double  F1;		        /* MSV filter threshold                     */
+  double  F2;		        /* Viterbi filter threshold                 */
+  double  F3;		        /* uncorrected Forward filter threshold     */
+  int     B1;               /* window length for biased-composition modifier - MSV*/
+  int     B2;               /* window length for biased-composition modifier - Viterbi*/
+  int     B3;               /* window length for biased-composition modifier - Forward*/
+  int     do_biasfilter;	/* TRUE to use biased comp HMM filter       */
+  int     do_null2;		/* TRUE to use null2 score corrections      */
+
+  /* Accounting. (reduceable in threaded/MPI parallel version)              */
+  uint64_t      nmodels;        /* # of HMMs searched                       */
+  uint64_t      nseqs;	        /* # of sequences searched                  */
+  uint64_t      nres;	        /* # of residues searched                   */
+  uint64_t      nnodes;	        /* # of model nodes searched                */
+  uint64_t      n_past_msv;	/* # comparisons that pass MSVFilter()      */
+  uint64_t      n_past_bias;	/* # comparisons that pass bias filter      */
+  uint64_t      n_past_vit;	/* # comparisons that pass ViterbiFilter()  */
+  uint64_t      n_past_fwd;	/* # comparisons that pass ForwardFilter()  */
+  uint64_t      n_output;	    /* # alignments that make it to the final output (used for nhmmer) */
+  uint64_t      pos_past_msv;	/* # positions that pass MSVFilter()  (used for nhmmer) */
+  uint64_t      pos_past_bias;	/* # positions that pass bias filter  (used for nhmmer) */
+  uint64_t      pos_past_vit;	/* # positions that pass ViterbiFilter()  (used for nhmmer) */
+  uint64_t      pos_past_fwd;	/* # positions that pass ForwardFilter()  (used for nhmmer) */
+  uint64_t      pos_output;	    /* # positions that make it to the final output (used for nhmmer) */
+
+  enum p7_pipemodes_e mode;    	/* p7_SCAN_MODELS | p7_SEARCH_SEQS          */
+  int           long_targets;   /* TRUE if the target sequences are expected to be very long (e.g. dna chromosome search in nhmmer) */
+  int           strands;         /*  p7_STRAND_TOPONLY  | p7_STRAND_BOTTOMONLY |  p7_STRAND_BOTH */
+  int 		    	W;              /* window length for nhmmer scan - essentially maximum length of model that we expect to find*/
+  int           block_length;   /* length of overlapping blocks read in the multi-threaded variant (default MAX_RESIDUE_COUNT) */
+
+  int           show_accessions;/* TRUE to output accessions not names      */
+  int           show_alignments;/* TRUE to output alignments (default)      */
+
+  P7_HMMFILE   *hfp;		/* COPY of open HMM database (if scan mode) */
+  char          errbuf[eslERRBUFSIZE];
+} P7_PIPELINE;
+
+
+
+/*****************************************************************
+ * 17. P7_BUILDER: pipeline for new HMM construction
+ *****************************************************************/
+
+#define p7_DEFAULT_WINDOW_BETA  1e-7
+
+enum p7_archchoice_e { p7_ARCH_FAST = 0, p7_ARCH_HAND = 1 };
+enum p7_wgtchoice_e  { p7_WGT_NONE  = 0, p7_WGT_GIVEN = 1, p7_WGT_GSC    = 2, p7_WGT_PB       = 3, p7_WGT_BLOSUM = 4 };
+enum p7_effnchoice_e { p7_EFFN_NONE = 0, p7_EFFN_SET  = 1, p7_EFFN_CLUST = 2, p7_EFFN_ENTROPY = 3, p7_EFFN_ENTROPY_EXP = 4 };
+
+typedef struct p7_builder_s {
+  /* Model architecture                                                                            */
+  enum p7_archchoice_e arch_strategy;    /* choice of model architecture determination algorithm   */
+  float                symfrac;	         /* residue occ thresh for fast architecture determination */
+  float                fragthresh;	 /* if L <= fragthresh*alen, seq is called a fragment      */
+
+  /* Relative sequence weights                                                                     */
+  enum p7_wgtchoice_e  wgt_strategy;     /* choice of relative sequence weighting algorithm        */
+  double               wid;		 /* %id threshold for BLOSUM relative weighting            */
+
+  /* Effective sequence number                                                                     */
+  enum p7_effnchoice_e effn_strategy;    /* choice of effective seq # determination algorithm      */
+  double               re_target;	 /* rel entropy target for effn eweighting, if set; or -1.0*/
+  double               esigma;		 /* min total rel ent parameter for effn entropy weights   */
+  double               eid;		 /* %id threshold for effn clustering                      */
+  double               eset;		 /* effective sequence number, if --eset; or -1.0          */
+
+  /* Run-to-run variation due to random number generation                                          */
+  ESL_RANDOMNESS      *r;	         /* RNG for E-value calibration simulations                */
+  int                  do_reseeding;	 /* TRUE to reseed, making results reproducible            */
+
+  /* E-value parameter calibration                                                                 */
+  int                  EmL;            	 /* length of sequences generated for MSV fitting          */
+  int                  EmN;	         /* # of sequences generated for MSV fitting               */
+  int                  EvL;            	 /* length of sequences generated for Viterbi fitting      */
+  int                  EvN;	         /* # of sequences generated for Viterbi fitting           */
+  int                  EfL;	         /* length of sequences generated for Forward fitting      */
+  int                  EfN;	         /* # of sequences generated for Forward fitting           */
+  double               Eft;	         /* tail mass used for Forward fitting                     */
+
+  /* Choice of prior                                                                               */
+  P7_PRIOR            *prior;	         /* choice of prior when parameterizing from counts        */
+  int                  max_insert_len;
+
+  /* Optional: information used for parameterizing single sequence queries                         */
+  ESL_SCOREMATRIX     *S;		 /* residue score matrix                                   */
+  ESL_DMATRIX         *Q;	         /* Q->mx[a][b] = P(b|a) residue probabilities             */
+  double               popen;         	 /* gap open probability                                   */
+  double               pextend;          /* gap extend probability                                 */
+
+  double               w_beta;    /*beta value used to compute W (window length)   */
+  int                  w_len;     /*W (window length)  explicitly set */
+
+  const ESL_ALPHABET  *abc;		 /* COPY of alphabet                                       */
+  char errbuf[eslERRBUFSIZE];            /* informative message on model construction failure      */
+} P7_BUILDER;
+
+
+
+/*****************************************************************
+ * 18. Routines in HMMER's exposed API.
+ *****************************************************************/
+
+/* build.c */
+extern int p7_Handmodelmaker(ESL_MSA *msa,                P7_BUILDER *bld, P7_HMM **ret_hmm, P7_TRACE ***ret_tr);
+extern int p7_Fastmodelmaker(ESL_MSA *msa, float symfrac, P7_BUILDER *bld, P7_HMM **ret_hmm, P7_TRACE ***ret_tr);
+
+/* emit.c */
+extern int p7_CoreEmit   (ESL_RANDOMNESS *r, const P7_HMM *hmm,                                        ESL_SQ *sq, P7_TRACE *tr);
+extern int p7_ProfileEmit(ESL_RANDOMNESS *r, const P7_HMM *hmm, const P7_PROFILE *gm, const P7_BG *bg, ESL_SQ *sq, P7_TRACE *tr);
+extern int p7_emit_SimpleConsensus(const P7_HMM *hmm, ESL_SQ *sq);
+extern int p7_emit_FancyConsensus (const P7_HMM *hmm, float min_lower, float min_upper, ESL_SQ *sq);
+
+/* errors.c */
+extern void p7_Die (char *format, ...);
+extern void p7_Fail(char *format, ...);
+
+/* evalues.c */
+extern int p7_Calibrate(P7_HMM *hmm, P7_BUILDER *cfg_b, ESL_RANDOMNESS **byp_rng, P7_BG **byp_bg, P7_PROFILE **byp_gm, P7_OPROFILE **byp_om);
+extern int p7_Lambda(P7_HMM *hmm, P7_BG *bg, double *ret_lambda);
+extern int p7_MSVMu     (ESL_RANDOMNESS *r, P7_OPROFILE *om, P7_BG *bg, int L, int N, double lambda,               double *ret_mmu);
+extern int p7_ViterbiMu (ESL_RANDOMNESS *r, P7_OPROFILE *om, P7_BG *bg, int L, int N, double lambda,               double *ret_vmu);
+extern int p7_Tau       (ESL_RANDOMNESS *r, P7_OPROFILE *om, P7_BG *bg, int L, int N, double lambda, double tailp, double *ret_tau);
+
+/* eweight.c */
+extern int p7_EntropyWeight(const P7_HMM *hmm, const P7_BG *bg, const P7_PRIOR *pri, double infotarget, double *ret_Neff);
+
+extern int p7_EntropyWeight_exp(const P7_HMM *hmm, const P7_BG *bg, const P7_PRIOR *pri, double etarget, double *ret_exp);
+/* generic_decoding.c */
+extern int p7_GDecoding      (const P7_PROFILE *gm, const P7_GMX *fwd,       P7_GMX *bck, P7_GMX *pp);
+extern int p7_GDomainDecoding(const P7_PROFILE *gm, const P7_GMX *fwd, const P7_GMX *bck, P7_DOMAINDEF *ddef);
+
+/* generic_fwdback.c */
+extern int p7_GForward     (const ESL_DSQ *dsq, int L, const P7_PROFILE *gm,       P7_GMX *gx, float *ret_sc);
+extern int p7_GBackward    (const ESL_DSQ *dsq, int L, const P7_PROFILE *gm,       P7_GMX *gx, float *ret_sc);
+extern int p7_GHybrid      (const ESL_DSQ *dsq, int L, const P7_PROFILE *gm,       P7_GMX *gx, float *opt_fwdscore, float *opt_hybscore);
+
+/* generic_msv.c */
+extern int p7_GMSV           (const ESL_DSQ *dsq, int L, const P7_PROFILE *gm, P7_GMX *gx, float nu, float *ret_sc);
+extern int p7_GMSV_longtarget(const ESL_DSQ *dsq, int L, P7_PROFILE *gm, P7_GMX *gx, float nu,  P7_BG *bg, double P, P7_HMM_WINDOWLIST *windowlist);
+
+/* generic_null2.c */
+extern int p7_GNull2_ByExpectation(const P7_PROFILE *gm, P7_GMX *pp, float *null2);
+extern int p7_GNull2_ByTrace      (const P7_PROFILE *gm, const P7_TRACE *tr, int zstart, int zend, P7_GMX *wrk, float *null2);
+
+/* generic_optacc.c */
+extern int p7_GOptimalAccuracy(const P7_PROFILE *gm, const P7_GMX *pp,       P7_GMX *gx, float *ret_e);
+extern int p7_GOATrace        (const P7_PROFILE *gm, const P7_GMX *pp, const P7_GMX *gx, P7_TRACE *tr);
+
+/* generic_stotrace.c */
+extern int p7_GStochasticTrace(ESL_RANDOMNESS *r, const ESL_DSQ *dsq, int L, const P7_PROFILE *gm, const P7_GMX *gx, P7_TRACE *tr);
+
+/* generic_viterbi.c */
+extern int p7_GViterbi     (const ESL_DSQ *dsq, int L, const P7_PROFILE *gm,       P7_GMX *gx, float *ret_sc);
+
+/* generic_vtrace.c */
+extern int p7_GTrace       (const ESL_DSQ *dsq, int L, const P7_PROFILE *gm, const P7_GMX *gx, P7_TRACE *tr);
+extern int p7_GViterbi_longtarget(const ESL_DSQ *dsq, int L, const P7_PROFILE *gm, P7_GMX *gx,
+                       float filtersc, double P, P7_HMM_WINDOWLIST *windowlist);
+
+
+/* heatmap.c (evolving now, intend to move this to Easel in the future) */
+extern double dmx_upper_max(ESL_DMATRIX *D);
+extern double dmx_upper_min(ESL_DMATRIX *D);
+extern double dmx_upper_element_sum(ESL_DMATRIX *D);
+extern double dmx_upper_norm(ESL_DMATRIX *D);
+extern int    dmx_Visualize(FILE *fp, ESL_DMATRIX *D, double min, double max);
+
+/* hmmdutils.c */
+extern void p7_openlog(const char *ident, int option, int facility);
+extern void p7_syslog(int priority, const char *format, ...);
+extern void p7_closelog(void);
+
+/* hmmlogo.c */
+extern float hmmlogo_maxHeight (P7_BG *bg);
+extern int hmmlogo_RelativeEntropy_all      (P7_HMM *hmm, P7_BG *bg, float *rel_ents, float **probs, float **heights );
+extern int hmmlogo_RelativeEntropy_above_bg (P7_HMM *hmm, P7_BG *bg, float *rel_ents, float **probs, float **heights );
+extern int hmmlogo_ScoreHeights (P7_HMM *hmm, P7_BG *bg, float **heights );
+extern int hmmlogo_IndelValues (P7_HMM *hmm, float *insert_P, float *insert_expL, float *delete_P );
+
+
+
+/* hmmpgmd2msa.c */
+extern int hmmpgmd2msa(void *data, P7_HMM *hmm, ESL_SQ *qsq, int *incl, int incl_size, int *excl, int excl_size, int excl_all, ESL_MSA **ret_msa);
+
+
+
+/* island.c */
+extern int   p7_island_Viterbi(ESL_DSQ *dsq, int L, P7_PROFILE *gm, P7_GMX *mx, ESL_HISTOGRAM *h);
+
+/* h2_io.c */
+extern int   p7_h2io_WriteASCII(FILE *fp, P7_HMM *hmm);
+
+/* hmmer.c */
+extern void         p7_banner(FILE *fp, const char *progname, char *banner);
+extern ESL_GETOPTS *p7_CreateDefaultApp(ESL_OPTIONS *options, int nargs, int argc, char **argv, char *banner, char *usage);
+extern int          p7_AminoFrequencies(float *f);
+
+/* logsum.c */
+extern int   p7_FLogsumInit(void);
+extern float p7_FLogsum(float a, float b);
+extern float p7_FLogsumError(float a, float b);
+extern int   p7_ILogsumInit(void);
+extern int   p7_ILogsum(int s1, int s2);
+
+
+/* modelconfig.c */
+extern int p7_ProfileConfig(const P7_HMM *hmm, const P7_BG *bg, P7_PROFILE *gm, int L, int mode);
+extern int p7_ReconfigLength  (P7_PROFILE *gm, int L);
+extern int p7_ReconfigMultihit(P7_PROFILE *gm, int L);
+extern int p7_ReconfigUnihit  (P7_PROFILE *gm, int L);
+
+/* modelstats.c */
+extern double p7_MeanMatchInfo           (const P7_HMM *hmm, const P7_BG *bg);
+extern double p7_MeanMatchEntropy        (const P7_HMM *hmm);
+extern double p7_MeanMatchRelativeEntropy(const P7_HMM *hmm, const P7_BG *bg);
+extern double p7_MeanForwardScore        (const P7_HMM *hmm, const P7_BG *bg);
+extern int    p7_MeanPositionRelativeEntropy(const P7_HMM *hmm, const P7_BG *bg, double *ret_entropy);
+extern int    p7_hmm_CompositionKLD(const P7_HMM *hmm, const P7_BG *bg, float *ret_KL, float **opt_avp);
+
+
+/* mpisupport.c */
+#ifdef HMMER_MPI
+extern int p7_hmm_MPISend(P7_HMM *hmm, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc);
+extern int p7_hmm_MPIPackSize(P7_HMM *hmm, MPI_Comm comm, int *ret_n);
+extern int p7_hmm_MPIPack(P7_HMM *hmm, char *buf, int n, int *position, MPI_Comm comm);
+extern int p7_hmm_MPIUnpack(char *buf, int n, int *pos, MPI_Comm comm, ESL_ALPHABET **abc, P7_HMM **ret_hmm);
+extern int p7_hmm_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, ESL_ALPHABET **abc, P7_HMM **ret_hmm);
+
+extern int p7_profile_MPISend(P7_PROFILE *gm, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc);
+extern int p7_profile_MPIRecv(int source, int tag, MPI_Comm comm, const ESL_ALPHABET *abc, const P7_BG *bg,
+			      char **buf, int *nalloc,  P7_PROFILE **ret_gm);
+
+extern int p7_pipeline_MPISend(P7_PIPELINE *pli, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc);
+extern int p7_pipeline_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, ESL_GETOPTS *go, P7_PIPELINE **ret_pli);
+
+extern int p7_tophits_MPISend(P7_TOPHITS *th, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc);
+extern int p7_tophits_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, P7_TOPHITS **ret_th);
+
+extern int p7_oprofile_MPISend(P7_OPROFILE *om, int dest, int tag, MPI_Comm comm, char **buf, int *nalloc);
+extern int p7_oprofile_MPIPackSize(P7_OPROFILE *om, MPI_Comm comm, int *ret_n);
+extern int p7_oprofile_MPIPack(P7_OPROFILE *om, char *buf, int n, int *pos, MPI_Comm comm);
+extern int p7_oprofile_MPIUnpack(char *buf, int n, int *pos, MPI_Comm comm, ESL_ALPHABET **abc, P7_OPROFILE **ret_om);
+extern int p7_oprofile_MPIRecv(int source, int tag, MPI_Comm comm, char **buf, int *nalloc, ESL_ALPHABET **abc, P7_OPROFILE **ret_om);
+#endif /*HMMER_MPI*/
+
+/* tracealign.c */
+extern int p7_tracealign_Seqs(ESL_SQ **sq,           P7_TRACE **tr, int nseq, int M,  int optflags, P7_HMM *hmm, ESL_MSA **ret_msa);
+extern int p7_tracealign_MSA (const ESL_MSA *premsa, P7_TRACE **tr,           int M,  int optflags, ESL_MSA **ret_postmsa);
+extern int p7_tracealign_computeTraces(P7_HMM *hmm, ESL_SQ  **sq, int offset, int N, P7_TRACE  **tr);
+extern int p7_tracealign_getMSAandStats(P7_HMM *hmm, ESL_SQ  **sq, int N, ESL_MSA **ret_msa, float **ret_pp, float **ret_relent, float **ret_scores );
+
+/* p7_alidisplay.c */
+extern P7_ALIDISPLAY *p7_alidisplay_Create(const P7_TRACE *tr, int which, const P7_OPROFILE *om, const ESL_SQ *sq, const ESL_SQ *ntsq);
+extern P7_ALIDISPLAY *p7_alidisplay_Create_empty();
+extern P7_ALIDISPLAY *p7_alidisplay_Clone(const P7_ALIDISPLAY *ad);
+extern size_t         p7_alidisplay_Sizeof(const P7_ALIDISPLAY *ad);
+extern int            p7_alidisplay_Serialize(const P7_ALIDISPLAY *obj, uint8_t **buf, uint32_t *n, uint32_t *nalloc);
+extern int            p7_alidisplay_Deserialize(const uint8_t *buf, uint32_t *n, P7_ALIDISPLAY *ret_obj);
+extern int            p7_alidisplay_Serialize_old(P7_ALIDISPLAY *ad);
+extern int            p7_alidisplay_Deserialize_old(P7_ALIDISPLAY *ad);
+extern void           p7_alidisplay_Destroy(P7_ALIDISPLAY *ad);
+extern char           p7_alidisplay_EncodePostProb(float p);
+extern float          p7_alidisplay_DecodePostProb(char pc);
+extern char           p7_alidisplay_EncodeAliPostProb(float p, float hi, float med, float lo);
+
+extern int            p7_alidisplay_Print(FILE *fp, P7_ALIDISPLAY *ad, int min_aliwidth, int linewidth, P7_PIPELINE *pli);
+extern int            p7_translated_alidisplay_Print(FILE *fp, P7_ALIDISPLAY *ad, int min_aliwidth, int linewidth, P7_PIPELINE *pli);
+extern int            p7_nontranslated_alidisplay_Print(FILE *fp, P7_ALIDISPLAY *ad, int min_aliwidth, int linewidth, int show_accessions);
+
+extern int            p7_alidisplay_Backconvert(const P7_ALIDISPLAY *ad, const ESL_ALPHABET *abc, ESL_SQ **ret_sq, P7_TRACE **ret_tr);
+extern int            p7_alidisplay_Sample(ESL_RANDOMNESS *rng, int N, P7_ALIDISPLAY **ret_ad);
+extern int            p7_alidisplay_Dump(FILE *fp, const P7_ALIDISPLAY *ad);
+extern int            p7_alidisplay_Compare(const P7_ALIDISPLAY *ad1, const P7_ALIDISPLAY *ad2);
+
+/* p7_bg.c */
+extern P7_BG *p7_bg_Create(const ESL_ALPHABET *abc);
+extern P7_BG *p7_bg_CreateUniform(const ESL_ALPHABET *abc);
+extern P7_BG *p7_bg_Clone(const P7_BG *bg);
+extern int    p7_bg_Dump(FILE *ofp, const P7_BG *bg);
+extern void   p7_bg_Destroy(P7_BG *bg);
+extern int    p7_bg_SetLength(P7_BG *bg, int L);
+extern int    p7_bg_NullOne(const P7_BG *bg, const ESL_DSQ *dsq, int L, float *ret_sc);
+
+extern int    p7_bg_Read(char *bgfile, P7_BG *bg, char *errbuf);
+extern int    p7_bg_Write(FILE *fp, P7_BG *bg);
+
+extern int    p7_bg_SetFilter  (P7_BG *bg, int M, const float *compo);
+extern int    p7_bg_FilterScore(P7_BG *bg, const ESL_DSQ *dsq, int L, float *ret_sc);
+
+/* p7_builder.c */
+extern P7_BUILDER *p7_builder_Create(const ESL_GETOPTS *go, const ESL_ALPHABET *abc);
+extern int         p7_builder_LoadScoreSystem(P7_BUILDER *bld, const char *matrix,                  double popen, double pextend, P7_BG *bg);
+extern int         p7_builder_SetScoreSystem (P7_BUILDER *bld, const char *mxfile, const char *env, double popen, double pextend, P7_BG *bg);
+extern void        p7_builder_Destroy(P7_BUILDER *bld);
+
+extern int p7_Builder      (P7_BUILDER *bld, ESL_MSA *msa, P7_BG *bg, P7_HMM **opt_hmm, P7_TRACE ***opt_trarr, P7_PROFILE **opt_gm, P7_OPROFILE **opt_om, ESL_MSA **opt_postmsa);
+extern int p7_SingleBuilder(P7_BUILDER *bld, ESL_SQ *sq,   P7_BG *bg, P7_HMM **opt_hmm, P7_TRACE  **opt_tr,    P7_PROFILE **opt_gm, P7_OPROFILE **opt_om); 
+extern int p7_Builder_MaxLength      (P7_HMM *hmm, double emit_thresh);
+
+/* p7_domain.c */
+extern P7_DOMAIN *p7_domain_Create_empty();
+extern void p7_domain_Destroy(P7_DOMAIN *obj);
+extern int p7_domain_Serialize(const P7_DOMAIN *obj, uint8_t **buf, uint32_t *n, uint32_t *nalloc);
+extern int p7_domain_Deserialize(const uint8_t *buf, uint32_t *n, P7_DOMAIN *ret_obj);
+extern int p7_domain_TestSample(ESL_RAND64 *rng, P7_DOMAIN **ret_obj);
+extern int p7_domain_Compare(P7_DOMAIN *first, P7_DOMAIN *second, double atol, double rtol);
+
+/* p7_domaindef.c */
+extern P7_DOMAINDEF *p7_domaindef_Create (ESL_RANDOMNESS *r);
+extern int           p7_domaindef_Fetch  (P7_DOMAINDEF *ddef, int which, int *opt_i, int *opt_j, float *opt_sc, P7_ALIDISPLAY **opt_ad);
+extern int           p7_domaindef_GrowTo (P7_DOMAINDEF *ddef, int L);
+extern int           p7_domaindef_Reuse  (P7_DOMAINDEF *ddef);
+extern int           p7_domaindef_DumpPosteriors(FILE *ofp, P7_DOMAINDEF *ddef);
+extern void          p7_domaindef_Destroy(P7_DOMAINDEF *ddef);
+
+extern int p7_domaindef_ByViterbi            (P7_PROFILE *gm, const ESL_SQ *sq, const ESL_SQ *ntsq, P7_GMX *gx1, P7_GMX *gx2, P7_DOMAINDEF *ddef);
+extern int p7_domaindef_ByPosteriorHeuristics(const ESL_SQ *sq, const ESL_SQ *ntsq, P7_OPROFILE *om, P7_OMX *oxf, P7_OMX *oxb, P7_OMX *fwd, P7_OMX *bck,
+				                                  P7_DOMAINDEF *ddef, P7_BG *bg, int long_target,
+				                                  P7_BG *bg_tmp, float *scores_arr, float *fwd_emissions_arr);
+
+
+/* p7_gmx.c */
+extern P7_GMX *p7_gmx_Create (int allocM, int allocL);
+extern int     p7_gmx_GrowTo (P7_GMX *gx, int allocM, int allocL);
+extern size_t  p7_gmx_Sizeof (P7_GMX *gx);
+extern int     p7_gmx_Reuse  (P7_GMX *gx);
+extern void    p7_gmx_Destroy(P7_GMX *gx);
+extern int     p7_gmx_Compare(P7_GMX *gx1, P7_GMX *gx2, float tolerance);
+extern int     p7_gmx_Dump(FILE *fp, P7_GMX *gx, int flags);
+extern int     p7_gmx_DumpWindow(FILE *fp, P7_GMX *gx, int istart, int iend, int kstart, int kend, int show_specials);
+
+/* p7_hit.c */
+extern P7_HIT *p7_hit_Create_empty();
+extern void p7_hit_Destroy(P7_HIT *the_hit);
+extern int p7_hit_Serialize(const P7_HIT *obj, uint8_t **buf, uint32_t *n, uint32_t *nalloc);
+extern int p7_hit_Deserialize(const uint8_t *buf, uint32_t *n, P7_HIT *ret_obj);
+extern int p7_hit_TestSample(ESL_RAND64 *rng, P7_HIT **ret_obj);
+extern int p7_hit_Compare(P7_HIT *first, P7_HIT *second, double atol, double rtol);
+
+/* p7_hmm.c */
+/*      1. The P7_HMM object: allocation, initialization, destruction. */
+extern P7_HMM *p7_hmm_Create(int M, const ESL_ALPHABET *abc);
+extern P7_HMM *p7_hmm_CreateShell(void);
+extern int     p7_hmm_CreateBody(P7_HMM *hmm, int M, const ESL_ALPHABET *abc);
+extern void    p7_hmm_Destroy(P7_HMM *hmm);
+extern int     p7_hmm_CopyParameters(const P7_HMM *src, P7_HMM *dest);
+extern P7_HMM *p7_hmm_Clone(const P7_HMM *hmm);
+extern int     p7_hmm_Zero(P7_HMM *hmm);
+extern char    p7_hmm_EncodeStatetype(char *typestring);
+extern char   *p7_hmm_DecodeStatetype(char st);
+/*      2. Convenience routines for setting fields in an HMM. */
+extern int     p7_hmm_SetName       (P7_HMM *hmm, char *name);
+extern int     p7_hmm_SetAccession  (P7_HMM *hmm, char *acc);
+extern int     p7_hmm_SetDescription(P7_HMM *hmm, char *desc);
+extern int     p7_hmm_AppendComlog  (P7_HMM *hmm, int argc, char **argv);
+extern int     p7_hmm_SetCtime      (P7_HMM *hmm);
+extern int     p7_hmm_SetComposition(P7_HMM *hmm);
+extern int     p7_hmm_SetConsensus  (P7_HMM *hmm, ESL_SQ *sq);
+/*      3. Renormalization and rescaling counts in core HMMs. */
+extern int     p7_hmm_Scale      (P7_HMM *hmm, double scale);
+extern int     p7_hmm_ScaleExponential(P7_HMM *hmm, double exp);
+extern int     p7_hmm_Renormalize(P7_HMM *hmm);
+/*      4. Debugging and development code. */
+extern int     p7_hmm_Dump(FILE *fp, P7_HMM *hmm);
+extern int     p7_hmm_Sample          (ESL_RANDOMNESS *r, int M, const ESL_ALPHABET *abc, P7_HMM **ret_hmm);
+extern int     p7_hmm_SampleUngapped  (ESL_RANDOMNESS *r, int M, const ESL_ALPHABET *abc, P7_HMM **ret_hmm);
+extern int     p7_hmm_SampleEnumerable(ESL_RANDOMNESS *r, int M, const ESL_ALPHABET *abc, P7_HMM **ret_hmm);
+extern int     p7_hmm_SampleUniform   (ESL_RANDOMNESS *r, int M, const ESL_ALPHABET *abc, 
+				     float tmi, float tii, float tmd, float tdd,  P7_HMM **ret_hmm);
+extern int     p7_hmm_Compare(P7_HMM *h1, P7_HMM *h2, float tol);
+extern int     p7_hmm_Validate(P7_HMM *hmm, char *errbuf, float tol);
+/*      5. Other routines in the API */
+extern int     p7_hmm_CalculateOccupancy(const P7_HMM *hmm, float *mocc, float *iocc);
+
+
+
+/* p7_hmmfile.c */
+extern int  p7_hmmfile_OpenE    (const char *filename, char *env, P7_HMMFILE **ret_hfp, char *errbuf);
+extern int  p7_hmmfile_OpenENoDB(const char *filename, char *env, P7_HMMFILE **ret_hfp, char *errbuf);
+extern int  p7_hmmfile_Open     (const char *filename, char *env, P7_HMMFILE **ret_hfp); /* deprecated */
+extern int  p7_hmmfile_OpenNoDB (const char *filename, char *env, P7_HMMFILE **ret_hfp); /* deprecated */
+extern int  p7_hmmfile_OpenBuffer(const char *buffer, int size, P7_HMMFILE **ret_hfp);
+extern void p7_hmmfile_Close(P7_HMMFILE *hfp);
+#ifdef HMMER_THREADS
+extern int  p7_hmmfile_CreateLock(P7_HMMFILE *hfp);
+#endif
+extern int  p7_hmmfile_WriteBinary(FILE *fp, int format, P7_HMM *hmm);
+extern int  p7_hmmfile_WriteASCII (FILE *fp, int format, P7_HMM *hmm);
+extern int  p7_hmmfile_WriteToString (char **s, int format, P7_HMM *hmm);
+extern int  p7_hmmfile_Read(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc,  P7_HMM **opt_hmm);
+extern int  p7_hmmfile_PositionByKey(P7_HMMFILE *hfp, const char *key);
+extern int  p7_hmmfile_Position(P7_HMMFILE *hfp, const off_t offset);
+
+
+/* p7_hmmwindow.c */
+int p7_hmmwindow_init (P7_HMM_WINDOWLIST *list);
+P7_HMM_WINDOW *p7_hmmwindow_new (P7_HMM_WINDOWLIST *list, uint32_t id, uint32_t pos, uint32_t fm_pos, uint16_t k, uint32_t length, float score, uint8_t complementarity, uint32_t target_len);
+
+
+
+/* p7_msvdata.c */
+extern P7_SCOREDATA   *p7_hmm_ScoreDataCreate(P7_OPROFILE *om, P7_PROFILE *gm );
+extern P7_SCOREDATA   *p7_hmm_ScoreDataClone(P7_SCOREDATA *src, int K);
+extern int            p7_hmm_ScoreDataComputeRest(P7_OPROFILE *om, P7_SCOREDATA *data );
+extern void           p7_hmm_ScoreDataDestroy( P7_SCOREDATA *data );
+extern int            p7_hmm_initWindows (P7_HMM_WINDOWLIST *list);
+extern P7_HMM_WINDOW *p7_hmm_newWindow (P7_HMM_WINDOWLIST *list, uint32_t id, uint32_t pos, uint32_t fm_pos, uint16_t k, uint32_t length, float score, uint8_t complementarity);
+
+
+
+/* p7_null3.c */
+extern void p7_null3_score(const ESL_ALPHABET *abc, const ESL_DSQ *dsq, P7_TRACE *tr, int start, int stop, P7_BG *bg, float *ret_sc);
+extern void p7_null3_windowed_score(const ESL_ALPHABET *abc, const ESL_DSQ *dsq, int start, int stop, P7_BG *bg, float *ret_sc);
+
+/* p7_pipeline.c */
+extern P7_PIPELINE *p7_pipeline_Create(const ESL_GETOPTS *go, int M_hint, int L_hint, int long_targets, enum p7_pipemodes_e mode);
+extern int          p7_pipeline_Reuse  (P7_PIPELINE *pli);
+extern void         p7_pipeline_Destroy(P7_PIPELINE *pli);
+extern int          p7_pipeline_Merge  (P7_PIPELINE *p1, P7_PIPELINE *p2);
+
+extern int p7_pli_ExtendAndMergeWindows (P7_OPROFILE *om, const P7_SCOREDATA *msvdata, P7_HMM_WINDOWLIST *windowlist, float pct_overlap);
+extern int p7_pli_TargetReportable  (P7_PIPELINE *pli, float score,     double lnP);
+extern int p7_pli_DomainReportable  (P7_PIPELINE *pli, float dom_score, double lnP);
+
+extern int p7_pli_TargetIncludable  (P7_PIPELINE *pli, float score,     double lnP);
+extern int p7_pli_DomainIncludable  (P7_PIPELINE *pli, float dom_score, double lnP);
+extern int p7_pli_NewModel          (P7_PIPELINE *pli, const P7_OPROFILE *om, P7_BG *bg);
+extern int p7_pli_NewModelThresholds(P7_PIPELINE *pli, const P7_OPROFILE *om);
+extern int p7_pli_NewSeq            (P7_PIPELINE *pli, const ESL_SQ *sq);
+extern int p7_Pipeline              (P7_PIPELINE *pli, P7_OPROFILE *om, P7_BG *bg, const ESL_SQ *sq, const ESL_SQ *ntsq, P7_TOPHITS *th);
+extern int p7_Pipeline_LongTarget   (P7_PIPELINE *pli, P7_OPROFILE *om, P7_SCOREDATA *data,
+                                     P7_BG *bg, P7_TOPHITS *hitlist, int64_t seqidx,
+                                     const ESL_SQ *sq, int complementarity,
+                                     const FM_DATA *fmf, const FM_DATA *fmb, FM_CFG *fm_cfg
+                                     );
+
+
+
+extern int p7_pli_Statistics(FILE *ofp, P7_PIPELINE *pli, ESL_STOPWATCH *w);
+
+
+/* p7_prior.c */
+extern P7_PRIOR  *p7_prior_CreateAmino(void);
+extern P7_PRIOR  *p7_prior_CreateNucleic(void);
+extern P7_PRIOR  *p7_prior_CreateLaplace(const ESL_ALPHABET *abc);
+extern void       p7_prior_Destroy(P7_PRIOR *pri);
+
+extern int        p7_ParameterEstimation(P7_HMM *hmm, const P7_PRIOR *pri);
+
+/* p7_profile.c */
+extern P7_PROFILE *p7_profile_Create(int M, const ESL_ALPHABET *abc);
+extern P7_PROFILE *p7_profile_Clone(const P7_PROFILE *gm);
+extern int         p7_profile_Copy(const P7_PROFILE *src, P7_PROFILE *dst);
+extern int         p7_profile_SetNullEmissions(P7_PROFILE *gm);
+extern int         p7_profile_Reuse(P7_PROFILE *gm);
+extern size_t      p7_profile_Sizeof(P7_PROFILE *gm);
+extern void        p7_profile_Destroy(P7_PROFILE *gm);
+extern int         p7_profile_IsLocal(const P7_PROFILE *gm);
+extern int         p7_profile_IsMultihit(const P7_PROFILE *gm);
+extern int         p7_profile_GetT(const P7_PROFILE *gm, char st1, int k1, 
+				   char st2, int k2, float *ret_tsc);
+extern int         p7_profile_Validate(const P7_PROFILE *gm, char *errbuf, float tol);
+extern int         p7_profile_Compare(P7_PROFILE *gm1, P7_PROFILE *gm2, float tol);
+
+/* p7_spensemble.c */
+P7_SPENSEMBLE *p7_spensemble_Create(int init_n, int init_epc, int init_sigc);
+extern int     p7_spensemble_Reuse(P7_SPENSEMBLE *sp);
+extern int     p7_spensemble_Add(P7_SPENSEMBLE *sp, int sampleidx, int i, int j, int k, int m);
+extern int     p7_spensemble_Cluster(P7_SPENSEMBLE *sp, 
+				     float min_overlap, int of_smaller, int max_diagdiff, 
+				     float min_posterior, float min_endpointp,
+				     int *ret_nclusters);
+extern int     p7_spensemble_GetClusterCoords(P7_SPENSEMBLE *sp, int which,
+					      int *ret_i, int *ret_j, int *ret_k, int *ret_m, float *ret_p);
+extern void    p7_spensemble_Destroy(P7_SPENSEMBLE *sp);
+
+/* p7_tophits.c */
+extern P7_TOPHITS *p7_tophits_Create(void);
+extern int         p7_tophits_Grow(P7_TOPHITS *h);
+extern int         p7_tophits_CreateNextHit(P7_TOPHITS *h, P7_HIT **ret_hit);
+extern int         p7_tophits_Add(P7_TOPHITS *h,
+				  char *name, char *acc, char *desc, 
+				  double sortkey, 
+				  float score,    double lnP, 
+				  float mothersc, double mother_lnP,
+				  int sqfrom, int sqto, int sqlen,
+				  int hmmfrom, int hmmto, int hmmlen, 
+				  int domidx, int ndom,
+				  P7_ALIDISPLAY *ali);
+extern int         p7_tophits_SortBySortkey(P7_TOPHITS *h);
+extern int         p7_tophits_SortBySeqidxAndAlipos(P7_TOPHITS *h);
+extern int         p7_tophits_SortByModelnameAndAlipos(P7_TOPHITS *h);
+
+extern int         p7_tophits_Merge(P7_TOPHITS *h1, P7_TOPHITS *h2);
+extern int         p7_tophits_GetMaxPositionLength(P7_TOPHITS *h);
+extern int         p7_tophits_GetMaxNameLength(P7_TOPHITS *h);
+extern int         p7_tophits_GetMaxAccessionLength(P7_TOPHITS *h);
+extern int         p7_tophits_GetMaxShownLength(P7_TOPHITS *h);
+extern void        p7_tophits_Destroy(P7_TOPHITS *h);
+
+extern int p7_tophits_ComputeNhmmerEvalues(P7_TOPHITS *th, double N, int W);
+extern int p7_tophits_RemoveDuplicates(P7_TOPHITS *th, int using_bit_cutoffs);
+extern int p7_tophits_Threshold(P7_TOPHITS *th, P7_PIPELINE *pli);
+extern int p7_tophits_CompareRanking(P7_TOPHITS *th, ESL_KEYHASH *kh, int *opt_nnew);
+extern int p7_tophits_Targets(FILE *ofp, P7_TOPHITS *th, P7_PIPELINE *pli, int textw);
+extern int p7_tophits_Domains(FILE *ofp, P7_TOPHITS *th, P7_PIPELINE *pli, int textw);
+
+
+extern int p7_tophits_Alignment(const P7_TOPHITS *th, const ESL_ALPHABET *abc, 
+				ESL_SQ **inc_sqarr, P7_TRACE **inc_trarr, int inc_n, int optflags,
+				ESL_MSA **ret_msa);
+extern int p7_tophits_TabularTargets(FILE *ofp, char *qname, char *qacc, P7_TOPHITS *th, P7_PIPELINE *pli, int show_header);
+extern int p7_tophits_TabularDomains(FILE *ofp, char *qname, char *qacc, P7_TOPHITS *th, P7_PIPELINE *pli, int show_header);
+extern int p7_tophits_TabularXfam(FILE *ofp, char *qname, char *qacc, P7_TOPHITS *th, P7_PIPELINE *pli);
+extern int p7_tophits_TabularTail(FILE *ofp, const char *progname, enum p7_pipemodes_e pipemode, 
+				  const char *qfile, const char *tfile, const ESL_GETOPTS *go);
+extern int p7_tophits_AliScores(FILE *ofp, char *qname, P7_TOPHITS *th );
+
+/* p7_trace.c */
+extern P7_TRACE *p7_trace_Create(void);
+extern P7_TRACE *p7_trace_CreateWithPP(void);
+extern int  p7_trace_Reuse(P7_TRACE *tr);
+extern int  p7_trace_Grow(P7_TRACE *tr);
+extern int  p7_trace_GrowIndex(P7_TRACE *tr);
+extern int  p7_trace_GrowTo(P7_TRACE *tr, int N);
+extern int  p7_trace_GrowIndexTo(P7_TRACE *tr, int ndom);
+extern void p7_trace_Destroy(P7_TRACE *tr);
+extern void p7_trace_DestroyArray(P7_TRACE **tr, int N);
+
+extern int  p7_trace_GetDomainCount   (const P7_TRACE *tr, int *ret_ndom);
+extern int  p7_trace_GetStateUseCounts(const P7_TRACE *tr, int *counts);
+extern int  p7_trace_GetDomainCoords  (const P7_TRACE *tr, int which, int *ret_i1, int *ret_i2,
+				       int *ret_k1, int *ret_k2);
+
+extern int   p7_trace_Validate(const P7_TRACE *tr, const ESL_ALPHABET *abc, const ESL_DSQ *dsq, char *errbuf);
+extern int   p7_trace_Dump(FILE *fp, const P7_TRACE *tr, const P7_PROFILE *gm, const ESL_DSQ *dsq);
+extern int   p7_trace_Compare(P7_TRACE *tr1, P7_TRACE *tr2, float pptol);
+extern int   p7_trace_Score(P7_TRACE *tr, ESL_DSQ *dsq, P7_PROFILE *gm, float *ret_sc);
+extern int   p7_trace_SetPP(P7_TRACE *tr, const P7_GMX *pp);
+extern float p7_trace_GetExpectedAccuracy(const P7_TRACE *tr);
+
+extern int  p7_trace_Append(P7_TRACE *tr, char st, int k, int i);
+extern int  p7_trace_AppendWithPP(P7_TRACE *tr, char st, int k, int i, float pp);
+extern int  p7_trace_Reverse(P7_TRACE *tr);
+extern int  p7_trace_Index(P7_TRACE *tr);
+
+extern int  p7_trace_FauxFromMSA(ESL_MSA *msa, int *matassign, int optflags, P7_TRACE **tr);
+extern int  p7_trace_Doctor(P7_TRACE *tr, int *opt_ndi, int *opt_nid);
+
+extern int  p7_trace_Count(P7_HMM *hmm, ESL_DSQ *dsq, float wt, P7_TRACE *tr);
+
+
+/* seqmodel.c */
+extern int p7_Seqmodel(const ESL_ALPHABET *abc, ESL_DSQ *dsq, int M, char *name,
+		       ESL_DMATRIX *P, float *f, double popen, double pextend,
+		       P7_HMM **ret_hmm);
+
+/* fm_alphabet.c */
+extern int fm_alphabetCreate (FM_METADATA *meta, uint8_t *alph_bits);
+extern int fm_alphabetDestroy (FM_METADATA *meta);
+extern int fm_reverseString (char *str, int N);
+extern int fm_getComplement (char c, uint8_t alph_type);
+
+
+/* fm_general.c */
+extern uint64_t fm_computeSequenceOffset (const FM_DATA *fms, const FM_METADATA *meta, int block, uint64_t pos);
+extern int fm_getOriginalPosition (const FM_DATA *fms, const FM_METADATA *meta, int fm_id, int length, int direction, uint64_t fm_pos,
+                                    uint32_t *segment_id, uint64_t *seg_pos);
+extern int fm_readFMmeta( FM_METADATA *meta);
+extern int fm_FM_read( FM_DATA *fm, FM_METADATA *meta, int getAll );
+extern void fm_FM_destroy ( FM_DATA *fm, int isMainFM);
+extern uint8_t fm_getChar(uint8_t alph_type, int j, const uint8_t *B );
+extern int fm_getSARangeReverse( const FM_DATA *fm, FM_CFG *cfg, char *query, char *inv_alph, FM_INTERVAL *interval);
+extern int fm_getSARangeForward( const FM_DATA *fm, FM_CFG *cfg, char *query, char *inv_alph, FM_INTERVAL *interval);
+extern int fm_configAlloc(FM_CFG **cfg);
+extern int fm_configDestroy(FM_CFG *cfg);
+extern int fm_metaDestroy(FM_METADATA *meta );
+extern int fm_updateIntervalForward( const FM_DATA *fm, const FM_CFG *cfg, char c, FM_INTERVAL *interval_f, FM_INTERVAL *interval_bk);
+extern int fm_updateIntervalReverse( const FM_DATA *fm, const FM_CFG *cfg, char c, FM_INTERVAL *interval);
+extern int fm_initSeeds (FM_DIAGLIST *list) ;
+extern FM_DIAG * fm_newSeed (FM_DIAGLIST *list);
+extern int fm_initAmbiguityList (FM_AMBIGLIST *list);
+extern int fm_addAmbiguityRange (FM_AMBIGLIST *list, uint32_t start, uint32_t stop);
+extern int fm_convertRange2DSQ(const FM_DATA *fm, const FM_METADATA *meta, uint64_t first, int length, int complementarity, ESL_SQ *sq, int fix_ambiguities );
+extern int fm_initConfigGeneric( FM_CFG *cfg, ESL_GETOPTS *go);
+
+/* fm_ssv.c */
+extern int p7_SSVFM_longlarget( P7_OPROFILE *om, float nu, P7_BG *bg, double F1,
+                      const FM_DATA *fmf, const FM_DATA *fmb, FM_CFG *fm_cfg, const P7_SCOREDATA *ssvdata,
+                      int strands, P7_HMM_WINDOWLIST *windowlist);
+
+
+/* fm_sse.c */
+extern int fm_configInit      (FM_CFG *cfg, ESL_GETOPTS *go);
+extern int fm_getOccCount     (const FM_DATA *fm, const FM_CFG *cfg, int pos, uint8_t c);
+extern int fm_getOccCountLT   (const FM_DATA *fm, const FM_CFG *cfg, int pos, uint8_t c, uint32_t *cnteq, uint32_t *cntlt);
+
+#endif /*P7_HMMERH_INCLUDED*/
+
+
diff -Nur hmmer-3.3.orig/src/hmmscan.c hmmer-3.3/src/hmmscan.c
--- hmmer-3.3.orig/src/hmmscan.c	2019-11-18 14:23:12.000000000 +0100
+++ hmmer-3.3/src/hmmscan.c	2019-12-06 15:39:25.116539217 +0100
@@ -420,16 +420,19 @@
     }
 #endif
 
+  /* Open the target profile database */
+  status = p7_hmmfile_OpenE(cfg->hmmfile, p7_HMMDBENV, &hfp, NULL);
+  if (status != eslOK)        p7_Fail("Unexpected error %d in opening hmm file %s.\n",           status, cfg->hmmfile);  
+  
   /* Outside loop: over each query sequence in <seqfile>. */
   while ((sstatus = esl_sqio_Read(sqfp, qsq)) == eslOK)
     {
       nquery++;
       esl_stopwatch_Start(w);	                          
 
-      /* Open the target profile database */
-      status = p7_hmmfile_OpenE(cfg->hmmfile, p7_HMMDBENV, &hfp, NULL);
-      if (status != eslOK)        p7_Fail("Unexpected error %d in opening hmm file %s.\n",           status, cfg->hmmfile);  
-  
+      status = p7_hmmfile_Reset(p7_HMMDBENV, hfp, NULL);
+      if (status != eslOK)        p7_Fail("Unexpected error %d rewinding hmm file %s.\n",           status, cfg->hmmfile);
+
 #ifdef HMMER_THREADS
       /* if we are threaded, create a lock to prevent multiple readers */
       if (ncpus > 0)
@@ -498,7 +501,6 @@
       if (fprintf(ofp, "//\n") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
       fflush(ofp);
 
-      p7_hmmfile_Close(hfp);
       p7_pipeline_Destroy(info->pli);
       p7_tophits_Destroy(info->th);
       esl_sq_Reuse(qsq);
@@ -508,6 +510,8 @@
   else if (sstatus != eslEOF)     esl_fatal("Unexpected error %d reading sequence file %s",
 					    sstatus, sqfp->filename);
 
+  p7_hmmfile_Close(hfp);
+
   /* Terminate outputs - any last words?
    */
   if (tblfp)    p7_tophits_TabularTail(tblfp,    "hmmscan", p7_SCAN_MODELS, cfg->seqfile, cfg->hmmfile, go);
diff -Nur hmmer-3.3.orig/src/hmmscan.c.orig hmmer-3.3/src/hmmscan.c.orig
--- hmmer-3.3.orig/src/hmmscan.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ hmmer-3.3/src/hmmscan.c.orig	2019-11-18 14:23:12.000000000 +0100
@@ -0,0 +1,1288 @@
+/* hmmscan: search sequence(s) against a profile HMM database
+ *
+ * To do:
+ *  - in MPI mode, add a check to make sure ncpus >= 2. If 1, then we
+ *    only have a master, no workers. See Infernal commit r3972 on the
+ *    same point; and same note in hmmsearch.c's to do list.
+ */
+#include "p7_config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "easel.h"
+#include "esl_alphabet.h"
+#include "esl_getopts.h"
+#include "esl_sq.h"
+#include "esl_sqio.h"
+#include "esl_stopwatch.h"
+
+#ifdef HMMER_MPI
+#include "mpi.h"
+#include "esl_mpi.h"
+#endif 
+
+#ifdef HMMER_THREADS
+#include <unistd.h>
+#include "esl_threads.h"
+#include "esl_workqueue.h"
+#endif
+
+#include "hmmer.h"
+
+typedef struct {
+#ifdef HMMER_THREADS
+  ESL_WORK_QUEUE   *queue;
+#endif
+  ESL_SQ           *qsq;
+  P7_BG            *bg;	         /* null model                              */
+  P7_PIPELINE      *pli;         /* work pipeline                           */
+  P7_TOPHITS       *th;          /* top hit results                         */
+} WORKER_INFO;
+
+#define REPOPTS     "-E,-T,--cut_ga,--cut_nc,--cut_tc"
+#define DOMREPOPTS  "--domE,--domT,--cut_ga,--cut_nc,--cut_tc"
+#define INCOPTS     "--incE,--incT,--cut_ga,--cut_nc,--cut_tc"
+#define INCDOMOPTS  "--incdomE,--incdomT,--cut_ga,--cut_nc,--cut_tc"
+#define THRESHOPTS  "-E,-T,--domE,--domT,--incE,--incT,--incdomE,--incdomT,--cut_ga,--cut_nc,--cut_tc"
+
+#if defined (HMMER_THREADS) && defined (HMMER_MPI)
+#define CPUOPTS     "--mpi"
+#define MPIOPTS     "--cpu"
+#else
+#define CPUOPTS     NULL
+#define MPIOPTS     NULL
+#endif
+
+static ESL_OPTIONS options[] = {
+  /* name           type          default  env  range toggles  reqs   incomp                         help                                           docgroup*/
+  { "-h",           eslARG_NONE,   FALSE, NULL, NULL,    NULL,  NULL,  NULL,            "show brief help on version and usage",                          1 },
+  /* Control of output */
+  { "-o",           eslARG_OUTFILE, NULL, NULL, NULL,    NULL,  NULL,  NULL,            "direct output to file <f>, not stdout",                         2 },
+  { "--tblout",     eslARG_OUTFILE, NULL, NULL, NULL,    NULL,  NULL,  NULL,            "save parseable table of per-sequence hits to file <f>",         2 },
+  { "--domtblout",  eslARG_OUTFILE, NULL, NULL, NULL,    NULL,  NULL,  NULL,            "save parseable table of per-domain hits to file <f>",           2 },
+  { "--pfamtblout", eslARG_OUTFILE, NULL, NULL, NULL,    NULL,  NULL,  NULL,            "save table of hits and domains to file, in Pfam format <f>",    2 },
+  { "--acc",        eslARG_NONE,   FALSE, NULL, NULL,    NULL,  NULL,  NULL,            "prefer accessions over names in output",                        2 },
+  { "--noali",      eslARG_NONE,   FALSE, NULL, NULL,    NULL,  NULL,  NULL,            "don't output alignments, so output is smaller",                 2 },
+  { "--notextw",    eslARG_NONE,    NULL, NULL, NULL,    NULL,  NULL, "--textw",        "unlimit ASCII text output line width",                          2 },
+  { "--textw",      eslARG_INT,    "120", NULL, "n>=120",NULL,  NULL, "--notextw",      "set max width of ASCII text output lines",                      2 },
+  /* Control of reporting thresholds */
+  { "-E",           eslARG_REAL,  "10.0", NULL, "x>0",   NULL,  NULL,  REPOPTS,         "report models <= this E-value threshold in output",             4 },
+  { "-T",           eslARG_REAL,   FALSE, NULL, NULL,    NULL,  NULL,  REPOPTS,         "report models >= this score threshold in output",               4 },
+  { "--domE",       eslARG_REAL,  "10.0", NULL, "x>0",   NULL,  NULL,  DOMREPOPTS,      "report domains <= this E-value threshold in output",            4 },
+  { "--domT",       eslARG_REAL,   FALSE, NULL, NULL,    NULL,  NULL,  DOMREPOPTS,      "report domains >= this score cutoff in output",                 4 },
+  /* Control of inclusion (significance) thresholds: */
+  { "--incE",       eslARG_REAL,  "0.01", NULL, "x>0",   NULL,  NULL,  INCOPTS,         "consider models <= this E-value threshold as significant",      5 },
+  { "--incT",       eslARG_REAL,   FALSE, NULL, NULL,    NULL,  NULL,  INCOPTS,         "consider models >= this score threshold as significant",        5 },
+  { "--incdomE",    eslARG_REAL,  "0.01", NULL, "x>0",   NULL,  NULL,  INCDOMOPTS,      "consider domains <= this E-value threshold as significant",     5 },
+  { "--incdomT",    eslARG_REAL,   FALSE, NULL, NULL,    NULL,  NULL,  INCDOMOPTS,      "consider domains >= this score threshold as significant",       5 },
+  /* Model-specific thresholding for both reporting and inclusion */
+  { "--cut_ga",     eslARG_NONE,   FALSE, NULL, NULL,    NULL,  NULL,  THRESHOPTS,      "use profile's GA gathering cutoffs to set all thresholding",    6 },
+  { "--cut_nc",     eslARG_NONE,   FALSE, NULL, NULL,    NULL,  NULL,  THRESHOPTS,      "use profile's NC noise cutoffs to set all thresholding",        6 },
+  { "--cut_tc",     eslARG_NONE,   FALSE, NULL, NULL,    NULL,  NULL,  THRESHOPTS,      "use profile's TC trusted cutoffs to set all thresholding",      6 },
+  /* Control of acceleration pipeline */
+  { "--max",        eslARG_NONE,   FALSE, NULL, NULL,    NULL,  NULL, "--F1,--F2,--F3", "Turn all heuristic filters off (less speed, more power)",       7 },
+  { "--F1",         eslARG_REAL,  "0.02", NULL, NULL,    NULL,  NULL, "--max",          "MSV threshold: promote hits w/ P <= F1",                        7 },
+  { "--F2",         eslARG_REAL,  "1e-3", NULL, NULL,    NULL,  NULL, "--max",          "Vit threshold: promote hits w/ P <= F2",                        7 },
+  { "--F3",         eslARG_REAL,  "1e-5", NULL, NULL,    NULL,  NULL, "--max",          "Fwd threshold: promote hits w/ P <= F3",                        7 },
+  { "--nobias",     eslARG_NONE,    NULL, NULL, NULL,    NULL,  NULL, "--max",          "turn off composition bias filter",                              7 },
+  /* Other options */
+  { "--nonull2",    eslARG_NONE,    NULL, NULL, NULL,    NULL,  NULL,  NULL,            "turn off biased composition score corrections",                12 },
+  { "-Z",           eslARG_REAL,   FALSE, NULL, "x>0",   NULL,  NULL,  NULL,            "set # of comparisons done, for E-value calculation",           12 },
+  { "--domZ",       eslARG_REAL,   FALSE, NULL, "x>0",   NULL,  NULL,  NULL,            "set # of significant seqs, for domain E-value calculation",    12 },
+  { "--seed",       eslARG_INT,    "42",  NULL, "n>=0",  NULL,  NULL,  NULL,            "set RNG seed to <n> (if 0: one-time arbitrary seed)",          12 },
+  { "--qformat",    eslARG_STRING,  NULL, NULL, NULL,    NULL,  NULL,  NULL,            "assert input <seqfile> is in format <s>: no autodetection",    12 },
+#ifdef HMMER_THREADS
+  { "--cpu",        eslARG_INT, p7_NCPU,"HMMER_NCPU","n>=0",NULL,  NULL,  CPUOPTS,      "number of parallel CPU workers to use for multithreads",       12 },
+#endif
+#ifdef HMMER_MPI
+  { "--stall",      eslARG_NONE,   FALSE, NULL, NULL,    NULL,"--mpi", NULL,            "arrest after start: for debugging MPI under gdb",              12 },  
+  { "--mpi",        eslARG_NONE,   FALSE, NULL, NULL,    NULL,  NULL,  MPIOPTS,         "run as an MPI parallel program",                               12 },
+#endif
+  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+};
+
+
+/* struct cfg_s : "Global" application configuration shared by all threads/processes
+ * 
+ * This structure is passed to routines within main.c, as a means of semi-encapsulation
+ * of shared data amongst different parallel processes (threads or MPI processes).
+ */
+struct cfg_s {
+  char            *seqfile;           /* query sequence file                             */
+  char            *hmmfile;           /* database HMM file                               */
+
+  int              do_mpi;            /* TRUE if we're doing MPI parallelization         */
+  int              nproc;             /* how many MPI processes, total                   */
+  int              my_rank;           /* who am I, in 0..nproc-1                         */
+};
+
+static char usage[]  = "[-options] <hmmdb> <seqfile>";
+static char banner[] = "search sequence(s) against a profile database";
+
+static int  serial_master(ESL_GETOPTS *go, struct cfg_s *cfg);
+static int  serial_loop  (WORKER_INFO *info, P7_HMMFILE *hfp);
+
+#ifdef HMMER_THREADS
+#define BLOCK_SIZE 1000
+
+static int  thread_loop(ESL_THREADS *obj, ESL_WORK_QUEUE *queue, P7_HMMFILE *hfp);
+static void pipeline_thread(void *arg);
+#endif
+
+#ifdef HMMER_MPI
+static int  mpi_master   (ESL_GETOPTS *go, struct cfg_s *cfg);
+static int  mpi_worker   (ESL_GETOPTS *go, struct cfg_s *cfg);
+#endif
+
+/* process_commandline()
+ * 
+ * Processes the commandline, filling in fields in <cfg> and creating and returning
+ * an <ESL_GETOPTS> options structure. The help page (hmmsearch -h) is formatted
+ * here.
+ */
+static int
+process_commandline(int argc, char **argv, ESL_GETOPTS **ret_go, char **ret_hmmfile, char **ret_seqfile)
+{
+  ESL_GETOPTS *go = esl_getopts_Create(options);
+  int          status;
+
+  if (esl_opt_ProcessEnvironment(go)         != eslOK)  { if (printf("Failed to process environment: %s\n", go->errbuf) < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed"); goto FAILURE; }
+  if (esl_opt_ProcessCmdline(go, argc, argv) != eslOK)  { if (printf("Failed to parse command line: %s\n",  go->errbuf) < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed"); goto FAILURE; }
+  if (esl_opt_VerifyConfig(go)               != eslOK)  { if (printf("Failed to parse command line: %s\n",  go->errbuf) < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed"); goto FAILURE; }
+ 
+  /* help format: */
+  if (esl_opt_GetBoolean(go, "-h") == TRUE) 
+    {
+      p7_banner(stdout, argv[0], banner);
+      esl_usage(stdout, argv[0], usage);
+      if (puts("\nBasic options:")                                           < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+      esl_opt_DisplayHelp(stdout, go, 1, 2, 80); /* 1= group; 2 = indentation; 80=textwidth*/
+
+      if (puts("\nOptions controlling output:")                              < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+      esl_opt_DisplayHelp(stdout, go, 2, 2, 80); 
+
+      if (puts("\nOptions controlling reporting thresholds:")                < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+      esl_opt_DisplayHelp(stdout, go, 4, 2, 80); 
+
+      if (puts("\nOptions controlling inclusion (significance) thresholds:") < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+      esl_opt_DisplayHelp(stdout, go, 5, 2, 80); 
+
+      if (puts("\nOptions for model-specific thresholding:")                 < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+      esl_opt_DisplayHelp(stdout, go, 6, 2, 80); 
+
+      if (puts("\nOptions controlling acceleration heuristics:")             < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+      esl_opt_DisplayHelp(stdout, go, 7, 2, 80); 
+
+      if (puts("\nOther expert options:")                                    < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+      esl_opt_DisplayHelp(stdout, go, 12, 2, 80); 
+      exit(0);
+    }
+
+  if (esl_opt_ArgNumber(go)                 != 2)      { if (puts("Incorrect number of command line arguments.")      < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed"); goto FAILURE; }
+  if ((*ret_hmmfile = esl_opt_GetArg(go, 1)) == NULL)  { if (puts("Failed to get <hmmdb> argument on command line")   < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed"); goto FAILURE; }
+  if ((*ret_seqfile = esl_opt_GetArg(go, 2)) == NULL)  { if (puts("Failed to get <seqfile> argument on command line") < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed"); goto FAILURE; }
+
+  /* Validate any attempted use of stdin streams */
+  if (strcmp(*ret_hmmfile, "-") == 0) 
+    { if (puts("hmmscan cannot read <hmm database> from stdin stream, because it must have hmmpress'ed auxfiles") < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");   goto FAILURE;  }
+
+  *ret_go = go;
+  return eslOK;
+  
+ FAILURE:  /* all errors handled here are user errors, so be polite.  */
+  esl_usage(stdout, argv[0], usage);
+  if (puts("\nwhere most common options are:")                                 < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+  esl_opt_DisplayHelp(stdout, go, 1, 2, 80); /* 1= group; 2 = indentation; 80=textwidth*/
+  if (printf("\nTo see more help on available options, do %s -h\n\n", argv[0]) < 0) ESL_XEXCEPTION_SYS(eslEWRITE, "write failed");
+  esl_getopts_Destroy(go);
+  exit(1);  
+
+ ERROR:
+  if (go) esl_getopts_Destroy(go);
+  exit(status);
+}
+
+
+static int
+output_header(FILE *ofp, ESL_GETOPTS *go, char *hmmfile, char *seqfile)
+{
+  p7_banner(ofp, go->argv[0], banner);
+  
+  if (fprintf(ofp, "# query sequence file:             %s\n", seqfile)                                                                              < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (fprintf(ofp, "# target HMM database:             %s\n", hmmfile)                                                                              < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "-o")          && fprintf(ofp, "# output directed to file:         %s\n",            esl_opt_GetString(go, "-o"))          < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--tblout")    && fprintf(ofp, "# per-seq hits tabular output:     %s\n",            esl_opt_GetString(go, "--tblout"))    < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--domtblout") && fprintf(ofp, "# per-dom hits tabular output:     %s\n",            esl_opt_GetString(go, "--domtblout")) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--pfamtblout")&& fprintf(ofp, "# pfam-style tabular hit output:   %s\n",            esl_opt_GetString(go, "--pfamtblout")) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--acc")       && fprintf(ofp, "# prefer accessions over names:    yes\n")                                                 < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--noali")     && fprintf(ofp, "# show alignments in output:       no\n")                                                  < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--notextw")   && fprintf(ofp, "# max ASCII text line length:      unlimited\n")                                           < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--textw")     && fprintf(ofp, "# max ASCII text line length:      %d\n",            esl_opt_GetInteger(go, "--textw"))    < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");  
+  if (esl_opt_IsUsed(go, "-E")          && fprintf(ofp, "# profile reporting threshold:     E-value <= %g\n", esl_opt_GetReal(go, "-E"))            < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "-T")          && fprintf(ofp, "# profile reporting threshold:     score >= %g\n",   esl_opt_GetReal(go, "-T"))            < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--domE")      && fprintf(ofp, "# domain reporting threshold:      E-value <= %g\n", esl_opt_GetReal(go, "--domE"))        < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--domT")      && fprintf(ofp, "# domain reporting threshold:      score >= %g\n",   esl_opt_GetReal(go, "--domT"))        < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--incE")      && fprintf(ofp, "# profile inclusion threshold:     E-value <= %g\n", esl_opt_GetReal(go, "--incE"))        < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--incT")      && fprintf(ofp, "# profile inclusion threshold:     score >= %g\n",   esl_opt_GetReal(go, "--incT"))        < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--incdomE")   && fprintf(ofp, "# domain inclusion threshold:      E-value <= %g\n", esl_opt_GetReal(go, "--incdomE"))     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--incdomT")   && fprintf(ofp, "# domain inclusion threshold:      score >= %g\n",   esl_opt_GetReal(go, "--incdomT"))     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--cut_ga")    && fprintf(ofp, "# model-specific thresholding:     GA cutoffs\n")                                          < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--cut_nc")    && fprintf(ofp, "# model-specific thresholding:     NC cutoffs\n")                                          < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--cut_tc")    && fprintf(ofp, "# model-specific thresholding:     TC cutoffs\n")                                          < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--max")       && fprintf(ofp, "# Max sensitivity mode:            on [all heuristic filters off]\n")                      < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--F1")        && fprintf(ofp, "# MSV filter P threshold:       <= %g\n",            esl_opt_GetReal(go, "--F1"))          < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--F2")        && fprintf(ofp, "# Vit filter P threshold:       <= %g\n",            esl_opt_GetReal(go, "--F2"))          < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--F3")        && fprintf(ofp, "# Fwd filter P threshold:       <= %g\n",            esl_opt_GetReal(go, "--F3"))          < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--nobias")    && fprintf(ofp, "# biased composition HMM filter:   off\n")                                                 < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--nonull2")   && fprintf(ofp, "# null2 bias corrections:          off\n")                                                 < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "-Z")          && fprintf(ofp, "# sequence search space set to:    %.0f\n",          esl_opt_GetReal(go, "-Z"))            < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--domZ")      && fprintf(ofp, "# domain search space set to:      %.0f\n",          esl_opt_GetReal(go, "--domZ"))        < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  if (esl_opt_IsUsed(go, "--seed"))  {
+    if (esl_opt_GetInteger(go, "--seed")==0 && fprintf(ofp, "# random number seed:              one-time arbitrary\n")                              < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+    else if (                                  fprintf(ofp, "# random number seed set to:       %d\n",        esl_opt_GetInteger(go, "--seed"))     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  }
+  if (esl_opt_IsUsed(go, "--qformat")   && fprintf(ofp, "# input seqfile format asserted:   %s\n",            esl_opt_GetString(go, "--qformat"))   < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+#ifdef HMMER_THREADS
+  if (esl_opt_IsUsed(go, "--cpu")       && fprintf(ofp, "# number of worker threads:        %d\n",            esl_opt_GetInteger(go, "--cpu"))      < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");  
+#endif
+#ifdef HMMER_MPI
+  if (esl_opt_IsUsed(go, "--mpi")       && fprintf(ofp, "# MPI:                             on\n")                                                  < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+#endif
+  if (fprintf(ofp, "# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n")                                                 < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+  return eslOK;
+}
+
+
+int
+main(int argc, char **argv)
+{
+  ESL_GETOPTS     *go  = NULL;	
+  struct cfg_s     cfg;         
+  int              status   = eslOK;
+
+  impl_Init();			/* processor-specific initialization */
+  p7_FLogsumInit();		/* we're going to use table-driven Logsum() approximations at times */
+
+  /* Initialize what we can in the config structure (without knowing the alphabet yet) */
+  cfg.hmmfile    = NULL;
+  cfg.seqfile    = NULL;
+  cfg.do_mpi     = FALSE;	           /* this gets reset below, if we init MPI */
+  cfg.nproc      = 0;		           /* this gets reset below, if we init MPI */
+  cfg.my_rank    = 0;		           /* this gets reset below, if we init MPI */
+
+  process_commandline(argc, argv, &go, &cfg.hmmfile, &cfg.seqfile);    
+
+  /* Figure out who we are, and send control there: 
+   * we might be an MPI master, an MPI worker, or a serial program.
+   */
+#ifdef HMMER_MPI
+  /* pause the execution of the programs execution until the user has a
+   * chance to attach with a debugger and send a signal to resume execution
+   * i.e. (gdb) signal SIGCONT
+   */
+  if (esl_opt_GetBoolean(go, "--stall")) pause();
+
+  if (esl_opt_GetBoolean(go, "--mpi")) 
+    {
+      cfg.do_mpi     = TRUE;
+      MPI_Init(&argc, &argv);
+      MPI_Comm_rank(MPI_COMM_WORLD, &(cfg.my_rank));
+      MPI_Comm_size(MPI_COMM_WORLD, &(cfg.nproc));
+
+      if (cfg.my_rank > 0)  status = mpi_worker(go, &cfg);
+      else 		    status = mpi_master(go, &cfg);
+
+      MPI_Finalize();
+    }
+  else
+#endif /*HMMER_MPI*/
+    {
+      status = serial_master(go, &cfg);
+    }
+
+  esl_getopts_Destroy(go);
+  return status;
+}
+
+
+/* serial_master()
+ * The serial version of hmmsearch.
+ * For each query HMM in <hmmdb> search the database for hits.
+ * 
+ * A master can only return if it's successful. All errors are handled
+ * immediately and fatally with p7_Fail().
+ */
+static int
+serial_master(ESL_GETOPTS *go, struct cfg_s *cfg)
+{
+  FILE            *ofp      = stdout;	         /* output file for results (default stdout)        */
+  FILE            *tblfp    = NULL;		 /* output stream for tabular per-seq (--tblout)    */
+  FILE            *domtblfp = NULL;	  	 /* output stream for tabular per-seq (--domtblout) */
+  FILE            *pfamtblfp= NULL;              /* output stream for pfam tabular output (--pfamtblout)    */
+  int              seqfmt   = eslSQFILE_UNKNOWN; /* format of seqfile                               */
+  ESL_SQFILE      *sqfp     = NULL;              /* open seqfile                                    */
+  P7_HMMFILE      *hfp      = NULL;		 /* open HMM database file                          */
+  ESL_ALPHABET    *abc      = NULL;              /* sequence alphabet                               */
+  P7_OPROFILE     *om       = NULL;		 /* target profile                                  */
+  ESL_STOPWATCH   *w        = NULL;              /* timing                                          */
+  ESL_SQ          *qsq      = NULL;		 /* query sequence                                  */
+  int              nquery   = 0;
+  int              textw;
+  int              status   = eslOK;
+  int              hstatus  = eslOK;
+  int              sstatus  = eslOK;
+  int              i;
+
+  int              ncpus    = 0;
+
+  int              infocnt  = 0;
+  WORKER_INFO     *info     = NULL;
+#ifdef HMMER_THREADS
+  P7_OM_BLOCK     *block    = NULL;
+  ESL_THREADS     *threadObj= NULL;
+  ESL_WORK_QUEUE  *queue    = NULL;
+#endif
+  char             errbuf[eslERRBUFSIZE];
+
+  w = esl_stopwatch_Create();
+
+  if (esl_opt_GetBoolean(go, "--notextw")) textw = 0;
+  else                                     textw = esl_opt_GetInteger(go, "--textw");
+
+  /* If caller declared an input format, decode it */
+  if (esl_opt_IsOn(go, "--qformat")) {
+    seqfmt = esl_sqio_EncodeFormat(esl_opt_GetString(go, "--qformat"));
+    if (seqfmt == eslSQFILE_UNKNOWN) p7_Fail("%s is not a recognized input sequence file format\n", esl_opt_GetString(go, "--qformat"));
+  }
+
+  /* Open the target profile database to get the sequence alphabet */
+  status = p7_hmmfile_OpenE(cfg->hmmfile, p7_HMMDBENV, &hfp, errbuf);
+  if      (status == eslENOTFOUND) p7_Fail("File existence/permissions problem in trying to open HMM file %s.\n%s\n", cfg->hmmfile, errbuf);
+  else if (status == eslEFORMAT)   p7_Fail("File format problem, trying to open HMM file %s.\n%s\n",                  cfg->hmmfile, errbuf);
+  else if (status != eslOK)        p7_Fail("Unexpected error %d in opening HMM file %s.\n%s\n",               status, cfg->hmmfile, errbuf);  
+  if (! hfp->is_pressed)           p7_Fail("Failed to open binary auxfiles for %s: use hmmpress first\n",             hfp->fname);
+
+  hstatus = p7_oprofile_ReadMSV(hfp, &abc, &om);
+  if      (hstatus == eslEFORMAT)   p7_Fail("bad format, binary auxfiles, %s:\n%s",     cfg->hmmfile, hfp->errbuf);
+  else if (hstatus == eslEINCOMPAT) p7_Fail("HMM file %s contains different alphabets", cfg->hmmfile);
+  else if (hstatus != eslOK)        p7_Fail("Unexpected error in reading HMMs from %s", cfg->hmmfile); 
+
+  p7_oprofile_Destroy(om);
+  p7_hmmfile_Close(hfp);
+
+  /* Open the query sequence database */
+  status = esl_sqfile_OpenDigital(abc, cfg->seqfile, seqfmt, NULL, &sqfp);
+  if      (status == eslENOTFOUND) p7_Fail("Failed to open sequence file %s for reading\n",      cfg->seqfile);
+  else if (status == eslEFORMAT)   p7_Fail("Sequence file %s is empty or misformatted\n",        cfg->seqfile);
+  else if (status == eslEINVAL)    p7_Fail("Can't autodetect format of a stdin or .gz seqfile");
+  else if (status != eslOK)        p7_Fail("Unexpected error %d opening sequence file %s\n", status, cfg->seqfile);
+  qsq = esl_sq_CreateDigital(abc);
+
+  /* Open the results output files */
+  if (esl_opt_IsOn(go, "-o"))          { if ((ofp      = fopen(esl_opt_GetString(go, "-o"),          "w")) == NULL)  esl_fatal("Failed to open output file %s for writing\n",                 esl_opt_GetString(go, "-o")); }
+  if (esl_opt_IsOn(go, "--tblout"))    { if ((tblfp    = fopen(esl_opt_GetString(go, "--tblout"),    "w")) == NULL)  esl_fatal("Failed to open tabular per-seq output file %s for writing\n", esl_opt_GetString(go, "--tblout")); }
+  if (esl_opt_IsOn(go, "--domtblout")) { if ((domtblfp = fopen(esl_opt_GetString(go, "--domtblout"), "w")) == NULL)  esl_fatal("Failed to open tabular per-dom output file %s for writing\n", esl_opt_GetString(go, "--domtblout")); }
+  if (esl_opt_IsOn(go, "--pfamtblout")){ if ((pfamtblfp = fopen(esl_opt_GetString(go, "--pfamtblout"), "w")) == NULL)  esl_fatal("Failed to open pfam-style tabular output file %s for writing\n", esl_opt_GetString(go, "--pfamtblout")); }
+
+  output_header(ofp, go, cfg->hmmfile, cfg->seqfile);
+
+#ifdef HMMER_THREADS
+  /* initialize thread data */
+  ncpus = ESL_MIN( esl_opt_GetInteger(go, "--cpu"), esl_threads_GetCPUCount());
+  if (ncpus > 0)
+    {
+      threadObj = esl_threads_Create(&pipeline_thread);
+      queue = esl_workqueue_Create(ncpus * 2);
+    }
+#endif
+
+  infocnt = (ncpus == 0) ? 1 : ncpus;
+  ESL_ALLOC(info, sizeof(*info) * infocnt);
+
+  for (i = 0; i < infocnt; ++i)
+    {
+      info[i].bg    = p7_bg_Create(abc);
+#ifdef HMMER_THREADS
+      info[i].queue = queue;
+#endif
+    }
+
+#ifdef HMMER_THREADS
+  for (i = 0; i < ncpus * 2; ++i)
+    {
+      block = p7_oprofile_CreateBlock(BLOCK_SIZE);
+      if (block == NULL)    esl_fatal("Failed to allocate sequence block");
+
+      status = esl_workqueue_Init(queue, block);
+      if (status != eslOK)  esl_fatal("Failed to add block to work queue");
+    }
+#endif
+
+  /* Outside loop: over each query sequence in <seqfile>. */
+  while ((sstatus = esl_sqio_Read(sqfp, qsq)) == eslOK)
+    {
+      nquery++;
+      esl_stopwatch_Start(w);	                          
+
+      /* Open the target profile database */
+      status = p7_hmmfile_OpenE(cfg->hmmfile, p7_HMMDBENV, &hfp, NULL);
+      if (status != eslOK)        p7_Fail("Unexpected error %d in opening hmm file %s.\n",           status, cfg->hmmfile);  
+  
+#ifdef HMMER_THREADS
+      /* if we are threaded, create a lock to prevent multiple readers */
+      if (ncpus > 0)
+	{
+	  status = p7_hmmfile_CreateLock(hfp);
+	  if (status != eslOK) p7_Fail("Unexpected error %d creating lock\n", status);
+	}
+#endif
+
+      if (fprintf(ofp, "Query:       %s  [L=%ld]\n", qsq->name, (long) qsq->n) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+      if (qsq->acc[0]  != 0 && fprintf(ofp, "Accession:   %s\n", qsq->acc)     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+      if (qsq->desc[0] != 0 && fprintf(ofp, "Description: %s\n", qsq->desc)    < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+
+      for (i = 0; i < infocnt; ++i)
+	{
+	  /* Create processing pipeline and hit list */
+	  info[i].th  = p7_tophits_Create(); 
+	  info[i].pli = p7_pipeline_Create(go, 100, 100, FALSE, p7_SCAN_MODELS); /* M_hint = 100, L_hint = 100 are just dummies for now */
+	  info[i].pli->hfp = hfp;  /* for two-stage input, pipeline needs <hfp> */
+
+	  p7_pli_NewSeq(info[i].pli, qsq);
+	  info[i].qsq = qsq;
+
+#ifdef HMMER_THREADS
+	  if (ncpus > 0) esl_threads_AddThread(threadObj, &info[i]);
+#endif
+	}
+
+#ifdef HMMER_THREADS
+      if (ncpus > 0)  hstatus = thread_loop(threadObj, queue, hfp);
+      else	      hstatus = serial_loop(info, hfp);
+#else
+      hstatus = serial_loop(info, hfp);
+#endif
+      switch(hstatus)
+	{
+	case eslEFORMAT:   p7_Fail("bad file format in HMM file %s",             cfg->hmmfile);	  break;
+	case eslEINCOMPAT: p7_Fail("HMM file %s contains different alphabets",   cfg->hmmfile);	  break;
+	case eslEOF: 	  /* do nothing */                                                 	  break;
+	default: 	   p7_Fail("Unexpected error in reading HMMs from %s",   cfg->hmmfile); 
+	}
+
+      /* merge the results of the search results */
+      for (i = 1; i < infocnt; ++i)
+	{
+	  p7_tophits_Merge(info[0].th, info[i].th);
+	  p7_pipeline_Merge(info[0].pli, info[i].pli);
+
+	  p7_pipeline_Destroy(info[i].pli);
+	  p7_tophits_Destroy(info[i].th);
+	}
+
+      /* Print results */
+      p7_tophits_SortBySortkey(info->th);
+      p7_tophits_Threshold(info->th, info->pli);
+
+      p7_tophits_Targets(ofp, info->th, info->pli, textw); if (fprintf(ofp, "\n\n") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+      p7_tophits_Domains(ofp, info->th, info->pli, textw); if (fprintf(ofp, "\n\n") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+
+      if (tblfp)     p7_tophits_TabularTargets(tblfp,    qsq->name, qsq->acc, info->th, info->pli, (nquery == 1));
+      if (domtblfp)  p7_tophits_TabularDomains(domtblfp, qsq->name, qsq->acc, info->th, info->pli, (nquery == 1));
+      if (pfamtblfp) p7_tophits_TabularXfam(pfamtblfp, qsq->name, qsq->acc, info->th, info->pli);
+
+      esl_stopwatch_Stop(w);
+      p7_pli_Statistics(ofp, info->pli, w);
+      if (fprintf(ofp, "//\n") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+      fflush(ofp);
+
+      p7_hmmfile_Close(hfp);
+      p7_pipeline_Destroy(info->pli);
+      p7_tophits_Destroy(info->th);
+      esl_sq_Reuse(qsq);
+    }
+  if      (sstatus == eslEFORMAT) esl_fatal("Parse failed (sequence file %s):\n%s\n",
+					    sqfp->filename, esl_sqfile_GetErrorBuf(sqfp));
+  else if (sstatus != eslEOF)     esl_fatal("Unexpected error %d reading sequence file %s",
+					    sstatus, sqfp->filename);
+
+  /* Terminate outputs - any last words?
+   */
+  if (tblfp)    p7_tophits_TabularTail(tblfp,    "hmmscan", p7_SCAN_MODELS, cfg->seqfile, cfg->hmmfile, go);
+  if (domtblfp) p7_tophits_TabularTail(domtblfp, "hmmscan", p7_SCAN_MODELS, cfg->seqfile, cfg->hmmfile, go);
+  if (pfamtblfp)p7_tophits_TabularTail(pfamtblfp,"hmmscan", p7_SEARCH_SEQS, cfg->seqfile, cfg->hmmfile, go);
+  if (ofp)      { if (fprintf(ofp, "[ok]\n") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed"); }
+
+  /* Cleanup - prepare for successful exit
+   */
+  for (i = 0; i < infocnt; ++i)
+    p7_bg_Destroy(info[i].bg);
+
+#ifdef HMMER_THREADS
+  if (ncpus > 0)
+    {
+      esl_workqueue_Reset(queue);
+      while (esl_workqueue_Remove(queue, (void **) &block) == eslOK)
+	p7_oprofile_DestroyBlock(block);
+      esl_workqueue_Destroy(queue);
+      esl_threads_Destroy(threadObj);
+    }
+#endif
+
+  free(info);
+
+  esl_sq_Destroy(qsq);
+  esl_stopwatch_Destroy(w);
+  esl_alphabet_Destroy(abc);
+  esl_sqfile_Close(sqfp);
+
+  if (ofp != stdout) fclose(ofp);
+  if (tblfp)         fclose(tblfp);
+  if (domtblfp)      fclose(domtblfp);
+  if (pfamtblfp)     fclose(pfamtblfp);
+  return eslOK;
+
+ ERROR:
+  return status;
+}
+
+#ifdef HMMER_MPI
+
+/* Define common tags used by the MPI master/slave processes */
+#define HMMER_ERROR_TAG          1
+#define HMMER_HMM_TAG            2
+#define HMMER_SEQUENCE_TAG       3
+#define HMMER_BLOCK_TAG          4
+#define HMMER_PIPELINE_TAG       5
+#define HMMER_TOPHITS_TAG        6
+#define HMMER_HIT_TAG            7
+#define HMMER_TERMINATING_TAG    8
+#define HMMER_READY_TAG          9
+
+/* mpi_failure()
+ * Generate an error message.  If the clients rank is not 0, a
+ * message is created with the error message and sent to the
+ * master process for handling.
+ */
+static void
+mpi_failure(char *format, ...)
+{
+  va_list  argp;
+  int      status = eslFAIL;
+  int      len;
+  int      rank;
+  char     str[512];
+
+  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
+
+  /* format the error mesg */
+  va_start(argp, format);
+  len = vsnprintf(str, sizeof(str), format, argp);
+  va_end(argp);
+
+  /* make sure the error string is terminated */
+  str[sizeof(str)-1] = '\0';
+
+  /* if the caller is the master, print the results and abort */
+  if (rank == 0)
+    {
+      if (fprintf(stderr, "\nError: ") < 0) exit(eslEWRITE);
+      if (fprintf(stderr, "%s", str)   < 0) exit(eslEWRITE);
+      if (fprintf(stderr, "\n")        < 0) exit(eslEWRITE);
+      fflush(stderr);
+
+      MPI_Abort(MPI_COMM_WORLD, status);
+      exit(1);
+    }
+  else
+    {
+      MPI_Send(str, len, MPI_CHAR, 0, HMMER_ERROR_TAG, MPI_COMM_WORLD);
+      pause();
+    }
+}
+
+#define MAX_BLOCK_SIZE (512*1024)
+
+typedef struct {
+  uint64_t  offset;
+  uint64_t  length;
+  uint64_t  count;
+} MSV_BLOCK;
+
+typedef struct {
+  int        complete;
+  int        size;
+  int        current;
+  int        last;
+  MSV_BLOCK *blocks;
+} BLOCK_LIST;
+
+/* this routine parses the database keeping track of the blocks
+ * offset within the file, number of sequences and the length
+ * of the block.  These blocks are passed as work units to the
+ * MPI workers.  If multiple hmm's are in the query file, the
+ * blocks are reused without parsing the database a second time.
+ */
+int next_block(P7_HMMFILE *hfp, BLOCK_LIST *list, MSV_BLOCK *block)
+{
+  P7_OPROFILE   *om       = NULL;
+  ESL_ALPHABET  *abc      = NULL;
+  int            status   = eslOK;
+
+  /* if the list has been calculated, use it instead of parsing the database */
+  if (list->complete)
+    {
+      if (list->current == list->last)
+	{
+	  block->offset = 0;
+	  block->length = 0;
+	  block->count  = 0;
+
+	  status = eslEOF;
+	}
+      else
+	{
+	  int inx = list->current++;
+
+	  block->offset = list->blocks[inx].offset;
+	  block->length = list->blocks[inx].length;
+	  block->count  = list->blocks[inx].count;
+
+	  status = eslOK;
+	}
+
+      return status;
+    }
+
+  block->offset = 0;
+  block->length = 0;
+  block->count = 0;
+
+  while (block->length < MAX_BLOCK_SIZE && (status = p7_oprofile_ReadInfoMSV(hfp, &abc, &om)) == eslOK)
+    {
+      if (block->count == 0) block->offset = om->roff;
+      block->length = om->eoff - block->offset + 1;
+      block->count++;
+      p7_oprofile_Destroy(om);
+    }
+
+  if (status == eslEOF && block->count > 0) status = eslOK;
+  if (status == eslEOF) list->complete = 1;
+
+  /* add the block to the list of known blocks */
+  if (status == eslOK)
+    {
+      int inx;
+
+      if (list->last >= list->size)
+	{
+	  void *tmp;
+	  list->size += 500;
+	  ESL_RALLOC(list->blocks, tmp, sizeof(MSV_BLOCK) * list->size);
+	}
+
+      inx = list->last++;
+      list->blocks[inx].offset = block->offset;
+      list->blocks[inx].length = block->length;
+      list->blocks[inx].count  = block->count;
+    }
+
+  return status;
+
+ ERROR:
+  return eslEMEM;
+}
+
+/* mpi_master()
+ * The MPI version of hmmscan
+ * Follows standard pattern for a master/worker load-balanced MPI program (J1/78-79).
+ * 
+ * A master can only return if it's successful. 
+ * Errors in an MPI master come in two classes: recoverable and nonrecoverable.
+ * 
+ * Recoverable errors include all worker-side errors, and any
+ * master-side error that do not affect MPI communication. Error
+ * messages from recoverable messages are delayed until we've cleanly
+ * shut down the workers.
+ * 
+ * Unrecoverable errors are master-side errors that may affect MPI
+ * communication, meaning we cannot count on being able to reach the
+ * workers and shut them down. Unrecoverable errors result in immediate
+ * p7_Fail()'s, which will cause MPI to shut down the worker processes
+ * uncleanly.
+ */
+static int
+mpi_master(ESL_GETOPTS *go, struct cfg_s *cfg)
+{
+  FILE            *ofp      = stdout;	         /* output file for results (default stdout)        */
+  FILE            *tblfp    = NULL;		 /* output stream for tabular per-seq (--tblout)    */
+  FILE            *domtblfp = NULL;	  	 /* output stream for tabular per-seq (--domtblout) */
+  FILE            *pfamtblfp= NULL;              /* output stream for pfam-style tabular output  (--pfamtblout) */
+  int              seqfmt   = eslSQFILE_UNKNOWN; /* format of seqfile                               */
+  P7_BG           *bg       = NULL;	         /* null model                                      */
+  ESL_SQFILE      *sqfp     = NULL;              /* open seqfile                                    */
+  P7_HMMFILE      *hfp      = NULL;		 /* open HMM database file                          */
+  ESL_ALPHABET    *abc      = NULL;              /* sequence alphabet                               */
+  P7_OPROFILE     *om       = NULL;		 /* target profile                                  */
+  ESL_STOPWATCH   *w        = NULL;              /* timing                                          */
+  ESL_SQ          *qsq      = NULL;		 /* query sequence                                  */
+  int              nquery   = 0;
+  int              textw;
+  int              status   = eslOK;
+  int              hstatus  = eslOK;
+  int              sstatus  = eslOK;
+  int              dest;
+
+  char            *mpi_buf  = NULL;              /* buffer used to pack/unpack structures */
+  int              mpi_size = 0;                 /* size of the allocated buffer */
+  BLOCK_LIST      *list     = NULL;
+  MSV_BLOCK        block;
+
+  int              i;
+  int              size;
+  MPI_Status       mpistatus;
+  char             errbuf[eslERRBUFSIZE];
+
+  w = esl_stopwatch_Create();
+
+  if (esl_opt_GetBoolean(go, "--notextw")) textw = 0;
+  else                                     textw = esl_opt_GetInteger(go, "--textw");
+
+  /* If caller declared an input format, decode it */
+  if (esl_opt_IsOn(go, "--qformat")) {
+    seqfmt = esl_sqio_EncodeFormat(esl_opt_GetString(go, "--qformat"));
+    if (seqfmt == eslSQFILE_UNKNOWN) mpi_failure("%s is not a recognized input sequence file format\n", esl_opt_GetString(go, "--qformat"));
+  }
+
+  /* Open the target profile database to get the sequence alphabet */
+  status = p7_hmmfile_OpenE(cfg->hmmfile, p7_HMMDBENV, &hfp, errbuf);
+  if      (status == eslENOTFOUND) mpi_failure("File existence/permissions problem in trying to open HMM file %s.\n%s\n", cfg->hmmfile, errbuf);
+  else if (status == eslEFORMAT)   mpi_failure("File format problem, trying to open HMM file %s.\n%s\n",                  cfg->hmmfile, errbuf);
+  else if (status != eslOK)        mpi_failure("Unexpected error %d in opening HMM file %s.\n%s\n",               status, cfg->hmmfile, errbuf);  
+  if (! hfp->is_pressed)           mpi_failure("Failed to open binary auxfiles for %s: use hmmpress first\n",             hfp->fname);
+  
+  hstatus = p7_oprofile_ReadMSV(hfp, &abc, &om);
+  if      (hstatus == eslEFORMAT)   mpi_failure("bad format, binary auxfiles, %s",            cfg->hmmfile);
+  else if (hstatus == eslEINCOMPAT) mpi_failure("HMM file %s contains different alphabets",   cfg->hmmfile);
+  else if (hstatus != eslOK)        mpi_failure("Unexpected error in reading HMMs from %s",   cfg->hmmfile); 
+
+  p7_oprofile_Destroy(om);
+  p7_hmmfile_Close(hfp);
+
+  /* Open the query sequence database */
+  status = esl_sqfile_OpenDigital(abc, cfg->seqfile, seqfmt, NULL, &sqfp);
+  if      (status == eslENOTFOUND) mpi_failure("Failed to open sequence file %s for reading\n",      cfg->seqfile);
+  else if (status == eslEFORMAT)   mpi_failure("Sequence file %s is empty or misformatted\n",        cfg->seqfile);
+  else if (status == eslEINVAL)    mpi_failure("Can't autodetect format of a stdin or .gz seqfile");
+  else if (status != eslOK)        mpi_failure("Unexpected error %d opening sequence file %s\n", status, cfg->seqfile);
+
+  /* Open the results output files */
+  if (esl_opt_IsOn(go, "-o")          && (ofp      = fopen(esl_opt_GetString(go, "-o"),          "w")) == NULL)
+    mpi_failure("Failed to open output file %s for writing\n",                 esl_opt_GetString(go, "-o"));
+  if (esl_opt_IsOn(go, "--tblout")    && (tblfp    = fopen(esl_opt_GetString(go, "--tblout"),    "w")) == NULL)
+    mpi_failure("Failed to open tabular per-seq output file %s for writing\n", esl_opt_GetString(go, "--tblfp"));
+  if (esl_opt_IsOn(go, "--domtblout") && (domtblfp = fopen(esl_opt_GetString(go, "--domtblout"), "w")) == NULL)  
+    mpi_failure("Failed to open tabular per-dom output file %s for writing\n", esl_opt_GetString(go, "--domtblfp"));
+  if (esl_opt_IsOn(go, "--pfamtblout") && (pfamtblfp = fopen(esl_opt_GetString(go, "--pfamtblout"), "w")) == NULL)
+    mpi_failure("Failed to open pfam-style tabular output file %s for writing\n", esl_opt_GetString(go, "--pfamtblout"));
+ 
+  ESL_ALLOC(list, sizeof(MSV_BLOCK));
+  list->complete = 0;
+  list->size     = 0;
+  list->current  = 0;
+  list->last     = 0;
+  list->blocks   = NULL;
+
+  output_header(ofp, go, cfg->hmmfile, cfg->seqfile);
+  qsq = esl_sq_CreateDigital(abc);
+  bg = p7_bg_Create(abc);
+
+  /* Outside loop: over each query sequence in <seqfile>. */
+  while ((sstatus = esl_sqio_Read(sqfp, qsq)) == eslOK)
+    {
+      P7_PIPELINE     *pli     = NULL;		/* processing pipeline                      */
+      P7_TOPHITS      *th      = NULL;        	/* top-scoring sequence hits                */
+
+      nquery++;
+
+      esl_stopwatch_Start(w);	                          
+
+      /* seqfile may need to be rewound (multiquery mode) */
+      if (nquery > 1) list->current = 0;
+
+      /* Open the target profile database */
+      status = p7_hmmfile_OpenE(cfg->hmmfile, p7_HMMDBENV, &hfp, NULL);
+      if (status != eslOK) mpi_failure("Unexpected error %d in opening hmm file %s.\n", status, cfg->hmmfile);  
+  
+      if (fprintf(ofp, "Query:       %s  [L=%ld]\n", qsq->name, (long) qsq->n) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+      if (qsq->acc[0]  != 0 && fprintf(ofp, "Accession:   %s\n", qsq->acc)     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+      if (qsq->desc[0] != 0 && fprintf(ofp, "Description: %s\n", qsq->desc)    < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+
+      /* Create processing pipeline and hit list */
+      th  = p7_tophits_Create(); 
+      pli = p7_pipeline_Create(go, 100, 100, FALSE, p7_SCAN_MODELS); /* M_hint = 100, L_hint = 100 are just dummies for now */
+      pli->hfp = hfp;  /* for two-stage input, pipeline needs <hfp> */
+
+      p7_pli_NewSeq(pli, qsq);
+
+      /* Main loop: */
+      while ((hstatus = next_block(hfp, list, &block)) == eslOK)
+	{
+	  if (MPI_Probe(MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &mpistatus) != 0) 
+	    mpi_failure("MPI error %d receiving message from %d\n", mpistatus.MPI_SOURCE);
+
+	  MPI_Get_count(&mpistatus, MPI_PACKED, &size);
+	  if (mpi_buf == NULL || size > mpi_size) {
+	    void *tmp;
+	    ESL_RALLOC(mpi_buf, tmp, sizeof(char) * size);
+	    mpi_size = size; 
+	  }
+
+	  dest = mpistatus.MPI_SOURCE;
+	  MPI_Recv(mpi_buf, size, MPI_PACKED, dest, mpistatus.MPI_TAG, MPI_COMM_WORLD, &mpistatus);
+
+	  if (mpistatus.MPI_TAG == HMMER_ERROR_TAG)
+	    mpi_failure("MPI client %d raised error:\n%s\n", dest, mpi_buf);
+	  if (mpistatus.MPI_TAG != HMMER_READY_TAG)
+	    mpi_failure("Unexpected tag %d from %d\n", mpistatus.MPI_TAG, dest);
+      
+	  MPI_Send(&block, 3, MPI_LONG_LONG_INT, dest, HMMER_BLOCK_TAG, MPI_COMM_WORLD);
+	}
+      switch(hstatus)
+	{
+	case eslEFORMAT:
+	  mpi_failure("bad file format in HMM file %s",              cfg->hmmfile);
+	  break;
+	case eslEINCOMPAT:
+	  mpi_failure("HMM file %s contains different alphabets",    cfg->hmmfile);
+	  break;
+	case eslEOF:
+	  /* do nothing */
+	  break;
+	default:
+	  mpi_failure("Unexpected error %d in reading HMMs from %s", hstatus, cfg->hmmfile); 
+	}
+
+      block.offset = 0;
+      block.length = 0;
+      block.count  = 0;
+
+      /* wait for all workers to finish up their work blocks */
+      for (i = 1; i < cfg->nproc; ++i)
+	{
+	  if (MPI_Probe(MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &mpistatus) != 0) 
+	    mpi_failure("MPI error %d receiving message from %d\n", mpistatus.MPI_SOURCE);
+
+	  MPI_Get_count(&mpistatus, MPI_PACKED, &size);
+	  if (mpi_buf == NULL || size > mpi_size) {
+	    void *tmp;
+	    ESL_RALLOC(mpi_buf, tmp, sizeof(char) * size);
+	    mpi_size = size; 
+	  }
+
+	  dest = mpistatus.MPI_SOURCE;
+	  MPI_Recv(mpi_buf, size, MPI_PACKED, dest, mpistatus.MPI_TAG, MPI_COMM_WORLD, &mpistatus);
+
+	  if (mpistatus.MPI_TAG == HMMER_ERROR_TAG)
+	    mpi_failure("MPI client %d raised error:\n%s\n", dest, mpi_buf);
+	  if (mpistatus.MPI_TAG != HMMER_READY_TAG)
+	    mpi_failure("Unexpected tag %d from %d\n", mpistatus.MPI_TAG, dest);
+	}
+
+      /* merge the results of the search results */
+      for (dest = 1; dest < cfg->nproc; ++dest)
+	{
+	  P7_PIPELINE     *mpi_pli   = NULL;
+	  P7_TOPHITS      *mpi_th    = NULL;
+
+	  /* send an empty block to signal the worker they are done */
+	  MPI_Send(&block, 3, MPI_LONG_LONG_INT, dest, HMMER_BLOCK_TAG, MPI_COMM_WORLD);
+
+	  /* wait for the results */
+	  if ((status = p7_tophits_MPIRecv(dest, HMMER_TOPHITS_TAG, MPI_COMM_WORLD, &mpi_buf, &mpi_size, &mpi_th)) != eslOK)
+	    mpi_failure("Unexpected error %d receiving tophits from %d", status, dest);
+
+	  if ((status = p7_pipeline_MPIRecv(dest, HMMER_PIPELINE_TAG, MPI_COMM_WORLD, &mpi_buf, &mpi_size, go, &mpi_pli)) != eslOK)
+	    mpi_failure("Unexpected error %d receiving pipeline from %d", status, dest);
+
+	  p7_tophits_Merge(th, mpi_th);
+	  p7_pipeline_Merge(pli, mpi_pli);
+
+	  p7_pipeline_Destroy(mpi_pli);
+	  p7_tophits_Destroy(mpi_th);
+	}
+
+      /* Print the results.  */
+      p7_tophits_SortBySortkey(th);
+      p7_tophits_Threshold(th, pli);
+      p7_tophits_Targets(ofp, th, pli, textw); fprintf(ofp, "\n\n");
+      p7_tophits_Domains(ofp, th, pli, textw); fprintf(ofp, "\n\n");
+
+      if (tblfp)     p7_tophits_TabularTargets(tblfp,    qsq->name, qsq->acc, th, pli, (nquery == 1));
+      if (domtblfp)  p7_tophits_TabularDomains(domtblfp, qsq->name, qsq->acc, th, pli, (nquery == 1));
+      if (pfamtblfp) p7_tophits_TabularXfam(pfamtblfp,   qsq->name, qsq->acc, th, pli);
+
+      esl_stopwatch_Stop(w);
+      p7_pli_Statistics(ofp, pli, w);
+      if (fprintf(ofp, "//\n") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed");
+
+      p7_hmmfile_Close(hfp);
+      p7_pipeline_Destroy(pli);
+      p7_tophits_Destroy(th);
+      esl_sq_Reuse(qsq);
+    }
+  if (sstatus == eslEFORMAT) 
+    mpi_failure("Parse failed (sequence file %s):\n%s\n", sqfp->filename, esl_sqfile_GetErrorBuf(sqfp));
+  else if (sstatus != eslEOF)     
+    mpi_failure("Unexpected error %d reading sequence file %s", sstatus, sqfp->filename);
+
+  /* monitor all the workers to make sure they have ended */
+  for (i = 1; i < cfg->nproc; ++i)
+    {
+      if (MPI_Probe(MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &mpistatus) != 0) 
+	mpi_failure("MPI error %d receiving message from %d\n", mpistatus.MPI_SOURCE);
+
+      MPI_Get_count(&mpistatus, MPI_PACKED, &size);
+      if (mpi_buf == NULL || size > mpi_size) {
+	void *tmp;
+	ESL_RALLOC(mpi_buf, tmp, sizeof(char) * size);
+	mpi_size = size; 
+      }
+
+      dest = mpistatus.MPI_SOURCE;
+      MPI_Recv(mpi_buf, size, MPI_PACKED, dest, mpistatus.MPI_TAG, MPI_COMM_WORLD, &mpistatus);
+
+      if (mpistatus.MPI_TAG == HMMER_ERROR_TAG)
+	mpi_failure("MPI client %d raised error:\n%s\n", dest, mpi_buf);
+      if (mpistatus.MPI_TAG != HMMER_TERMINATING_TAG)
+	mpi_failure("Unexpected tag %d from %d\n", mpistatus.MPI_TAG, dest);
+    }
+
+ /* Terminate outputs - any last words?
+   */
+  if (tblfp)    p7_tophits_TabularTail(tblfp,    "hmmscan", p7_SCAN_MODELS, cfg->seqfile, cfg->hmmfile, go);
+  if (domtblfp) p7_tophits_TabularTail(domtblfp, "hmmscan", p7_SCAN_MODELS, cfg->seqfile, cfg->hmmfile, go);
+  if (pfamtblfp)p7_tophits_TabularTail(pfamtblfp, "hmmscan", p7_SEARCH_SEQS, cfg->seqfile, cfg->hmmfile, go);
+  if (ofp)      { if (fprintf(ofp, "[ok]\n") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "write failed"); }
+
+  /* Cleanup - prepare for successful exit
+   */
+  free(list);
+  if (mpi_buf != NULL) free(mpi_buf);
+
+  p7_bg_Destroy(bg);
+  esl_sq_Destroy(qsq);
+  esl_stopwatch_Destroy(w);
+  esl_alphabet_Destroy(abc);
+  esl_sqfile_Close(sqfp);
+
+  if (ofp != stdout) fclose(ofp);
+  if (tblfp)         fclose(tblfp);
+  if (domtblfp)      fclose(domtblfp);
+  if (pfamtblfp)     fclose(pfamtblfp);
+
+  return eslOK;
+
+ ERROR:
+  return status;
+}
+
+
+static int
+mpi_worker(ESL_GETOPTS *go, struct cfg_s *cfg)
+{
+  int              seqfmt   = eslSQFILE_UNKNOWN; /* format of seqfile                               */
+  P7_BG           *bg       = NULL;	         /* null model                                      */
+  ESL_SQFILE      *sqfp     = NULL;              /* open seqfile                                    */
+  P7_HMMFILE      *hfp      = NULL;		 /* open HMM database file                          */
+  ESL_ALPHABET    *abc      = NULL;              /* sequence alphabet                               */
+  P7_OPROFILE     *om       = NULL;		 /* target profile                                  */
+  ESL_STOPWATCH   *w        = NULL;              /* timing                                          */
+  ESL_SQ          *qsq      = NULL;		 /* query sequence                                  */
+  int              status   = eslOK;
+  int              hstatus  = eslOK;
+  int              sstatus  = eslOK;
+
+  char            *mpi_buf  = NULL;              /* buffer used to pack/unpack structures */
+  int              mpi_size = 0;                 /* size of the allocated buffer */
+
+  MPI_Status       mpistatus;
+  char             errbuf[eslERRBUFSIZE];
+
+  w = esl_stopwatch_Create();
+
+  /* Open the target profile database to get the sequence alphabet */
+  status = p7_hmmfile_OpenE(cfg->hmmfile, p7_HMMDBENV, &hfp, errbuf);
+  if      (status == eslENOTFOUND) mpi_failure("File existence/permissions problem in trying to open HMM file %s.\n%s\n", cfg->hmmfile, errbuf);
+  else if (status == eslEFORMAT)   mpi_failure("File format problem in trying to open HMM file %s.\n%s\n",                cfg->hmmfile, errbuf);
+  else if (status != eslOK)        mpi_failure("Unexpected error %d in opening HMM file %s.\n%s\n",               status, cfg->hmmfile, errbuf);  
+  if (! hfp->is_pressed)           mpi_failure("Failed to open binary dbs for HMM file %s: use hmmpress first\n",         hfp->fname);
+
+  hstatus = p7_oprofile_ReadMSV(hfp, &abc, &om);
+  if      (hstatus == eslEFORMAT)   mpi_failure("bad file format in HMM file %s",             cfg->hmmfile);
+  else if (hstatus == eslEINCOMPAT) mpi_failure("HMM file %s contains different alphabets",   cfg->hmmfile);
+  else if (hstatus != eslOK)        mpi_failure("Unexpected error in reading HMMs from %s",   cfg->hmmfile); 
+
+  p7_oprofile_Destroy(om);
+  p7_hmmfile_Close(hfp);
+
+  /* Open the query sequence database */
+  status = esl_sqfile_OpenDigital(abc, cfg->seqfile, seqfmt, NULL, &sqfp);
+  if      (status == eslENOTFOUND) mpi_failure("Failed to open sequence file %s for reading\n",      cfg->seqfile);
+  else if (status == eslEFORMAT)   mpi_failure("Sequence file %s is empty or misformatted\n",        cfg->seqfile);
+  else if (status == eslEINVAL)    mpi_failure("Can't autodetect format of a stdin or .gz seqfile");
+  else if (status != eslOK)        mpi_failure("Unexpected error %d opening sequence file %s\n", status, cfg->seqfile);
+
+  qsq = esl_sq_CreateDigital(abc);
+  bg = p7_bg_Create(abc);
+
+  /* Outside loop: over each query sequence in <seqfile>. */
+  while ((sstatus = esl_sqio_Read(sqfp, qsq)) == eslOK)
+    {
+      P7_PIPELINE     *pli     = NULL;		/* processing pipeline                      */
+      P7_TOPHITS      *th      = NULL;        	/* top-scoring sequence hits                */
+
+      MSV_BLOCK        block;
+
+      esl_stopwatch_Start(w);
+
+      status = 0;
+      MPI_Send(&status, 1, MPI_INT, 0, HMMER_READY_TAG, MPI_COMM_WORLD);
+
+      /* Open the target profile database */
+      status = p7_hmmfile_OpenE(cfg->hmmfile, p7_HMMDBENV, &hfp, NULL);
+      if (status != eslOK) mpi_failure("Unexpected error %d in opening hmm file %s.\n", status, cfg->hmmfile);  
+  
+      /* Create processing pipeline and hit list */
+      th  = p7_tophits_Create(); 
+      pli = p7_pipeline_Create(go, 100, 100, FALSE, p7_SCAN_MODELS); /* M_hint = 100, L_hint = 100 are just dummies for now */
+      pli->hfp = hfp;  /* for two-stage input, pipeline needs <hfp> */
+
+      p7_pli_NewSeq(pli, qsq);
+
+      /* receive a sequence block from the master */
+      MPI_Recv(&block, 3, MPI_LONG_LONG_INT, 0, HMMER_BLOCK_TAG, MPI_COMM_WORLD, &mpistatus);
+      while (block.count > 0)
+	{
+	  uint64_t length = 0;
+	  uint64_t count  = block.count;
+
+	  hstatus = p7_oprofile_Position(hfp, block.offset);
+	  if (hstatus != eslOK) mpi_failure("Cannot position optimized model to %ld\n", block.offset);
+
+	  while (count > 0 && (hstatus = p7_oprofile_ReadMSV(hfp, &abc, &om)) == eslOK)
+	    {
+	      length = om->eoff - block.offset + 1;
+
+	      p7_pli_NewModel(pli, om, bg);
+	      p7_bg_SetLength(bg, qsq->n);
+	      p7_oprofile_ReconfigLength(om, qsq->n);
+	      
+	      p7_Pipeline(pli, om, bg, qsq, NULL, th);
+	      
+	      p7_oprofile_Destroy(om);
+	      p7_pipeline_Reuse(pli);
+
+	      --count;
+	    }
+
+	  /* check the status of reading the hmm */
+
+	  /* lets do a little bit of sanity checking here to make sure the blocks are the same */
+	  if (count > 0)              
+	    {
+	      switch(hstatus)
+		{
+		case eslEFORMAT:
+		  mpi_failure("bad file format in HMM file %s",              cfg->hmmfile);
+		  break;
+		case eslEINCOMPAT:
+		  mpi_failure("HMM file %s contains different alphabets",    cfg->hmmfile);
+		  break;
+		case eslOK:
+		case eslEOF:
+		  mpi_failure("Block count mismatch - expected %ld found %ld at offset %ld\n", block.count, block.count-count, block.offset);
+		  break;
+		default:
+		  mpi_failure("Unexpected error %d in reading HMMs from %s", hstatus, cfg->hmmfile); 
+		}
+	    }
+	  if (block.length != length) 
+	    mpi_failure("Block length mismatch - expected %ld found %ld at offset %ld\n", block.length, length, block.offset);
+
+	  /* inform the master we need another block of sequences */
+	  status = 0;
+	  MPI_Send(&status, 1, MPI_INT, 0, HMMER_READY_TAG, MPI_COMM_WORLD);
+
+	  /* wait for the next block of sequences */
+	  MPI_Recv(&block, 3, MPI_LONG_LONG_INT, 0, HMMER_BLOCK_TAG, MPI_COMM_WORLD, &mpistatus);
+	}
+
+      esl_stopwatch_Stop(w);
+
+      /* Send the top hits back to the master. */
+      p7_tophits_MPISend(th, 0, HMMER_TOPHITS_TAG, MPI_COMM_WORLD,  &mpi_buf, &mpi_size);
+      p7_pipeline_MPISend(pli, 0, HMMER_PIPELINE_TAG, MPI_COMM_WORLD,  &mpi_buf, &mpi_size);
+
+      p7_hmmfile_Close(hfp);
+      p7_pipeline_Destroy(pli);
+      p7_tophits_Destroy(th);
+      esl_sq_Reuse(qsq);
+    } /* end outer loop over query HMMs */
+  if (sstatus == eslEFORMAT) 
+    mpi_failure("Parse failed (sequence file %s):\n%s\n", sqfp->filename, esl_sqfile_GetErrorBuf(sqfp));
+  else if (sstatus != eslEOF)
+    mpi_failure("Unexpected error %d reading sequence file %s", sstatus, sqfp->filename);
+
+  status = 0;
+  MPI_Send(&status, 1, MPI_INT, 0, HMMER_TERMINATING_TAG, MPI_COMM_WORLD);
+
+  if (mpi_buf != NULL) free(mpi_buf);
+
+  p7_bg_Destroy(bg);
+
+  esl_sq_Destroy(qsq);
+  esl_stopwatch_Destroy(w);
+  esl_alphabet_Destroy(abc);
+  esl_sqfile_Close(sqfp);
+
+  return eslOK;
+}
+#endif /*HMMER_MPI*/
+
+static int
+serial_loop(WORKER_INFO *info, P7_HMMFILE *hfp)
+{
+  int            status;
+
+  P7_OPROFILE   *om;
+  ESL_ALPHABET  *abc = NULL;
+  /* Main loop: */
+  while ((status = p7_oprofile_ReadMSV(hfp, &abc, &om)) == eslOK)
+    {
+      p7_pli_NewModel(info->pli, om, info->bg);
+      p7_bg_SetLength(info->bg, info->qsq->n);
+      p7_oprofile_ReconfigLength(om, info->qsq->n);
+
+      status = p7_Pipeline(info->pli, om, info->bg, info->qsq, NULL, info->th);
+      if (status == eslEINVAL) p7_Fail(info->pli->errbuf);
+
+      p7_oprofile_Destroy(om);
+      p7_pipeline_Reuse(info->pli);
+    }
+
+  esl_alphabet_Destroy(abc);
+
+  return status;
+}
+
+#ifdef HMMER_THREADS
+static int
+thread_loop(ESL_THREADS *obj, ESL_WORK_QUEUE *queue, P7_HMMFILE *hfp)
+{
+  int  status   = eslOK;
+  int  sstatus  = eslOK;
+  int  eofCount = 0;
+  P7_OM_BLOCK   *block;
+  ESL_ALPHABET  *abc = NULL;
+  void          *newBlock;
+
+  esl_workqueue_Reset(queue);
+  esl_threads_WaitForStart(obj);
+
+  status = esl_workqueue_ReaderUpdate(queue, NULL, &newBlock);
+  if (status != eslOK) esl_fatal("Work queue reader failed");
+      
+  /* Main loop: */
+  while (sstatus == eslOK)
+    {
+      block = (P7_OM_BLOCK *) newBlock;
+      sstatus = p7_oprofile_ReadBlockMSV(hfp, &abc, block);
+      if (sstatus == eslEOF)
+	{
+	  if (eofCount < esl_threads_GetWorkerCount(obj)) sstatus = eslOK;
+	  ++eofCount;
+	}
+	  
+      if (sstatus == eslOK)
+	{
+	  status = esl_workqueue_ReaderUpdate(queue, block, &newBlock);
+	  if (status != eslOK) esl_fatal("Work queue reader failed");
+	}
+    }
+
+  status = esl_workqueue_ReaderUpdate(queue, block, NULL);
+  if (status != eslOK) esl_fatal("Work queue reader failed");
+
+  if (sstatus == eslEOF)
+    {
+      /* wait for all the threads to complete */
+      esl_threads_WaitForFinish(obj);
+      esl_workqueue_Complete(queue);  
+    }
+  
+  esl_alphabet_Destroy(abc);
+  return sstatus;
+}
+
+static void 
+pipeline_thread(void *arg)
+{
+  int i;
+  int status;
+  int workeridx;
+  WORKER_INFO   *info;
+  ESL_THREADS   *obj;
+  P7_OM_BLOCK   *block;
+  void          *newBlock;
+  
+  impl_Init();
+
+  obj = (ESL_THREADS *) arg;
+  esl_threads_Started(obj, &workeridx);
+
+  info = (WORKER_INFO *) esl_threads_GetData(obj, workeridx);
+
+  status = esl_workqueue_WorkerUpdate(info->queue, NULL, &newBlock);
+  if (status != eslOK) esl_fatal("Work queue worker failed");
+
+  /* loop until all blocks have been processed */
+  block = (P7_OM_BLOCK *) newBlock;
+  while (block->count > 0)
+  {
+      /* Main loop: */
+    for (i = 0; i < block->count; ++i)
+    {
+      P7_OPROFILE *om = block->list[i];
+
+      p7_pli_NewModel(info->pli, om, info->bg);
+      p7_bg_SetLength(info->bg, info->qsq->n);
+      p7_oprofile_ReconfigLength(om, info->qsq->n);
+
+      status = p7_Pipeline(info->pli, om, info->bg, info->qsq, NULL, info->th);
+      if (status == eslEINVAL) p7_Fail(info->pli->errbuf);
+
+      p7_oprofile_Destroy(om);
+      p7_pipeline_Reuse(info->pli);
+
+      block->list[i] = NULL;
+    }
+
+    status = esl_workqueue_WorkerUpdate(info->queue, block, &newBlock);
+    if (status != eslOK) esl_fatal("Work queue worker failed");
+
+    block = (P7_OM_BLOCK *) newBlock;
+  }
+
+  status = esl_workqueue_WorkerUpdate(info->queue, block, NULL);
+  if (status != eslOK) esl_fatal("Work queue worker failed");
+
+  esl_threads_Finished(obj, workeridx);
+  return;
+}
+#endif   /* HMMER_THREADS */
+
+
+
diff -Nur hmmer-3.3.orig/src/p7_hmmfile.c hmmer-3.3/src/p7_hmmfile.c
--- hmmer-3.3.orig/src/p7_hmmfile.c	2019-11-18 14:23:12.000000000 +0100
+++ hmmer-3.3/src/p7_hmmfile.c	2019-12-06 15:39:25.120539279 +0100
@@ -497,6 +497,43 @@
   free(hfp);
 }
 
+/* Function:  p7_hmmfile_Reset()
+ *
+ * Purpose:   Reset internal state for an open HMM file <hfp> so it can be used again.
+ *
+ * Returns:   <eslOK> on success, <eslFAIL> otherwise
+ */
+int 
+p7_hmmfile_Reset(char* env, P7_HMMFILE *hfp, char *errbuf)
+{
+  int status;
+
+  if (hfp == NULL) return eslOK;
+ 
+#ifdef HAVE_POPEN /* gzip functionality, need to reopen */
+  if (hfp->do_gzip && hfp->f != NULL) {
+    p7_hmmfile_Close(hfp);
+    return p7_hmmfile_OpenE(hfp->fname, env, &hfp, NULL);
+  }
+#endif
+
+  hfp->errbuf[0] = '\0';
+
+  if (hfp->f     != NULL && fseeko(hfp->f,   0, SEEK_SET) != 0) ESL_EXCEPTION(eslESYS, "fseek failed");
+  if (hfp->ffp   != NULL && fseeko(hfp->ffp, 0, SEEK_SET) != 0) ESL_EXCEPTION(eslESYS, "fseek failed");
+  if (hfp->pfp   != NULL && fseeko(hfp->pfp, 0, SEEK_SET) != 0) ESL_EXCEPTION(eslESYS, "fseek failed");
+
+  if (hfp->ssi != NULL) {
+    esl_ssi_Reset(hfp->ssi);
+  }
+
+  if (hfp->efp != NULL) {
+    esl_fileparser_Reset(hfp->efp);
+  }
+
+  return eslOK;
+}
+
 #ifdef HMMER_THREADS
 /* Function:  p7_hmmfile_CreateLock()
  *
diff -Nur hmmer-3.3.orig/src/p7_hmmfile.c.orig hmmer-3.3/src/p7_hmmfile.c.orig
--- hmmer-3.3.orig/src/p7_hmmfile.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ hmmer-3.3/src/p7_hmmfile.c.orig	2019-11-18 14:23:12.000000000 +0100
@@ -0,0 +1,2572 @@
+/* Input/output of HMMs.
+ * 
+ * Contents:
+ *     1. The P7_HMMFILE object for reading HMMs
+ *     2. Writing HMMER3 HMM files.
+ *     3. API for reading HMM files in various formats.
+ *     4. Private, specific profile HMM file format parsers.
+ *     5. Other private functions involved in i/o.
+ *     6. Benchmark driver.
+ *     7. Unit tests.
+ *     8. Test driver.
+ *     9. Example.
+ */
+#include "p7_config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#ifdef HMMER_THREADS
+#include <pthread.h>
+#endif
+
+#include "easel.h"
+#include "esl_alphabet.h"
+#include "esl_ssi.h"     /* this gives us esl_byteswap */
+#include "esl_vectorops.h"   /* gives us esl_vec_FCopy()   */
+
+#include "hmmer.h"
+
+/* Magic numbers identifying binary formats.
+ * Do not change the old magics! Necessary for backwards compatibility.
+ */
+#if 0 /* temporarily remove all the magic; write backwards compat stuff later */
+static uint32_t  v10magic = 0xe8ededb1; /* v1.0 binary: "hmm1" + 0x80808080 */
+static uint32_t  v10swap  = 0xb1edede8; /* byteswapped v1.0                 */
+static uint32_t  v11magic = 0xe8ededb2; /* v1.1 binary: "hmm2" + 0x80808080 */
+static uint32_t  v11swap  = 0xb2edede8; /* byteswapped v1.1                 */
+static uint32_t  v17magic = 0xe8ededb3; /* v1.7 binary: "hmm3" + 0x80808080 */
+static uint32_t  v17swap  = 0xb3edede8; /* byteswapped v1.7                 */
+static uint32_t  v19magic = 0xe8ededb4; /* V1.9 binary: "hmm4" + 0x80808080 */
+static uint32_t  v19swap  = 0xb4edede8; /* V1.9 binary, byteswapped         */ 
+static uint32_t  v20magic = 0xe8ededb5; /* V2.0 binary: "hmm5" + 0x80808080 */
+static uint32_t  v20swap  = 0xb5edede8; /* V2.0 binary, byteswapped         */
+#endif
+
+static uint32_t  v3a_magic = 0xe8ededb6; /* 3/a binary: "hmm6" + 0x80808080 */
+static uint32_t  v3b_magic = 0xe8ededb7; /* 3/b binary: "hmm7" + 0x80808080 */
+static uint32_t  v3c_magic = 0xe8ededb8; /* 3/c binary: "hmm8" + 0x80808080 */
+static uint32_t  v3d_magic = 0xe8ededb9; /* 3/d binary: "hmm9" + 0x80808080 */
+static uint32_t  v3e_magic = 0xe8ededb0; /* 3/e binary: "hmm0" + 0x80808080 */
+static uint32_t  v3f_magic = 0xe8ededba; /* 3/f binary: "hmma" + 0x80808080 */
+
+
+static int read_asc30hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm);
+static int read_bin30hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm);
+static int read_asc20hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm);
+
+static int   write_bin_string(FILE *fp, char *s);
+static int   read_bin_string (FILE *fp, char **ret_s);
+static float h2ascii2prob(char *s, float null);
+
+
+/*****************************************************************
+ * 1. The P7_HMMFILE object for reading HMMs.
+ *****************************************************************/
+
+/* Historical note:
+ * p7_hmmfile_Open() is deprecated;
+ * p7_hmmfile_OpenE() is the newer replacement, which includes
+ * better error reporting through a <errbuf>.
+ */
+
+static int open_engine(const char *filename, char *env, P7_HMMFILE **ret_hfp, int do_ascii_only, char *errbuf);
+
+
+/* Function:  p7_hmmfile_OpenE()
+ * Synopsis:  Open an HMM file <filename>. 
+ *
+ * Purpose:   Open an HMM file <filename>, and prepare to read the first
+ *            HMM from it.
+ *            
+ *            We look for <filename> relative to the current working
+ *            directory. Additionally, if we don't find it in the cwd
+ *            and <env> is non-NULL, we will look for <filename>
+ *            relative to one or more directories in a colon-delimited
+ *            list obtained from the environment variable <env>. For
+ *            example, if we had <setenv HMMERDB
+ *            /misc/db/Pfam:/misc/db/Rfam> in the environment, a
+ *            profile HMM application might pass "HMMERDB" as <env>.
+ *            
+ *            As a special case, if <filename> is "-", then HMMs will
+ *            be read from <stdin>. In this case, <env> has no effect.
+ *            
+ *            As another special case, if <filename> ends in a <.gz>
+ *            suffix, the file is assumed to be compressed by GNU
+ *            <gzip>, and it is opened for reading from a pipe with
+ *            <gunzip -dc>. This feature is only available on
+ *            POSIX-compliant systems that have a <popen()> call, and
+ *            <HAVE_POPEN> is defined by the configure script at
+ *            compile time. 
+ *            
+ * Args:      filename - HMM file to open; or "-" for <stdin>
+ *            env      - list of paths to look for <hmmfile> in, in 
+ *                       addition to current working dir; or <NULL>
+ *            ret_hfp  - RETURN: opened <P7_HMMFILE>.
+ *            errbuf   - error message buffer: <NULL>, or a ptr
+ *                       to <eslERRBUFSIZE> chars of allocated space.
+ *
+ * Returns:   <eslOK> on success, and the open <ESL_HMMFILE> is returned
+ *            in <*ret_hfp>.
+ *            
+ *            <eslENOTFOUND> if <filename> can't be opened for
+ *            reading, even after the list of directories in <env> (if
+ *            any) is checked.
+ *            
+ *            <eslEFORMAT> if <filename> is not in a recognized HMMER
+ *            HMM file format.
+ *            
+ *            On either type of error, if a non-NULL <errbuf> was provided,
+ *            a useful user error message is left in it.
+ *
+ * Throws:    <eslEMEM> on allocation failure.
+ */
+int
+p7_hmmfile_OpenE(const char *filename, char *env, P7_HMMFILE **ret_hfp, char *errbuf)
+{
+  return open_engine(filename, env, ret_hfp, FALSE, errbuf);
+}
+
+
+/* Function:  p7_hmmfile_Open()
+ * Synopsis:  Open an HMM file. (Deprecated version with less error handling)
+ *
+ * Purpose:   Same as <p7_hmmfile_OpenE()>, above, but without the <errbuf>.
+ *            This older version is now deprecated. Use <p7_hmmfile_OpenE()>.
+ *            
+ *            When we have squashed out all usage of legacy <p7_hmmfile_Open()>,
+ *            <OpenE()> will become <Open()>.
+ */
+int
+p7_hmmfile_Open(const char *filename, char *env, P7_HMMFILE **ret_hfp)
+{
+  return open_engine(filename, env, ret_hfp, FALSE, NULL);
+}
+
+/* Function:  p7_hmmfile_OpenENoDB()
+ * Synopsis:  Open only an HMM flatfile, even if pressed db exists.
+ *
+ * Purpose:   Same as <p7_hmmfile_OpenE()> except that if a pressed
+ *            database exists for <filename>, it is ignored. Only
+ *            <filename> itself is opened.
+ *            
+ *            hmmpress needs this call. Otherwise, it opens a press'ed
+ *            database that it may be about to overwrite.
+ */
+int
+p7_hmmfile_OpenENoDB(const char *filename, char *env, P7_HMMFILE **ret_hfp, char *errbuf)
+{
+  return open_engine(filename, env, ret_hfp, TRUE, errbuf);
+}
+
+
+
+/* Function:  p7_hmmfile_OpenNoDB()
+ * Synopsis:  Open only an HMM flatfile, even if pressed db exists. (Deprecated)
+ *
+ * Purpose:   Same as <p7_hmmfile_OpenENoDB()>, 
+ *            database exists for <filename>, it is ignored. Only
+ *            <filename> itself is opened.
+ *            
+ *            hmmpress needs this call. Otherwise, it opens a press'ed
+ *            database that it may be about to overwrite.
+ */
+int
+p7_hmmfile_OpenNoDB(const char *filename, char *env, P7_HMMFILE **ret_hfp)
+{
+  return open_engine(filename, env, ret_hfp, TRUE, NULL);
+}
+
+
+/* Function:  p7_hmmfile_OpenBuffer()
+ *
+ * Purpose:   Perparse a buffer containing an ascii HMM for parsing.
+ *            
+ *            As another special case, if <filename> ends in a <.gz>
+ *            suffix, the file is assumed to be compressed by GNU
+ *            <gzip>, and it is opened for reading from a pipe with
+ *            <gunzip -dc>. This feature is only available on
+ *            POSIX-compliant systems that have a <popen()> call, and
+ *            <HAVE_POPEN> is defined by the configure script at
+ *            compile time. 
+ *            
+ * Args:      filename - HMM file to open; or "-" for <stdin>
+ *            env      - list of paths to look for <hmmfile> in, in 
+ *                       addition to current working dir; or <NULL>
+ *            ret_hfp  - RETURN: opened <P7_HMMFILE>.
+ *
+ * Returns:   <eslOK> on success, and the open <ESL_HMMFILE> is returned
+ *            in <*ret_hfp>.
+ *            
+ *            <eslENOTFOUND> if <filename> can't be opened for
+ *            reading, even after the list of directories in <env> (if
+ *            any) is checked.
+ *            
+ *            <eslEFORMAT> if <filename> is not in a recognized HMMER
+ *            HMM file format.
+ *
+ * Throws:    <eslEMEM> on allocation failure.
+ */
+int
+p7_hmmfile_OpenBuffer(const char *buffer, int size, P7_HMMFILE **ret_hfp)
+{
+  P7_HMMFILE *hfp     = NULL;
+  int         status;
+  char       *tok;
+  int         toklen;
+
+  ESL_ALLOC(hfp, sizeof(P7_HMMFILE));
+  hfp->f            = NULL;
+  hfp->fname        = NULL;
+  hfp->do_gzip      = FALSE;
+  hfp->do_stdin     = FALSE;
+  hfp->newly_opened = TRUE;  /* well, it will be, real soon now */
+  hfp->is_pressed   = FALSE;
+#ifdef HMMER_THREADS
+  hfp->syncRead     = FALSE;
+#endif
+  hfp->parser       = NULL;
+  hfp->efp          = NULL;
+  hfp->ffp          = NULL;
+  hfp->pfp          = NULL;
+  hfp->ssi          = NULL;
+  hfp->errbuf[0]    = '\0';
+
+  if ((hfp->efp = esl_fileparser_CreateMapped(buffer, size))         == NULL)   { status = eslEMEM; goto ERROR; }
+  if ((status = esl_fileparser_SetCommentChar(hfp->efp, '#'))        != eslOK)  goto ERROR;
+  if ((status = esl_fileparser_GetToken(hfp->efp, &tok, &toklen))    != eslOK)  goto ERROR;
+
+  if      (strcmp("HMMER3/f", tok) == 0) { hfp->format = p7_HMMFILE_3f; hfp->parser = read_asc30hmm; }
+  else if (strcmp("HMMER3/e", tok) == 0) { hfp->format = p7_HMMFILE_3e; hfp->parser = read_asc30hmm; }
+  else if (strcmp("HMMER3/d", tok) == 0) { hfp->format = p7_HMMFILE_3d; hfp->parser = read_asc30hmm; }
+  else if (strcmp("HMMER3/c", tok) == 0) { hfp->format = p7_HMMFILE_3c; hfp->parser = read_asc30hmm; }
+  else if (strcmp("HMMER3/b", tok) == 0) { hfp->format = p7_HMMFILE_3b; hfp->parser = read_asc30hmm; }
+  else if (strcmp("HMMER3/a", tok) == 0) { hfp->format = p7_HMMFILE_3a; hfp->parser = read_asc30hmm; }
+  else if (strcmp("HMMER2.0", tok) == 0) { hfp->format = p7_HMMFILE_20; hfp->parser = read_asc20hmm; }
+
+  if (hfp->parser == NULL) { status = eslEFORMAT; goto ERROR; }
+
+  *ret_hfp = hfp;
+  return eslOK;
+
+ ERROR:
+  if (hfp     != NULL) p7_hmmfile_Close(hfp);
+  *ret_hfp = NULL;
+  if      (status == eslEMEM)       return status;
+  else if (status == eslENOTFOUND)  return status;
+  else                              return eslEFORMAT;
+}
+
+
+/* open_engine()
+ *
+ * Implements all of the file opening functions:
+ * <p7_hmmfile_Open()>, <p7_hmmfile_OpenE()>, <p7_hmmfile_OpenNoDB()>, 
+ * and <p7_OpenENoDB()>.
+ * See their comments above.
+ * 
+ * Only returns three types of errors: 
+ *    eslENOTFOUND - file (the HMM file) or program (gzip, for .gz files) not found
+ *    eslEFORMAT   - bad HMM file format (or format of associated file)           
+ *    eslEMEM      - allocation failure somewhere
+ * <errbuf>, if non-NULL, will contain a useful error message.             
+ *              
+ */
+static int 
+open_engine(const char *filename, char *env, P7_HMMFILE **ret_hfp, int do_ascii_only, char *errbuf)
+{
+  P7_HMMFILE *hfp      = NULL;
+  char       *envfile  = NULL;  /* full path to filename after using environment  */
+  char       *dbfile   = NULL;  /* constructed name of an index or binary db file */
+  char       *cmd      = NULL;  /* constructed gzip -dc pipe command              */
+  int         status;
+  int         n       = strlen(filename);
+  union { char c[4]; uint32_t n; } magic;
+  char       *tok;
+  int         toklen;
+
+  ESL_ALLOC(hfp, sizeof(P7_HMMFILE));
+  hfp->f            = NULL;
+  hfp->fname        = NULL;
+  hfp->do_gzip      = FALSE;
+  hfp->do_stdin     = FALSE;
+  hfp->newly_opened = TRUE;  /* well, it will be, real soon now */
+  hfp->is_pressed   = FALSE;
+#ifdef HMMER_THREADS
+  hfp->syncRead     = FALSE;
+#endif
+  hfp->parser       = NULL;
+  hfp->efp          = NULL;
+  hfp->ffp          = NULL;
+  hfp->pfp          = NULL;
+  hfp->ssi          = NULL;
+  hfp->errbuf[0]    = '\0';
+
+  /* 1. There's two special reading modes that have limited indexing
+   *    and optimization capability: reading from standard input, and 
+   *    reading a gzip'ped file. Once we've set one of these up and set
+   *    either the <do_stdin> or <do_gzip> flag, we won't try to open
+   *    any associated indexes or binary database files.
+   */
+  if (strcmp(filename, "-") == 0) /* "-" means read from stdin */
+    {
+      hfp->f        = stdin;
+      hfp->do_stdin = TRUE;
+      if ((status = esl_strdup("[STDIN]", -1, &(hfp->fname))) != eslOK)   ESL_XFAIL(status, errbuf, "esl_strdup failed; shouldn't happen");
+    }
+#ifdef HAVE_POPEN
+  else if (n > 3 && strcmp(filename+n-3, ".gz") == 0) /* a <*.gz> filename means read via gunzip pipe */
+  {
+    if (! esl_FileExists(filename))                                    ESL_XFAIL(eslENOTFOUND, errbuf, ".gz file %s not found or not readable", filename);
+    if ((status = esl_sprintf(&cmd, "gzip -dc %s", filename)) != eslOK) ESL_XFAIL(status,       errbuf, "when setting up .gz pipe: esl_sprintf() failed");
+    if ((hfp->f = popen(cmd, "r")) == NULL)                             ESL_XFAIL(eslENOTFOUND, errbuf, "gzip -dc %s failed; gzip not installed or not in PATH?", filename);
+    if ((status = esl_strdup(filename, n, &(hfp->fname))) != eslOK)     ESL_XFAIL(status,       errbuf, "esl_strdup() failed, shouldn't happen");
+    hfp->do_gzip  = TRUE;
+    free(cmd); cmd = NULL;
+  }
+#endif /*HAVE_POPEN: gzip mode */
+  
+  
+  /* 2. If <hfp->f> is still NULL, then we're in the usual situation
+   *    of looking for a file on disk. It may either be in the cwd, or
+   *    in one of the directories listed in the <env> string. Find it,
+   *    open it to <hfp->f>, and set <hfp->filename>. The
+   *    <hfp->filename> string will be used later to construct the
+   *    names of expected index and binary database files.
+   */
+  if (hfp->f == NULL) {
+    if ((hfp->f = fopen(filename, "r")) != NULL) {
+      if ((status = esl_strdup(filename, n, &(hfp->fname)))    != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed, shouldn't happen");
+    } else if (esl_FileEnvOpen(filename, env, &(hfp->f), &envfile) == eslOK) {
+      n = strlen(envfile);
+      if ((status = esl_strdup(envfile, n, &(hfp->fname)))     != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed, shouldn't happen");
+      free(envfile); envfile = NULL;
+    } else
+    { /* temporarily copy filename over to hfp->fname, even though we haven't opened anything: we'll next try to open <filename>.h3m  */
+      if ((status = esl_strdup(filename, n, &(hfp->fname)))    != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed, shouldn't happen");
+    }
+  }
+  /* <hfp->f> may *still* be NULL, if <filename> is a press'ed database and ASCII file is deleted */
+
+
+  /* 3. Look for the binary model file component of a press'ed HMM database.
+   * 
+   *    If <hfp->f> is still NULL, this is our last chance to find it. 
+   *    (The ASCII base file may have been deleted to save space, leaving
+   *    binary press'ed files.)
+   *    
+   * If we've been asked to open only an ASCII file -- because we're being
+   * called by hmmpress, for example! -- then don't do this.   
+   */
+  if (! do_ascii_only && ! hfp->do_stdin && ! hfp->do_gzip) {
+    FILE *tmpfp;
+    /* if we opened an ASCII file in the HMMERDB directory, hfp->fname contains fully qualified name of file including the path */
+    if ((status = esl_sprintf(&dbfile, "%s.h3m", hfp->fname) != eslOK)) ESL_XFAIL(status, errbuf, "esl_sprintf() failed; shouldn't happen");
+
+    if ((tmpfp = fopen(dbfile, "rb")) != NULL)
+    {
+      if (hfp->f != NULL) fclose(hfp->f); /* preferentially read the .h3m file, not the original */
+      hfp->f = tmpfp;
+      hfp->is_pressed = TRUE;
+      free(hfp->fname);
+      if ((status = esl_strdup(dbfile, -1, &(hfp->fname)))    != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed, shouldn't happen");
+    }
+    else if (hfp->f == NULL && esl_FileEnvOpen(dbfile, env, &(hfp->f), &envfile) == eslOK)
+    { /* found a binary-only press'ed db in one of the env directories. */
+      free(hfp->fname);
+      if ((status = esl_strdup(envfile, -1, &(hfp->fname)))    != eslOK) ESL_XFAIL(status, errbuf, "esl_strdup() failed; shouldn't happen");
+      hfp->is_pressed = TRUE;
+    }
+    free(dbfile); dbfile = NULL;
+  }
+
+  /* 4. <hfp->f> must now point to a valid model input stream: if not, we fail. 
+   */
+  if (hfp->f == NULL)  
+  {
+    if (env) ESL_XFAIL(eslENOTFOUND, errbuf, "HMM file %s not found (nor an .h3m binary of it); also looked in %s", filename, env);
+    else     ESL_XFAIL(eslENOTFOUND, errbuf, "HMM file %s not found (nor an .h3m binary of it)",                    filename);
+  }
+
+
+  /* 5. If we found and opened a binary model file .h3m, open the rest of 
+   *     the press'd model files. (this can't be true if do_ascii_only is set)
+   */
+  if (hfp->is_pressed) 
+  {
+  /* here we rely on the fact that the suffixes are .h3{mfpi}, to construct other names from .h3m file name !! */
+    n = strlen(hfp->fname);   /* so, n = '\0', n-1 = 'm'  */
+    esl_strdup(hfp->fname, n, &dbfile);
+
+    dbfile[n-1] = 'f';  /* the MSV filter part of the optimized profiles */
+    if ((hfp->ffp = fopen(dbfile, "rb")) == NULL) ESL_XFAIL(eslENOTFOUND, errbuf, "Opened %s, a pressed HMM file; but no .h3f file found", hfp->fname);
+
+    dbfile[n-1] = 'p';  /* the remainder of the optimized profiles */
+    if ((hfp->pfp = fopen(dbfile, "rb")) == NULL) ESL_XFAIL(eslENOTFOUND, errbuf, "Opened %s, a pressed HMM file; but no .h3p file found", hfp->fname);
+
+    dbfile[n-1] = 'i';  /* the SSI index for the .h3m file */
+    status = esl_ssi_Open(dbfile, &(hfp->ssi));
+    if      (status == eslENOTFOUND) ESL_XFAIL(eslENOTFOUND, errbuf, "Opened %s, a pressed HMM file; but no .h3i file found", hfp->fname);
+    else if (status == eslEFORMAT)   ESL_XFAIL(eslEFORMAT,   errbuf, "Opened %s, a pressed HMM file; but format of its .h3i file unrecognized", hfp->fname);
+    else if (status == eslERANGE)    ESL_XFAIL(eslEFORMAT,   errbuf, "Opened %s, a pressed HMM file; but its .h3i file is 64-bit and your system is 32-bit", hfp->fname);
+    else if (status != eslOK)        ESL_XFAIL(eslEFORMAT,   errbuf, "Opened %s, a pressed HMM file; but failed to open its .h3i file", hfp->fname);
+
+    free(dbfile); dbfile = NULL;
+  }
+  else
+  {
+    if ((status = esl_sprintf(&dbfile, "%s.ssi", hfp->fname)) != eslOK) ESL_XFAIL(status, errbuf, "esl_sprintf() failed");
+
+    status = esl_ssi_Open(dbfile, &(hfp->ssi)); /* not finding an SSI file is ok. we open it if we find it. */
+    if      (status == eslEFORMAT)   ESL_XFAIL(status, errbuf, "a %s.ssi file exists (an SSI index), but its SSI format is not recognized",     hfp->fname);
+    else if (status == eslERANGE)    ESL_XFAIL(status, errbuf, "a %s.ssi file exists (an SSI index), but is 64-bit, and your system is 32-bit", hfp->fname);
+    else if (status != eslOK && status != eslENOTFOUND) ESL_XFAIL(status, errbuf, "esl_ssi_Open() failed");
+    free(dbfile); dbfile = NULL;
+  }
+
+
+  /* 6. Check for binary file format. A pressed db is automatically binary: verify. */
+  if (! fread((char *) &(magic.n), sizeof(uint32_t), 1, hfp->f))  ESL_XFAIL(eslEFORMAT, errbuf, "File exists, but appears to be empty?");
+  if      (magic.n == v3a_magic) { hfp->format = p7_HMMFILE_3a; hfp->parser = read_bin30hmm; }
+  else if (magic.n == v3b_magic) { hfp->format = p7_HMMFILE_3b; hfp->parser = read_bin30hmm; }
+  else if (magic.n == v3c_magic) { hfp->format = p7_HMMFILE_3c; hfp->parser = read_bin30hmm; }
+  else if (magic.n == v3d_magic) { hfp->format = p7_HMMFILE_3d; hfp->parser = read_bin30hmm; }
+  else if (magic.n == v3e_magic) { hfp->format = p7_HMMFILE_3e; hfp->parser = read_bin30hmm; }
+  else if (magic.n == v3f_magic) { hfp->format = p7_HMMFILE_3f; hfp->parser = read_bin30hmm; }
+  else if (hfp->is_pressed) ESL_XFAIL(eslEFORMAT, errbuf, "Binary format tag in %s unrecognized\nCurrent H3 format is HMMER3/f. Previous H2/H3 formats also supported.", hfp->fname);
+
+  /* 7. Checks for ASCII file format */
+  if (hfp->parser == NULL)
+  {
+    /* Does the magic appear to be binary, yet we didn't recognize it? */
+    if (magic.n & 0x80000000) ESL_XFAIL(eslEFORMAT, errbuf, "Format tag appears binary, but unrecognized\nCurrent H3 format is HMMER3/f. Previous H2/H3 formats also supported.");
+
+    if ((hfp->efp = esl_fileparser_Create(hfp->f))                     == NULL)   ESL_XFAIL(eslEMEM, errbuf, "internal error in esl_fileparser_Create()");
+    if ((status = esl_fileparser_SetCommentChar(hfp->efp, '#'))        != eslOK)  ESL_XFAIL(status,  errbuf, "internal error in esl_fileparser_SetCommentChar()");
+    if ((status = esl_fileparser_NextLinePeeked(hfp->efp, magic.c, 4)) != eslOK)  ESL_XFAIL(status,  errbuf, "internal error in esl_fileparser_NextLinePeeked()");
+    if ((status = esl_fileparser_GetToken(hfp->efp, &tok, &toklen))    != eslOK)  ESL_XFAIL(status,  errbuf, "internal error in esl_fileparser_GetToken()");
+
+    if      (strcmp("HMMER3/f", tok) == 0) { hfp->format = p7_HMMFILE_3f; hfp->parser = read_asc30hmm; }
+    else if (strcmp("HMMER3/e", tok) == 0) { hfp->format = p7_HMMFILE_3e; hfp->parser = read_asc30hmm; }
+    else if (strcmp("HMMER3/d", tok) == 0) { hfp->format = p7_HMMFILE_3d; hfp->parser = read_asc30hmm; }
+    else if (strcmp("HMMER3/c", tok) == 0) { hfp->format = p7_HMMFILE_3c; hfp->parser = read_asc30hmm; }
+    else if (strcmp("HMMER3/b", tok) == 0) { hfp->format = p7_HMMFILE_3b; hfp->parser = read_asc30hmm; }
+    else if (strcmp("HMMER3/a", tok) == 0) { hfp->format = p7_HMMFILE_3a; hfp->parser = read_asc30hmm; }
+    else if (strcmp("HMMER2.0", tok) == 0) { hfp->format = p7_HMMFILE_20; hfp->parser = read_asc20hmm; }
+    else ESL_XFAIL(eslEFORMAT, errbuf, "Format tag is '%s': unrecognized.\nCurrent H3 format is 'HMMER3/f'. Previous H2/H3 formats also supported.", tok);
+  }
+
+  *ret_hfp = hfp;
+  return eslOK;
+
+ ERROR:
+  if (cmd     != NULL) free(cmd);
+  if (dbfile  != NULL) free(dbfile);
+  if (envfile != NULL) free(envfile);
+  if (hfp     != NULL) p7_hmmfile_Close(hfp);
+  *ret_hfp = NULL;
+  if      (status == eslEMEM)       return status;
+  else if (status == eslENOTFOUND)  return status;
+  else                              return eslEFORMAT;
+}
+
+/* Function:  p7_hmmfile_Close()
+ *
+ * Purpose:   Closes an open HMM file <hfp>.
+ *
+ * Returns:   (void)
+ */
+void
+p7_hmmfile_Close(P7_HMMFILE *hfp)
+{
+  if (hfp == NULL) return;
+
+#ifdef HAVE_POPEN /* gzip functionality */
+  if (hfp->do_gzip && hfp->f != NULL)    pclose(hfp->f);
+#endif
+  if (!hfp->do_gzip && !hfp->do_stdin && hfp->f != NULL) fclose(hfp->f);
+  if (hfp->ffp   != NULL) fclose(hfp->ffp);
+  if (hfp->pfp   != NULL) fclose(hfp->pfp);
+  if (hfp->fname != NULL) free(hfp->fname);
+  if (hfp->efp   != NULL) esl_fileparser_Destroy(hfp->efp);
+  if (hfp->ssi   != NULL) esl_ssi_Close(hfp->ssi);
+#ifdef HMMER_THREADS
+  if (hfp->syncRead)      pthread_mutex_destroy (&hfp->readMutex);
+#endif
+  free(hfp);
+}
+
+#ifdef HMMER_THREADS
+/* Function:  p7_hmmfile_CreateLock()
+ *
+ * Purpose:   Create a lock to synchronize readers
+ *
+ * Returns:   <eslOK> on success.
+ */
+int
+p7_hmmfile_CreateLock(P7_HMMFILE *hfp)
+{
+  int status;
+
+  if (hfp == NULL) return eslEINVAL;
+
+  /* make sure the lock is not created twice */
+  if (!hfp->syncRead)
+  {
+    hfp->syncRead = TRUE;
+    status = pthread_mutex_init(&hfp->readMutex, NULL);
+    if (status != 0) goto ERROR;
+  }
+
+  return eslOK;
+
+ ERROR:
+  hfp->syncRead = FALSE;
+  return eslFAIL;
+}
+#endif
+/*----------------- end, P7_HMMFILE object ----------------------*/
+
+
+
+/*****************************************************************
+ * 2. Writing HMMER3 HMM files.
+ *****************************************************************/
+static int multiline(FILE *fp, const char *pfx, char *s);
+static int multilineString(char **str, const char *pfx, char *s, int *offset);
+static int printprob(FILE *fp, int fieldwidth, float p);
+static int probToString(char **str , int fieldwidth, float p, int offset);
+
+/* Function:  p7_hmmfile_WriteASCII()
+ * Synopsis:  Write a HMMER3 ASCII save file.
+ *
+ * Purpose:   Write a profile HMM <hmm> in an ASCII save file format to
+ *            an open stream <fp>.
+ *
+ *            Legacy file formats in the 3.x release series are
+ *            supported by specifying the <format> code. Pass <-1> to
+ *            use the default current standard format; pass a valid
+ *            code such as <p7_HMMFILE_3a> to select a specific
+ *            format.
+ *
+ * Args:      fp     - open stream for writing
+ *            format - -1 for default format, or a 3.x format code like <p7_HMMFILE_3a>
+ *            hmm    - HMM to save
+ *
+ * Returns:   <eslOK> on success.
+ *
+ * Throws:    <eslEINVAL> if <format> isn't a valid 3.0 format code.
+ *            <eslEWRITE> on write error.
+ */
+int
+p7_hmmfile_WriteASCII(FILE *fp, int format, P7_HMM *hmm)
+{
+  int k, x;
+  int status;
+  
+
+  if (format == -1) format = p7_HMMFILE_3f;
+
+  if      (format == p7_HMMFILE_3f)  { if (fprintf(fp, "HMMER3/f [%s | %s]\n",                             HMMER_VERSION, HMMER_DATE) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");}
+  else if (format == p7_HMMFILE_3e)  { if (fprintf(fp, "HMMER3/e [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  else if (format == p7_HMMFILE_3d)  { if (fprintf(fp, "HMMER3/d [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  else if (format == p7_HMMFILE_3c)  { if (fprintf(fp, "HMMER3/c [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  else if (format == p7_HMMFILE_3b)  { if (fprintf(fp, "HMMER3/b [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  else if (format == p7_HMMFILE_3a)  { if (fprintf(fp, "HMMER3/a [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  else ESL_EXCEPTION(eslEINVAL, "invalid HMM file format code");
+  
+  if (fprintf(fp, "NAME  %s\n", hmm->name)                                                          < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (hmm->acc  && fprintf(fp, "ACC   %s\n", hmm->acc)                                              < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (hmm->desc && fprintf(fp, "DESC  %s\n", hmm->desc)                                             < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (fprintf(fp, "LENG  %d\n", hmm->M)                                                             < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (format >= p7_HMMFILE_3c && hmm->max_length > 0 && fprintf(fp, "MAXL  %d\n", hmm->max_length)  < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (fprintf(fp, "ALPH  %s\n", esl_abc_DecodeType(hmm->abc->type))                                 < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (fprintf(fp, "RF    %s\n", (hmm->flags & p7H_RF)    ? "yes" : "no")                            < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (format >= p7_HMMFILE_3f && fprintf(fp, "MM    %s\n", (hmm->flags & p7H_MMASK) ? "yes" : "no") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (format >= p7_HMMFILE_3e && fprintf(fp, "CONS  %s\n", (hmm->flags & p7H_CONS)  ? "yes" : "no") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (fprintf(fp, "CS    %s\n", (hmm->flags & p7H_CS)    ? "yes" : "no")                            < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (fprintf(fp, "MAP   %s\n", (hmm->flags & p7H_MAP)   ? "yes" : "no")                            < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (hmm->ctime    != NULL)   { if (           fprintf  (fp, "DATE  %s\n", hmm->ctime)        < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  if (hmm->comlog   != NULL)   { if ( (status = multiline(fp, "COM  ",      hmm->comlog)) != eslOK) return status; }
+  if (hmm->nseq     >  0)      { if (           fprintf  (fp, "NSEQ  %d\n", hmm->nseq)         < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  if (hmm->eff_nseq >= 0)      { if (           fprintf  (fp, "EFFN  %f\n", hmm->eff_nseq)     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  if (hmm->flags & p7H_CHKSUM) { if (           fprintf  (fp, "CKSUM %u\n", hmm->checksum)     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); } /* unsigned 32-bit */
+
+  if (hmm->abc->type == eslRNA || hmm->abc->type == eslDNA ) {
+    if ((hmm->flags & p7H_GA)  && fprintf(fp, "GA    %.2f\n", hmm->cutoff[p7_GA1]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    if ((hmm->flags & p7H_TC)  && fprintf(fp, "TC    %.2f\n", hmm->cutoff[p7_TC1]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    if ((hmm->flags & p7H_NC)  && fprintf(fp, "NC    %.2f\n", hmm->cutoff[p7_NC1]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  } else {
+    if ((hmm->flags & p7H_GA)  && fprintf(fp, "GA    %.2f %.2f\n", hmm->cutoff[p7_GA1], hmm->cutoff[p7_GA2]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    if ((hmm->flags & p7H_TC)  && fprintf(fp, "TC    %.2f %.2f\n", hmm->cutoff[p7_TC1], hmm->cutoff[p7_TC2]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    if ((hmm->flags & p7H_NC)  && fprintf(fp, "NC    %.2f %.2f\n", hmm->cutoff[p7_NC1], hmm->cutoff[p7_NC2]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  }
+  if (hmm->flags & p7H_STATS) {
+    if (format == p7_HMMFILE_3a)  {        /* reverse compatibility */
+      if (fprintf(fp, "STATS LOCAL     VLAMBDA %f\n", hmm->evparam[p7_MLAMBDA]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+      if (fprintf(fp, "STATS LOCAL         VMU %f\n", hmm->evparam[p7_MMU])     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+      if (fprintf(fp, "STATS LOCAL        FTAU %f\n", hmm->evparam[p7_FTAU])    < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    } else {        /* default stats lines */
+      if (fprintf(fp, "STATS LOCAL MSV      %8.4f %8.5f\n", hmm->evparam[p7_MMU],  hmm->evparam[p7_MLAMBDA]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+      if (fprintf(fp, "STATS LOCAL VITERBI  %8.4f %8.5f\n", hmm->evparam[p7_VMU],  hmm->evparam[p7_VLAMBDA]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+      if (fprintf(fp, "STATS LOCAL FORWARD  %8.4f %8.5f\n", hmm->evparam[p7_FTAU], hmm->evparam[p7_FLAMBDA]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    }
+  }
+
+  if (fprintf(fp, "HMM     ")                                         < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  for (x = 0; x < hmm->abc->K; x++) 
+    { if (fprintf(fp, "     %c   ", hmm->abc->sym[x])                 < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  if (fputc('\n', fp)                                                 < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (fprintf(fp, "        %8s %8s %8s %8s %8s %8s %8s\n",
+        "m->m", "m->i", "m->d", "i->m", "i->i", "d->m", "d->d") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (hmm->flags & p7H_COMPO) {
+    if (fprintf(fp, "  COMPO ") < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    for (x = 0; x < hmm->abc->K; x++) 
+      { if ( (status = printprob(fp, 8, hmm->compo[x])) != eslOK) return status; }
+    if (fputc('\n', fp)         < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  }
+
+  /* node 0 is special: insert emissions, and B-> transitions */
+  if (fputs("        ", fp) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  for (x = 0; x < hmm->abc->K;      x++) 
+    { if ( (status = printprob(fp, 8, hmm->ins[0][x])) != eslOK) return status; }  
+  if (fputc('\n', fp)       < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+
+  if (fputs("        ", fp) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  for (x = 0; x < p7H_NTRANSITIONS; x++) 
+    { if ( (status = printprob(fp, 8, hmm->t[0][x])) != eslOK) return status; }    
+  if (fputc('\n', fp)       < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  for (k = 1; k <= hmm->M; k++) {
+    /* Line 1: k; match emissions; optional map, RF, MM, CS */
+    if (fprintf(fp, " %6d ",  k) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    for (x = 0; x < hmm->abc->K; x++)
+    { if ( (status = printprob(fp, 8, hmm->mat[k][x])) != eslOK) return status; }
+
+    if (hmm->flags & p7H_MAP) { if (fprintf(fp, " %6d", hmm->map[k]) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+    else                      { if (fprintf(fp, " %6s", "-")         < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+
+    if (format >= p7_HMMFILE_3e) {
+      x = hmm->consensus[k];
+      if (format >= p7_HMMFILE_3f && (hmm->flags & p7H_MMASK) && hmm->mm[k] == 'm' )
+        x = tolower(hmm->abc->sym[hmm->abc->Kp-3]);
+      if (fprintf(fp, " %c",   (hmm->flags & p7H_CONS) ? x : '-') < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    }
+
+
+    if (hmm->rf && hmm->rf[k] == ' ') ESL_EXCEPTION_SYS(eslEWRITE, "input alignment contains an RF line with spaces");
+    if (fprintf(fp, " %c",   (hmm->flags & p7H_RF)    ? hmm->rf[k]        : '-') < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    if (format >= p7_HMMFILE_3f) { if (fprintf(fp, " %c",   (hmm->flags & p7H_MMASK) ? hmm->mm[k]       : '-') < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+    if (fprintf(fp, " %c\n", (hmm->flags & p7H_CS)    ? hmm->cs[k]        : '-') < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+
+    /* Line 2:   insert emissions */
+    if (fputs("        ", fp) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    for (x = 0; x < hmm->abc->K; x++)
+    { if ( (status = printprob(fp, 8, hmm->ins[k][x])) != eslOK) return status; }
+    /* Line 3:   transitions */
+    if (fputs("\n        ", fp) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+    for (x = 0; x < p7H_NTRANSITIONS; x++)
+    { if ( (status = printprob(fp, 8, hmm->t[k][x])) != eslOK) return status; }
+    if (fputc('\n', fp) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  }
+  if (fputs("//\n", fp) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  return eslOK;
+}
+
+
+/* Function:  p7_hmmfile_WriteToString()
+ * Synopsis:  Write a HMMER3 HMM to char.
+ *
+ * Purpose:   Write a profile HMM <hmm> in to string <ascii_hmm> in ASCII
+ *            format.
+ *
+ *            Should produce same output as p7_hmmfile_WriteASCII
+ *
+ *            Legacy file formats in the 3.x release series are
+ *            supported by specifying the <format> code. Pass <-1> to
+ *            use the default current standard format; pass a valid
+ *            code such as <p7_HMMFILE_3a> to select a specific
+ *            format.
+ *
+ *            Calling function is responsible for freeing the returned string.
+ *
+ * Args:      ascii_hmm - char pointer where the string will be allocated and set
+ *            format    - -1 for default format, or a 3.x format code like <p7_HMMFILE_3a>
+ *            hmm       - HMM to save
+ *
+ * Returns:   <eslOK> on success or <eslEWRITE> on error.
+ */
+int
+p7_hmmfile_WriteToString(char **ascii_hmm, int format, P7_HMM *hmm)
+{
+  int k, x;
+  int status;
+
+  int offset;
+  int coffset = 0;
+  /* These 3 chars and int are used in the size determiantion */
+  int size;
+  int n = 0;
+  char buff[100];
+  char *end   = NULL;
+  char *sptr;
+
+  char *ret_hmm;
+
+  if (format == -1) format = p7_HMMFILE_3f;
+
+  /* In this block of code, interogate the HMM to work out the amount of memory needed to write it out as an ASCII string */
+  /* The number in each row is the number of fixed chars, inlcuding the '\n' */
+
+  /* The header block containing the tag/value pairs */
+  size =  50 + strlen(HMMER_VERSION) +  strlen(HMMER_DATE);                                                 /* HMMER version text */
+  size += 7 + strlen(hmm->name);                                                                            /* NAME line */
+  size += (hmm->acc ?  ( 7 + strlen(hmm->acc)) : 0);                                                        /* ACC line, if present */
+  size += (hmm->desc ?  ( 7 + strlen(hmm->desc)) : 0);                                                      /* DESC line, if present */
+  size += 7 + sprintf(buff, "%d", hmm->M);                                                                  /*LENG tag, we determine size of field later */
+  size += ((format >= p7_HMMFILE_3c && hmm->max_length) ?  7  + sprintf(buff, "%d", hmm->max_length) : 0);  /*MAXL line, later formats only, optional */
+  size += 7 + strlen( esl_abc_DecodeType(hmm->abc->type));                                                  /*ALPH tag */
+  size += 10;                                                                                               /*RF tag, yes/no */
+  size += (format >= p7_HMMFILE_3f ?  10  : 0 );                                                            /*MM line, only later formats*/
+  size += (format >= p7_HMMFILE_3e ?  10  : 0 );                                                            /*CONS line, only later formats*/
+  size += 10;                                                                                               /*Consensus secondary structure lines */
+  size += 10;                                                                                               /*MAP line*/
+  size += (hmm->ctime != NULL ? (7 + strlen(hmm->ctime)) : 0);                                              /*DATE line*/
+
+  /* Complicated as it can cover multiple lines */
+  if(hmm->comlog != NULL){
+    /* Determine the number of COM lines by counting the number of '\n' */
+    sptr = hmm->comlog;
+    do {
+      n++; /* last line should not have \n, so count before to get count */
+      end = strchr(sptr, '\n');
+      sptr += (end - sptr) +1;
+    } while (end != NULL  && *sptr != '\0');
+    size += ((sprintf(buff, "%d", n) + 8) * n); /*length of all the COM tags*/
+    size += strlen(hmm->comlog);
+  }
+
+  size += (hmm->nseq  > 0 ? 7  + sprintf(buff, "%d", hmm->nseq) : 0);                                      /* NSEQ line */
+  size += (hmm->eff_nseq  >= 0 ? 7  + sprintf(buff, "%f", hmm->eff_nseq) : 0);                              /* EFFN line */
+  size += (hmm->flags & p7H_CHKSUM ? 7 + sprintf(buff, "%u", hmm->checksum) : 0);                           /*CKSUM line */
+
+  /* Thresholds section */
+  size += ((hmm->flags & p7H_GA) ? 8 + sprintf(buff, "%.2f", hmm->cutoff[p7_GA1])+sprintf(buff, "%.2f", hmm->cutoff[p7_GA2]) : 0);
+  size += ((hmm->flags & p7H_TC) ? 8 + sprintf(buff, "%.2f", hmm->cutoff[p7_TC1])+sprintf(buff, "%.2f", hmm->cutoff[p7_TC2]) : 0);
+  size += ((hmm->flags & p7H_NC) ? 8 + sprintf(buff, "%.2f", hmm->cutoff[p7_NC1])+sprintf(buff, "%.2f", hmm->cutoff[p7_NC2]) : 0);
+
+  /* E-value stats */
+  size += ((hmm->flags & p7H_STATS) ?
+             ((format == p7_HMMFILE_3a) ? ( 75 + sprintf(buff, "%f", hmm->evparam[p7_MLAMBDA]) +
+                                                 sprintf(buff, "%f", hmm->evparam[p7_MMU])     +
+                                                 sprintf(buff, "%f", hmm->evparam[p7_FTAU])) :
+                                          ( 75 + sprintf(buff, "%8.4f", hmm->evparam[p7_MMU])  + sprintf(buff, "%8.5f", hmm->evparam[p7_MLAMBDA]) +
+                                                 sprintf(buff, "%8.4f", hmm->evparam[p7_VMU])  + sprintf(buff, "%8.5f", hmm->evparam[p7_VLAMBDA]) +
+                                                 sprintf(buff, "%8.4f", hmm->evparam[p7_FTAU]) + sprintf(buff, "%8.5f", hmm->evparam[p7_FLAMBDA])))
+             : 0); /* No STATS */
+
+  /* Now on to the body of the HMM */
+  size += 9  + (hmm->abc->K * 9);                                   /* Alphabet labels */
+  size += 71;                                                       /* Transitions line labels */
+  size += ((hmm->flags & p7H_COMPO) ? 9 + (hmm->abc->K * 9) :  0);  /* Composition line */
+  /* node 0 */
+  size += 9 + (hmm->abc->K * 9);                                    /* Insert emissions */
+  size += 9 + ( p7H_NTRANSITIONS * 9);                              /* Transitions */
+
+  /* Matrix of probabilities */
+  size += (hmm->M * ( 9 + (hmm->abc->K * 9 ) + 7 + 8 ));        /* Line 1: k; match emissions; map (although optional just going to add it, RF, CS, MM) */
+  size += (hmm->M * ( 9 + (hmm->abc->K * 9 ))) ;                    /* Line 2:   insert emissions */
+  size += (hmm->M * ( 9 + (p7H_NTRANSITIONS * 9) ));                /* Line 3:   transitions */
+  size += 3;                                                        /* Final terminating line */
+
+  /* Now allocate the memory for the HMM string */
+  ret_hmm = malloc(sizeof(char) * (size));
+
+  /* Now added the HMM text to the string, remembering to offset the position */
+  /* If anything fails, return an eslEWRITE error */
+
+  /* Header block */
+  if      (format == p7_HMMFILE_3f)  { if ((offset = sprintf(ret_hmm, "HMMER3/f [%s | %s]\n",  HMMER_VERSION, HMMER_DATE))                              < 0) return eslEWRITE; }
+  else if (format == p7_HMMFILE_3e)  { if ((offset = sprintf(ret_hmm, "HMMER3/e [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE))   < 0) return eslEWRITE; }
+  else if (format == p7_HMMFILE_3d)  { if ((offset = sprintf(ret_hmm, "HMMER3/d [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE))   < 0) return eslEWRITE; }
+  else if (format == p7_HMMFILE_3c)  { if ((offset = sprintf(ret_hmm, "HMMER3/c [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE))    < 0) return eslEWRITE; }
+  else if (format == p7_HMMFILE_3b)  { if ((offset = sprintf(ret_hmm, "HMMER3/b [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE))    < 0) return eslEWRITE; }
+  else if (format == p7_HMMFILE_3a)  { if ((offset = sprintf(ret_hmm, "HMMER3/a [%s | %s; reverse compatibility mode]\n", HMMER_VERSION, HMMER_DATE))    < 0) return eslEWRITE; }
+  else return eslEINVAL;
+  coffset = offset;
+
+  if ((offset = sprintf(ret_hmm + coffset, "NAME  %s\n", hmm->name))                              < 0) return eslEWRITE;
+  coffset += offset;
+
+  if (hmm->acc){
+    if((offset = sprintf(ret_hmm + coffset, "ACC   %s\n", hmm->acc))                              < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if (hmm->desc){
+    if ((offset = sprintf(ret_hmm + coffset, "DESC  %s\n", hmm->desc))                            < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if ((offset = sprintf(ret_hmm + coffset, "LENG  %d\n", hmm->M))                                 < 0) return eslEWRITE;
+  coffset += offset;
+
+  if (format >= p7_HMMFILE_3c && hmm->max_length > 0){
+    if((offset = sprintf(ret_hmm + coffset, "MAXL  %d\n", hmm->max_length))                       < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if ((offset = sprintf(ret_hmm + coffset, "ALPH  %s\n", esl_abc_DecodeType(hmm->abc->type)))     < 0) return eslEWRITE;
+  coffset += offset;
+
+  if ((offset = sprintf(ret_hmm+coffset, "RF    %s\n", (hmm->flags & p7H_RF)    ? "yes" : "no"))  < 0) return eslEWRITE;
+  coffset += offset;
+
+  if ((format >= p7_HMMFILE_3f)){
+    if ((offset = sprintf(ret_hmm+coffset, "MM    %s\n", (hmm->flags & p7H_MMASK) ? "yes" : "no"))  < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if ((format >= p7_HMMFILE_3e)){
+    if((offset = sprintf(ret_hmm+coffset, "CONS  %s\n", (hmm->flags & p7H_CONS)  ? "yes" : "no")) < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if ((offset = sprintf(ret_hmm+coffset, "CS    %s\n", (hmm->flags & p7H_CS)    ? "yes" : "no"))  < 0) return eslEWRITE;
+  coffset += offset;
+
+  if ((offset = sprintf(ret_hmm+coffset, "MAP   %s\n", (hmm->flags & p7H_MAP)   ? "yes" : "no"))  < 0) return eslEWRITE;
+  coffset += offset;
+
+  if (hmm->ctime    != NULL){
+      if((offset = sprintf(ret_hmm + coffset, "DATE  %s\n", hmm->ctime))                          < 0) return eslEWRITE;
+      coffset += offset;
+  }
+
+  if (hmm->comlog   != NULL)   {
+    if ( (status = multilineString(&ret_hmm, "COM  ", hmm->comlog, &coffset)) != eslOK) return status; }
+
+
+  if (hmm->nseq   > 0){
+    if((offset = sprintf(ret_hmm + coffset, "NSEQ  %d\n", hmm->nseq))                            < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if (hmm->eff_nseq   >= 0){
+    if((offset = sprintf(ret_hmm + coffset, "EFFN  %f\n", hmm->eff_nseq))                        < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if (hmm->flags & p7H_CHKSUM) {
+    if ((offset = sprintf  (ret_hmm + coffset, "CKSUM %u\n", hmm->checksum))                     < 0) return eslEWRITE;
+    coffset += offset;
+  } /* unsigned 32-bit */
+
+
+  /* Thresholds */
+  if ((hmm->flags & p7H_GA)){
+    if(( offset = sprintf(ret_hmm + coffset , "GA    %.2f %.2f\n", hmm->cutoff[p7_GA1], hmm->cutoff[p7_GA2])) < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if ((hmm->flags & p7H_TC)){
+     if(( offset = sprintf(ret_hmm + coffset , "TC    %.2f %.2f\n", hmm->cutoff[p7_TC1], hmm->cutoff[p7_TC2])) < 0) return eslEWRITE;
+     coffset += offset;
+  }
+
+  if ((hmm->flags & p7H_NC)){
+     if(( offset = sprintf(ret_hmm + coffset , "NC    %.2f %.2f\n", hmm->cutoff[p7_NC1], hmm->cutoff[p7_NC2])) < 0) return eslEWRITE;
+     coffset += offset;
+  }
+
+
+  /* E-value stats */
+  if (hmm->flags & p7H_STATS) {
+    if (format == p7_HMMFILE_3a){
+      if ((offset =sprintf(ret_hmm + coffset, "STATS LOCAL     VLAMBDA %f\n", hmm->evparam[p7_MLAMBDA]))                               < 0) return eslEWRITE;
+      coffset += offset;
+      if ((offset =sprintf(ret_hmm + coffset, "STATS LOCAL         VMU %f\n", hmm->evparam[p7_MMU]))                                   < 0) return eslEWRITE;
+      coffset += offset;
+      if ((offset =sprintf(ret_hmm + coffset, "STATS LOCAL        FTAU %f\n", hmm->evparam[p7_FTAU]))                                  < 0) return eslEWRITE;
+      coffset += offset;
+    }else{
+      if ((offset =sprintf(ret_hmm + coffset, "STATS LOCAL MSV      %8.4f %8.5f\n", hmm->evparam[p7_MMU],  hmm->evparam[p7_MLAMBDA]))  < 0) return eslEWRITE;
+      coffset += offset;
+      if ((offset = sprintf(ret_hmm + coffset, "STATS LOCAL VITERBI  %8.4f %8.5f\n", hmm->evparam[p7_VMU],  hmm->evparam[p7_VLAMBDA])) < 0) return eslEWRITE;
+      coffset += offset;
+      if ((offset = sprintf(ret_hmm + coffset, "STATS LOCAL FORWARD  %8.4f %8.5f\n", hmm->evparam[p7_FTAU], hmm->evparam[p7_FLAMBDA])) < 0) return eslEWRITE;
+      coffset += offset;
+    }
+  }
+
+
+
+  /* HMM body */
+  if ((offset = sprintf(ret_hmm + coffset, "HMM     "))                         < 0) return eslEWRITE;
+  coffset += offset;
+
+  for (x = 0; x < hmm->abc->K; x++){
+    if ((offset = sprintf(ret_hmm + coffset, "     %c   ", hmm->abc->sym[x]))   < 0) return eslEWRITE;
+    coffset += offset;
+  }
+  if((offset = sprintf(ret_hmm + coffset, "\n"))                                < 0) return eslEWRITE;
+  coffset += offset;
+
+  if ((offset = sprintf(ret_hmm + coffset, "        %8s %8s %8s %8s %8s %8s %8s\n",
+         "m->m", "m->i", "m->d", "i->m", "i->i", "d->m", "d->d"))               < 0) return eslEWRITE;
+  coffset += offset;
+
+  if (hmm->flags & p7H_COMPO) {
+    if ((offset = sprintf(ret_hmm + coffset, "  COMPO ")) < 0) return eslEWRITE;
+      coffset += offset;
+      for (x = 0; x < hmm->abc->K; x++){
+        if ( (status = probToString(&ret_hmm, 8, hmm->compo[x], coffset)) != eslOK) return status;
+        coffset += 9;
+      }
+   if((offset = sprintf(ret_hmm + coffset, "\n"))                               < 0) return eslEWRITE;
+   coffset += offset;
+  }
+
+  /* node 0 is special: insert emissions, and B-> transitions */
+  if ((offset = sprintf(ret_hmm + coffset, "        "))                         < 0) return eslEWRITE;
+  coffset += offset;
+  for (x = 0; x < hmm->abc->K; x++){
+    if ( (status = probToString(&ret_hmm, 8, hmm->ins[0][x], coffset)) != eslOK) return status;
+    coffset += 9;
+  }
+
+  if((offset = sprintf(ret_hmm + coffset, "\n"))                                < 0) return eslEWRITE;
+  coffset += offset;
+
+  if ((offset = sprintf(ret_hmm + coffset, "        "))                         < 0) return eslEWRITE;
+  coffset += offset;
+  for (x = 0; x <  p7H_NTRANSITIONS; x++){
+    if ( (status = probToString(&ret_hmm, 8, hmm->t[0][x], coffset)) != eslOK)  return status;
+    coffset += 9;
+  }
+
+  if((offset = sprintf(ret_hmm + coffset, "\n"))                                < 0) return eslEWRITE;
+  coffset += offset;
+
+
+  for (k = 1; k <= hmm->M; k++) {
+    /* Line 1: k; match emissions; optional map, RF, CS */
+    if ((offset = sprintf(ret_hmm + coffset, " %6d ",  k))                    < 0) return eslEWRITE;
+    coffset += offset;
+
+    for (x = 0; x < hmm->abc->K; x++){
+      if ( (status = probToString(&ret_hmm, 8, hmm->mat[k][x], coffset)) != eslOK) return status;
+      coffset += 9;
+    }
+
+    if (hmm->flags & p7H_MAP) {
+      if ((offset = sprintf(ret_hmm + coffset, " %6d", hmm->map[k]))          < 0) return eslEWRITE;
+      coffset += offset;
+    } else {
+      if ((offset = sprintf(ret_hmm + coffset, " %6s", "-"))         < 0) return eslEWRITE;
+      coffset += offset;
+    }
+
+    if (format >= p7_HMMFILE_3e) {
+      if ((offset = sprintf(ret_hmm + coffset, " %c",  (hmm->flags & p7H_CONS)  ? hmm->consensus[k] : '-')) < 0) return eslEWRITE;
+      coffset += offset;
+    }
+
+    if ((offset = sprintf(ret_hmm + coffset, " %c",    (hmm->flags & p7H_RF)    ? hmm->rf[k]        : '-')) < 0) return eslEWRITE;
+    coffset += offset;
+
+    if (format >= p7_HMMFILE_3f) {
+      if ((offset = sprintf(ret_hmm + coffset, " %c",  (hmm->flags & p7H_MMASK) ? hmm->mm[k]        : '-')) < 0) return eslEWRITE;
+      coffset += offset;
+    }
+
+    if ((offset = sprintf(ret_hmm + coffset, " %c\n",  (hmm->flags & p7H_CS)    ? hmm->cs[k]        : '-')) < 0) return eslEWRITE;
+    coffset += offset;
+
+    /* Line 2:   insert emissions */
+    if ((offset = sprintf(ret_hmm + coffset, "        ")) < 0) return eslEWRITE;
+    coffset += offset;
+
+    for (x = 0; x < hmm->abc->K; x++){
+      if( (status = probToString(&ret_hmm, 8, hmm->ins[k][x], coffset)) != eslOK) return status;
+      coffset += 9; /*Fieldwidth + 1 for space*/
+    }
+
+    /* Line 3:   transitions */
+    if ((offset = sprintf(ret_hmm + coffset, "\n        ")) < 0) return eslEWRITE;
+    coffset += offset;
+
+    for (x = 0; x < p7H_NTRANSITIONS; x++){
+      if ( (status = probToString(&ret_hmm, 8, hmm->t[k][x], coffset)) != eslOK) return status;
+      coffset += 9;/*Fieldwidth + 1 for space*/
+    }
+    if ((offset = sprintf(ret_hmm + coffset, "\n")) < 0) return eslEWRITE;
+    coffset += offset;
+  }
+
+  if (sprintf(ret_hmm + coffset, "//\n") < 0) return eslEWRITE;
+  *ascii_hmm = ret_hmm;
+
+  return eslOK;
+}
+
+/* Function:  p7_hmmfile_WriteBinary()
+ * 
+ * Purpose:   Writes an HMM to a file in HMMER3 binary format.
+ *
+ *            Legacy binary file formats in the 3.x release series are
+ *            supported by specifying the <format> code. Pass <-1> to
+ *            use the default current standard format; pass a valid
+ *            code such as <p7_HMMFILE_3a> to select a specific
+ *            binary format.
+ *
+ * Returns:   <eslOK> on success.
+ *
+ * Throws:    <eslEINVAL> if <format> isn't a valid 3.0 format code.
+ *            <eslEWRITE> on write error.
+ */
+int
+p7_hmmfile_WriteBinary(FILE *fp, int format, P7_HMM *hmm)
+{
+  int k;
+  int status;
+
+  if (format == -1) format = p7_HMMFILE_3f;
+
+  /* Legacy: p7H_{ACC, DESC} flags used to be used to indicate
+   * whether optional acc, desc were present. Now we just use
+   * the <NULL> convention. The reason to use the flags was for
+   * saving binary files - we thought we needed to know whether
+   * the acc, desc were present in the binary file before trying
+   * to read them, and having <flags> as one of the first 
+   * data fields in the file solved that problem. It's not
+   * necessary - the {read,write}_bin_string() convention is fine.                      
+   * But write_bin_string() writes a 0 for length for a NULL string,
+   * whereas we weren't writing anything with the previous
+   * flag convention - so to maintain consistency with previous
+   * HMMER binary save files, we use the HMM flags fields here
+   * and in binary file reads. [xref J5/114]
+   * 
+   * If binary format is ever revised substantially - revisit this
+   * issue too - and remove the flags.
+   */
+  if (hmm->desc == NULL) hmm->flags &= ~p7H_DESC;  else hmm->flags |= p7H_DESC;
+  if (hmm->acc  == NULL) hmm->flags &= ~p7H_ACC;   else hmm->flags |= p7H_ACC;
+
+  /* ye olde magic number */
+  if      (format == p7_HMMFILE_3f) { if (fwrite((char *) &(v3f_magic), sizeof(uint32_t), 1, fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); }
+  else if (format == p7_HMMFILE_3e) { if (fwrite((char *) &(v3e_magic), sizeof(uint32_t), 1, fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); }
+  else if (format == p7_HMMFILE_3d) { if (fwrite((char *) &(v3d_magic), sizeof(uint32_t), 1, fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); }
+  else if (format == p7_HMMFILE_3c) { if (fwrite((char *) &(v3c_magic), sizeof(uint32_t), 1, fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); }
+  else if (format == p7_HMMFILE_3b) { if (fwrite((char *) &(v3b_magic), sizeof(uint32_t), 1, fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); }
+  else if (format == p7_HMMFILE_3a) { if (fwrite((char *) &(v3a_magic), sizeof(uint32_t), 1, fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); }
+  else ESL_EXCEPTION(eslEINVAL, "invalid HMM file format code");
+
+  /* info necessary for sizes of things
+   */
+  if (fwrite((char *) &(hmm->flags),      sizeof(int),  1,   fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); 
+  if (fwrite((char *) &(hmm->M),          sizeof(int),  1,   fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); 
+  if (fwrite((char *) &(hmm->abc->type),  sizeof(int),  1,   fp) != 1) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+
+  /* The core model probabilities
+   */
+  for (k = 1; k <= hmm->M; k++)  /* match emissions (0) 1..M */
+    if (fwrite((char *) hmm->mat[k], sizeof(float), hmm->abc->K, fp) != hmm->abc->K) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  for (k = 0; k <= hmm->M; k++)  /* insert emissions 0..M */
+    if (fwrite((char *) hmm->ins[k], sizeof(float), hmm->abc->K, fp) != hmm->abc->K) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  for (k = 0; k <= hmm->M; k++)  /* note: start from 0, to include B state */
+    if (fwrite((char *) hmm->t[k], sizeof(float), 7, fp)             != 7)           ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+
+  /* annotation section
+   */
+  if (                           (status = write_bin_string(fp, hmm->name))                   != eslOK)     return status;                  
+  if ((hmm->flags & p7H_ACC)  && (status = write_bin_string(fp, hmm->acc))                    != eslOK)     return status;
+  if ((hmm->flags & p7H_DESC) && (status = write_bin_string(fp, hmm->desc))                   != eslOK)     return status;
+  if ((hmm->flags & p7H_RF)   && (fwrite((char *) hmm->rf,        sizeof(char), hmm->M+2, fp) != hmm->M+2)) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); /* +2: 1..M and trailing \0 */
+  if ((hmm->flags & p7H_MMASK)&& (fwrite((char *) hmm->mm,        sizeof(char), hmm->M+2, fp) != hmm->M+2)) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); /* +2: 1..M and trailing \0 */
+  if ((hmm->flags & p7H_CONS) && (fwrite((char *) hmm->consensus, sizeof(char), hmm->M+2, fp) != hmm->M+2)) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed"); /* don't need to test for >=3e format; p7H_CONS flag suffices (didn't exist pre-3e) */
+  if ((hmm->flags & p7H_CS)   && (fwrite((char *) hmm->cs,        sizeof(char), hmm->M+2, fp) != hmm->M+2)) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  if ((hmm->flags & p7H_CA)   && (fwrite((char *) hmm->ca,        sizeof(char), hmm->M+2, fp) != hmm->M+2)) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  if ( (status = write_bin_string(fp, hmm->comlog))                                           != eslOK)     return status;                                          
+  if (                            fwrite((char *) &(hmm->nseq),       sizeof(int),    1,  fp) != 1)         ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  if (                            fwrite((char *) &(hmm->eff_nseq),   sizeof(float),  1,  fp) != 1)         ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  if (format >= p7_HMMFILE_3c &&  fwrite((char *) &(hmm->max_length), sizeof(int),    1,  fp) != 1)         ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  if ( (status = write_bin_string(fp, hmm->ctime))                                            != eslOK)     return status;
+  if ((hmm->flags & p7H_MAP)  && (fwrite((char *) hmm->map,       sizeof(int),  hmm->M+1, fp) != hmm->M+1)) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  if (                            fwrite((char *)&(hmm->checksum),sizeof(uint32_t),   1,  fp) != 1)         ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+
+  /* E-value parameters and Pfam cutoffs */
+  if (format == p7_HMMFILE_3a)
+  {  /* reverse compatibility; 3/a format stored LAMBDA, MU, TAU */
+    float oldparam[3];
+    oldparam[0] = hmm->evparam[p7_MLAMBDA];
+    oldparam[1] = hmm->evparam[p7_MMU];
+    oldparam[2] = hmm->evparam[p7_FTAU];
+    if (fwrite((char *) oldparam, sizeof(float), 3, fp) != 3) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  }
+  else
+  {        /* default stats values */
+    if (fwrite((char *) hmm->evparam, sizeof(float), p7_NEVPARAM, fp) != p7_NEVPARAM) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  }
+  if (fwrite((char *) hmm->cutoff,  sizeof(float), p7_NCUTOFFS, fp) != p7_NCUTOFFS) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  if ((hmm->flags & p7H_COMPO) && (fwrite((char *) hmm->compo, sizeof(float), hmm->abc->K, fp) != hmm->abc->K)) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+  
+  return eslOK;
+}
+/*----------------- end, save file output  ----------------------*/
+
+
+
+/*****************************************************************
+ * 3. API for reading profile HMM files in various formats.
+ *****************************************************************/
+
+/* Function:  p7_hmmfile_Read()
+ *
+ * Purpose:   Read the next HMM from open save file <hfp>, and
+ *            optionally return this newly allocated HMM in <opt_hmm>.
+ *            (The optional return is so that an application is
+ *            only interested in whether the file contains a valid
+ *            HMM or not -- for example, to verify that a file contains
+ *            only a single HMM instead of a database of them.)
+ *            
+ *            Caller may or may not already know what alphabet the HMM
+ *            is expected to be in.  A reference to the pointer to the
+ *            current alphabet is passed in <*ret_abc>. If the alphabet
+ *            is unknown, pass <*ret_abc = NULL>, and when the
+ *            new HMM is read, an appropriate new alphabet object is
+ *            allocated and passed back to the caller in <*ret_abc>.
+ *            If the alphabet is already known, <ret_abc> points to
+ *            that object ptr, and the new HMM's alphabet type is
+ *            verified to agree with it. This mechanism allows an
+ *            application to let the first HMM determine the alphabet
+ *            type for the application, while still keeping the
+ *            alphabet under the application's scope of control.
+ *            
+ * Returns:   <eslOK> on success, and the newly allocated HMM is
+ *            optionally returned via <opt_hmm>. Additionally, if
+ *            <ret_abc> pointed to <NULL>, it now points to a newly
+ *            allocated alphabet.
+ *
+ *            Returns <eslEOF> if no HMMs remain in the file; this may
+ *            indicate success or failure, depending on what the
+ *            caller is expecting.
+ *            
+ *            Returns <eslEFORMAT> on any format problems, including
+ *            premature end of data or bad magic at the start of a
+ *            binary file. An informative error message is left in
+ *            <hfp->errbuf>; the filename (fully qualified, if opened
+ *            in a directory specified by an <env> list) is in
+ *            <hfp->fname>; and if <hfp->efp> is non-<NULL>, the HMM
+ *            file is in an ASCII text format, and the caller may also
+ *            obtain the line number at which the format error was
+ *            detected, in <hfp->efp->linenumber>, and use it to
+ *            format informative output for a user.
+ *            
+ *            Returns <eslEINCOMPAT> if the caller passed a known
+ *            alphabet (a non-<NULL> <*ret_abc>), but the alphabet
+ *            of the HMM doesn't match this expectation.
+ *            
+ *            Upon any return that is not <eslOK>, <*opt_hmm> is
+ *            <NULL> and <*ret_abc> is left unchanged from what caller
+ *            passed it as.
+ *
+ * Throws:    <eslEMEM> upon an allocation error.
+ *            <eslESYS> on failure of other system calls, such
+ *            as file positioning functions (<fseeko()> or <ftello()>.
+ */
+int
+p7_hmmfile_Read(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc,  P7_HMM **opt_hmm)
+{
+  /* A call to SSI to remember file position may eventually go here.  */
+  return (*hfp->parser)(hfp, ret_abc, opt_hmm);
+}
+
+
+
+/* Function:  p7_hmmfile_PositionByKey()
+ * Synopsis:  Use SSI to reposition file to start of named HMM.
+ *
+ * Purpose:   Reposition <hfp> so tha next HMM we read will be the
+ *            one named (or accessioned) <key>.
+ *
+ * Returns:   <eslOK> on success.
+ * 
+ *            Returns <eslENOTFOUND> if <key> isn't found in the index for
+ *            <hfp>.
+ *            
+ *            Returns <eslEFORMAT> is something goes wrong trying to
+ *            read the index, indicating a file format problem in the
+ *            SSI file.
+ *            
+ *            In the event of either error, the state of <hfp> is left
+ *            unchanged.
+ *
+ * Throws:    <eslEMEM> on allocation failure, or <eslESYS> on system i/o
+ *            call failure, or <eslEINVAL> if <hfp> doesn't have an SSI 
+ *            index or is not a seekable stream. 
+ */
+int
+p7_hmmfile_PositionByKey(P7_HMMFILE *hfp, const char *key)
+{
+  uint16_t fh;
+  off_t    offset;
+  int      status;
+
+  if (hfp->ssi == NULL) ESL_EXCEPTION(eslEINVAL, "Need an open SSI index to call p7_hmmfile_PositionByKey()");
+  if ((status = esl_ssi_FindName(hfp->ssi, key, &fh, &offset, NULL, NULL)) != eslOK) return status;
+  if (fseeko(hfp->f, offset, SEEK_SET) != 0)    ESL_EXCEPTION(eslESYS, "fseek failed");
+
+  hfp->newly_opened = FALSE;  /* because we're poised on the magic number, and must read it */
+  return eslOK;
+}
+
+
+/* Function:  p7_hmmfile_Position()
+ * Synopsis:  Reposition file to start of named HMM.
+ *
+ * Purpose:   Reposition <hfp> so tha start of the requested HMM.
+ *
+ * Returns:   <eslOK> on success.
+ * 
+ *            In the event of either error, the state of <hfp> is left
+ *            unchanged.
+ *
+ * Throws:    <eslESYS> on system i/o call failure, or <eslEINVAL> if
+ *            <hfp> is not a seekable stream. 
+ */
+int
+p7_hmmfile_Position(P7_HMMFILE *hfp, const off_t offset)
+{
+  if (fseeko(hfp->f, offset, SEEK_SET) != 0)    ESL_EXCEPTION(eslESYS, "fseek failed");
+
+  hfp->newly_opened = FALSE;  /* because we're poised on the magic number, and must read it */
+  return eslOK;
+}
+/*------------------- end, input API ----------------------------*/
+
+
+
+/*****************************************************************
+ * 4.  Private, specific profile HMM file format parsers.
+ *****************************************************************/
+
+/* Parsing save files from HMMER 3.x
+ * All parsers follow the same API.
+ * 
+ * Returns <eslOK> on success, and if <opt_hmm> is non-NULL,
+ * <*opt_hmm> points at a newly allocated HMM.
+ *
+ * Additionally, if <*ret_abc> was NULL, then a new alphabet is
+ * allocated according to the alphabet type of this HMM, and returned
+ * thru <ret_abc>.  This allocation mechanism allows a main()
+ * application that doesn't yet know its alphabet to determine the
+ * alphabet when the first HMM is read, while also allowing an
+ * application to allocate its own alphabet and assure that the
+ * input HMMs are appropriate for that alphabet.
+ *             
+ * Returns <eslEOF> when no HMM remains in the file, indicating a
+ * normal end-of-file.
+ *
+ * Two types of "normal error" may happen, which the caller must check
+ * for. Returns <eslEFORMAT> on any save file format error, including
+ * bad magic (i.e. this is not a HMMER file at all). Returns
+ * <eslEINCOMPAT> if the expected alphabet (a non-<NULL> alphabet
+ * specified by <*ret_abc>) does not match the alphabet type of the
+ * HMM.
+ * 
+ * When these normal errors occur, the caller can construct its error
+ * message from:
+ *    <hfp->errbuf>:    contains an informative error message
+ *    <hfp->fname>:     name of the HMM file (or '-' if STDIN)
+ * and if <hfp->efp> is non-<NULL>, the HMM file is in ASCII text, 
+ * and the caller may also use:
+ *    <hfp->efp->linenumber>: line on which the parse error occurred.
+ *         
+ * Throws:     <eslEMEM> on allocation error.
+ *             <eslESYS> if a system i/o call fails.
+ *             In cases of error (including both thrown error and normal error), <*ret_abc>
+ *             is left in its original state as passed by the caller, and <*ret_hmm> is
+ *             returned <NULL>.
+ */
+static int
+read_asc30hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm)
+{
+  ESL_ALPHABET *abc  = NULL;
+  P7_HMM       *hmm  = NULL;
+  char         *tag  = NULL;
+  char         *tok1 = NULL;
+  char         *tok2 = NULL;
+  char         *tok3 = NULL;
+  char         *tok4 = NULL;
+  int           alphatype;
+  int           k,x;
+  off_t         offset = 0;
+  int           status;
+  uint32_t      statstracker = 0;
+
+  hfp->errbuf[0] = '\0';
+
+  if (hfp->newly_opened)
+    {
+      offset            = 0;
+      hfp->newly_opened = FALSE;
+    }
+  else
+    {
+      /* Record where this HMM starts on disk */
+      if ((! hfp->do_stdin) && (! hfp->do_gzip) && (offset = ftello(hfp->f)) < 0)   ESL_XEXCEPTION(eslESYS, "ftello() failed");
+
+      /* First line of file: "HMMER3/f". Allocate shell for HMM annotation information (we don't know K,M yet) */
+      if ((status = esl_fileparser_NextLine(hfp->efp))                   != eslOK)  goto ERROR;  /* EOF here is normal; could also be a thrown EMEM */
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tag, NULL)) != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "unexpected absence of tokens on data line");
+
+      if      (hfp->format == p7_HMMFILE_3f) { if (strcmp(tag, "HMMER3/f") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/f tag: bad format or not a HMMER save file?"); }
+      else if (hfp->format == p7_HMMFILE_3e) { if (strcmp(tag, "HMMER3/e") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/e tag: bad format or not a HMMER save file?"); }
+      else if (hfp->format == p7_HMMFILE_3d) { if (strcmp(tag, "HMMER3/d") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/d tag: bad format or not a HMMER save file?"); }
+      else if (hfp->format == p7_HMMFILE_3c) { if (strcmp(tag, "HMMER3/c") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/c tag: bad format or not a HMMER save file?"); }
+      else if (hfp->format == p7_HMMFILE_3b) { if (strcmp(tag, "HMMER3/b") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/b tag: bad format or not a HMMER save file?"); }
+      else if (hfp->format == p7_HMMFILE_3a) { if (strcmp(tag, "HMMER3/a") != 0)     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/a tag: bad format or not a HMMER save file?"); }
+      else                                                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No such HMM file format code: this shouldn't happen");
+    }
+
+  if ((hmm = p7_hmm_CreateShell())                                   == NULL)   ESL_XFAIL(eslEMEM,    hfp->errbuf, "allocation failure, HMM shell");
+  hmm->offset = offset;
+
+  /* Header section */
+  while ((status = esl_fileparser_NextLine(hfp->efp)) == eslOK)
+    {
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tag, NULL))     != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "Premature end of line");
+
+      if (strcmp(tag, "NAME") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No name found on NAME line");
+	p7_hmm_SetName(hmm, tok1);
+      } 
+
+      else if (strcmp(tag, "ACC") == 0)  {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No accession found on ACC line");
+	p7_hmm_SetAccession(hmm, tok1);
+      }  
+
+      else if (strcmp(tag, "DESC") == 0) {
+	if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1))      != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No description found on DESC line");
+	p7_hmm_SetDescription(hmm, tok1);
+      } 
+
+      else if (strcmp(tag, "LENG") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No model length found on LENG line");
+	if ((hmm->M = atoi(tok1))                                            == 0)     ESL_XFAIL(status,    hfp->errbuf, "Invalid model length %s on LENG line", tok1);
+      }  
+
+      else if (hfp->format >= p7_HMMFILE_3c && strcmp(tag, "MAXL") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No max length found on MAXL line");
+	if ((hmm->max_length = atoi(tok1))                                   == 0)     ESL_XFAIL(status,    hfp->errbuf, "Invalid max length %s on MAXL line", tok1);
+      }
+
+      else if (strcmp(tag, "ALPH") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No alphabet type found on ALPH");
+	if ((alphatype = esl_abc_EncodeType(tok1))                        == eslUNKNOWN) ESL_XFAIL(status,    hfp->errbuf, "Unrecognized alphabet type %s", tok1);
+	if (*ret_abc == NULL) {
+	  if ((abc = esl_alphabet_Create(alphatype))                        == NULL)    ESL_XFAIL(eslEMEM,   hfp->errbuf, "Failed to create alphabet");
+	} else {
+	  if ((*ret_abc)->type != alphatype)                                           ESL_XFAIL(eslEINCOMPAT,hfp->errbuf,"Alphabet type mismatch: was %s, but current HMM says %s", esl_abc_DecodeType( (*ret_abc)->type), tok1);
+	  abc = *ret_abc;
+	}
+      } 
+
+      else if (strcmp(tag, "RF") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,    hfp->errbuf, "No yes/no found for RF line");
+	if      (strcasecmp(tok1, "yes") == 0)
+	  hmm->flags |= p7H_RF;
+	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "RF header line must say yes/no, not %s", tok1);
+      } 
+
+      else if (strcmp(tag, "MM") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,    hfp->errbuf, "No yes/no found for MM line");
+	if      (strcasecmp(tok1, "yes") == 0)
+	  hmm->flags |= p7H_MMASK;
+	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "MM header line must say yes/no, not %s", tok1);
+      }
+
+
+      else if (strcmp(tag, "CONS") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No yes/no found for CONS line");
+	if (strcasecmp(tok1, "yes") == 0)
+	  hmm->flags |= p7H_CONS;
+	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "CONS header line must say yes/no, not %s", tok1);
+      } 
+
+      else if (strcmp(tag, "CS") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No yes/no found for CS line");
+	if (strcasecmp(tok1, "yes") == 0)
+	  hmm->flags |= p7H_CS;
+	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "CS header line must say yes/no, not %s", tok1);
+      } 
+
+      else if (strcmp(tag, "MAP") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No yes/no found for MAP line");
+	if      (strcasecmp(tok1, "yes") == 0)
+	  hmm->flags |= p7H_MAP;
+	else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "MAP header line must say yes/no, not %s", tok1);
+      } 
+
+      else if (strcmp(tag, "DATE") == 0) {
+	if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No date found on DATE line");
+	if (esl_strdup(tok1, -1, &(hmm->ctime))                               != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "strdup() failed to set date");
+      }
+
+      else if (strcmp(tag, "COM") == 0) {
+	/* just skip the first token; it's something like [1], numbering the command lines */
+	if ((status = esl_fileparser_GetTokenOnLine  (hfp->efp, &tok1, NULL)) != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No command number on COM line");
+	if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No command on COM line");
+	if (hmm->comlog == NULL) {
+	  if (esl_strdup(tok1, -1, &(hmm->comlog))                            != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strdup() failed");
+	} else {
+	  if (esl_strcat(&(hmm->comlog), -1, "\n", -1)                        != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strcat() failed");
+	  if (esl_strcat(&(hmm->comlog), -1, tok1,  -1)                       != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strcat() failed");
+	}
+      }
+      
+      else if (strcmp(tag, "NSEQ") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Nothing follows NSEQ tag");
+	if ((hmm->nseq = atoi(tok1)) == 0)                                               ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Invalid nseq on NSEQ line: should be integer, not %s", tok1);
+      }
+
+      else if (strcmp(tag, "EFFN") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Nothing follows EFFN tag");
+	if ((hmm->eff_nseq = atof(tok1)) <= 0.0f)                                        ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Invalid eff_nseq on EFFN line: should be a real number, not %s", tok1);
+      }
+
+      else if (strcmp(tag, "CKSUM") == 0) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Nothing follows CKSUM tag");
+	hmm->checksum = atoll(tok1); /* if atoi(), then you may truncate uint32_t checksums > 2^31-1 */
+	hmm->flags |= p7H_CHKSUM;
+      }
+
+      else if (strcmp(tag, "STATS") == 0) {
+	if (hfp->format >= p7_HMMFILE_3b)
+	  {
+	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* LOCAL */
+	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* MSV | VITERBI | FORWARD */
+	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok3, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* mu | tau */
+	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok4, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* lambda */
+	    if (strcasecmp(tok1, "LOCAL") == 0)
+	      {
+		if      (strcasecmp(tok2, "MSV")     == 0)  { hmm->evparam[p7_MMU]  = atof(tok3); hmm->evparam[p7_MLAMBDA] = atof(tok4); statstracker |= 0x1; }
+		else if (strcasecmp(tok2, "VITERBI") == 0)  { hmm->evparam[p7_VMU]  = atof(tok3); hmm->evparam[p7_VLAMBDA] = atof(tok4); statstracker |= 0x2; }
+		else if (strcasecmp(tok2, "FORWARD") == 0)  { hmm->evparam[p7_FTAU] = atof(tok3); hmm->evparam[p7_FLAMBDA] = atof(tok4); statstracker |= 0x4; }
+		else ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Failed to parse STATS, %s unrecognized as field 3", tok2);
+	      } else ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Failed to parse STATS, %s unrecognized as field 2", tok1);
+	  }
+	else if (hfp->format == p7_HMMFILE_3a) /* reverse compatibility with 30a */
+	  {
+	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* LOCAL */
+	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* VLAMBDA | VMU | FTAU */
+	    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok3, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on STATS line"); /* value */
+	    if (strcasecmp(tok1, "LOCAL") == 0)
+	      {
+		if      (strcasecmp(tok2, "VLAMBDA") == 0)  { hmm->evparam[p7_MLAMBDA] = hmm->evparam[p7_VLAMBDA] = hmm->evparam[p7_FLAMBDA] = atof(tok3);  statstracker |= 0x1; }
+		else if (strcasecmp(tok2, "VMU")     == 0)  {                            hmm->evparam[p7_MMU]     = hmm->evparam[p7_VMU]     = atof(tok3);  statstracker |= 0x2; }
+		else if (strcasecmp(tok2, "FTAU")    == 0)  {                                                       hmm->evparam[p7_FTAU]    = atof(tok3);  statstracker |= 0x4; }
+		else ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Failed to parse STATS, %s unrecognized as field 3", tok2);
+	      } else ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Failed to parse STATS, %s unrecognized as field 2", tok1);
+	  }
+      }
+
+      else if (strcmp(tag, "GA") == 0) {
+        if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on GA line");
+        hmm->cutoff[p7_GA1] = atof(tok1);
+        if ( (abc->type == eslDNA || abc->type == eslRNA) ) { //if DNA, there's no need for a 2nd value (domain GA)
+          hmm->cutoff[p7_GA2] = hmm->cutoff[p7_GA1];
+        } else {
+          if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on GA line");
+          hmm->cutoff[p7_GA2] = atof(tok2);
+        }
+        hmm->flags         |= p7H_GA;
+      }
+
+      else if (strcmp(tag, "TC") == 0) {
+        if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on TC line");
+        hmm->cutoff[p7_TC1] = atof(tok1);
+        if ( (abc->type == eslDNA || abc->type == eslRNA) ) { //if DNA, there's no need for a 2nd value (domain GA)
+          hmm->cutoff[p7_TC2] = hmm->cutoff[p7_TC1];
+        } else {
+          if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on TC line");
+          hmm->cutoff[p7_TC2] = atof(tok2);
+        }
+        hmm->flags         |= p7H_TC;
+      }
+
+      else if (strcmp(tag, "NC") == 0) {
+        if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on NC line");
+        hmm->cutoff[p7_NC1] = atof(tok1);
+        if ( (abc->type == eslDNA || abc->type == eslRNA) ) { //if DNA, there's no need for a 2nd value (domain GA)
+          hmm->cutoff[p7_NC2] = hmm->cutoff[p7_NC1];
+        } else {
+          if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on NC line");
+          hmm->cutoff[p7_NC2] = atof(tok2);
+        }
+        hmm->flags         |= p7H_NC;
+      }
+
+      else if (strcmp(tag, "HMM") == 0) 
+  break;
+    } /* end, loop over possible header tags */
+
+  if (status != eslOK) goto ERROR;
+
+  /* If we saw one STATS line, we need all 3. (True for both 3/a and 3/b formats) */
+  if      (statstracker == 0x7) hmm->flags |= p7H_STATS;
+  else if (statstracker != 0x0) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Missing one or more STATS parameter lines");
+
+  
+  /* Skip main model header lines; allocate body of HMM now that K,M are known */
+  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
+  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
+  if ((status = p7_hmm_CreateBody(hmm, hmm->M, abc))                          != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Failed to allocate body of the new HMM");
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))         != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
+
+  /* Optional model composition (filter null model) may immediately follow headers */
+  if (strcmp(tok1, "COMPO") == 0) {
+    for (x = 0; x < abc->K; x++)  {
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on COMPO line");
+      hmm->compo[x] = (*tok1 == '*' ? 0.0 : expf(-1.0 * atof(tok1)));
+    }
+    hmm->flags |= p7H_COMPO;
+    if ((status = esl_fileparser_NextLine(hfp->efp))                          != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data after COMPO line");  
+    if ((esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))                != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data after COMPO line");  
+  }
+
+  /* First two lines are node 0: insert emissions, then transitions from node 0 (begin) */
+
+  hmm->ins[0][0] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
+  for (x = 1; x < abc->K; x++) {
+    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on insert line, node 0: expected %d, got %d\n", abc->K, x);
+    hmm->ins[0][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
+  }
+  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model: no node 0 transition line");
+  for (x = 0; x < p7H_NTRANSITIONS; x++) {
+    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on begin (0) transition line");
+    hmm->t[0][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
+  }
+
+  /* The main model section. */
+  for (k = 1; k <= hmm->M; k++)
+    {
+
+      if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model section, at node %d (expected %d)", k, hmm->M);
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model section, at node %d (expected %d)", k, hmm->M);
+      if (atoi(tok1) != k)                                                               ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Expected match line to start with %d (of %d); saw %s", k, hmm->M, tok1);
+      
+      for (x = 0; x < abc->K; x++) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few probability fields on match line, node %d: expected %d, got %d\n", k, abc->K, x);
+	hmm->mat[k][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
+      }
+      
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing MAP field on match line for node %d: should at least be -", k);
+      if (hmm->flags & p7H_MAP) hmm->map[k] = atoi(tok1);
+
+      if (hfp->format >= p7_HMMFILE_3e) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing CONS field on match line for node %d: should at least be -", k);
+	if (hmm->flags & p7H_CONS) hmm->consensus[k] = *tok1;
+      }
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing RF field on match line for node %d: should at least be -",  k);
+      if (hmm->flags & p7H_RF) hmm->rf[k]   = *tok1;
+
+      if (hfp->format >= p7_HMMFILE_3f) {
+        if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing MM field on match line for node %d: should at least be -", k);
+        if (hmm->flags & p7H_MMASK) hmm->mm[k] = *tok1;
+      }
+
+
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing CS field on match line for node %d: should at least be -",  k);
+      if (hmm->flags & p7H_CS) hmm->cs[k]   = *tok1;
+
+      
+      if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model: no insert emission line, node %d", k);
+      for (x = 0; x < abc->K; x++) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few probability fields on insert line, node %d: expected %d, got %d\n", k, abc->K, x);
+	hmm->ins[k][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
+      }
+      if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model: no transition line, node %d", k);
+      for (x = 0; x < p7H_NTRANSITIONS; x++) {
+	if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few probability fields on transition line, node %d: expected %d, got %d\n", k, abc->K, x);
+	hmm->t[k][x] = (*tok1 == '*' ? 0.0 : expf(-1.0 *atof(tok1)));
+      }
+    }
+
+  /* The closing // */
+  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data: missing //?");
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))         != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data: missing //?");
+  if (strcmp(tok1, "//")                                                      != 0)      ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Expected closing //; found %s instead", tok1);
+
+  /* legacy issues */
+  if (hfp->format < p7_HMMFILE_3e && (status = p7_hmm_SetConsensus(hmm, NULL)) != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Failed to set consensus on legacy HMM format");
+
+  /* Finish up. */
+  if (hmm->flags & p7H_RF)   { hmm->rf[0]        = ' '; hmm->rf[hmm->M+1]        = '\0'; }
+  if (hmm->flags & p7H_MMASK){ hmm->mm[0]        = ' '; hmm->mm[hmm->M+1]        = '\0'; }
+  if (hmm->flags & p7H_CONS) { hmm->consensus[0] = ' '; hmm->consensus[hmm->M+1] = '\0'; }
+  if (hmm->flags & p7H_CS)   { hmm->cs[0]        = ' '; hmm->cs[hmm->M+1]        = '\0'; }
+  if (hmm->flags & p7H_MAP)  { hmm->map[0]       = 0; }
+  if (hmm->name == NULL)    ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No NAME found for HMM");
+  if (hmm->M    <= 0)       ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No LENG found for HMM (or LENG <= 0)");
+  if (abc       == NULL)    ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No ALPH found for HMM");
+
+  if (*ret_abc == NULL) *ret_abc = abc;
+  if ( opt_hmm != NULL) *opt_hmm = hmm; else p7_hmm_Destroy(hmm);
+  return eslOK;
+
+ ERROR:
+  if (*ret_abc == NULL && abc != NULL) esl_alphabet_Destroy(abc);
+  if (hmm     != NULL) p7_hmm_Destroy(hmm);
+  if (opt_hmm != NULL) *opt_hmm = NULL;
+  if      (status == eslEMEM || status == eslESYS) return status; 
+  else if (status == eslEOF)                       return status;
+  else if (status == eslEINCOMPAT)                 return status;
+  else                                             return eslEFORMAT;  /* anything else is a format error: includes premature EOF, EOL, EOD  */
+}
+
+
+static int
+read_bin30hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm)
+{
+  ESL_ALPHABET *abc = NULL;
+  P7_HMM       *hmm = NULL;
+  uint32_t      magic;
+  int           alphabet_type;
+  int           k;
+  off_t         offset = 0;
+  int           status;
+
+  hfp->errbuf[0] = '\0';
+  if (feof(hfp->f))                                             { status = eslEOF;       goto ERROR; }
+
+  if (hfp->newly_opened) 
+    {
+      offset = 0;
+      hfp->newly_opened = FALSE;
+    }
+  else
+    {  /* Check magic. */
+      if ((!hfp->do_stdin) && (! hfp->do_gzip)) {
+  if ((offset = ftello(hfp->f)) < 0)                          ESL_XEXCEPTION(eslESYS, "ftello() failed");
+      }
+      if (! fread((char *) &magic, sizeof(uint32_t), 1, hfp->f))    { status = eslEOF;       goto ERROR; }
+
+      if      (hfp->format == p7_HMMFILE_3f) { if (magic != v3f_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
+      else if (hfp->format == p7_HMMFILE_3e) { if (magic != v3e_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
+      else if (hfp->format == p7_HMMFILE_3d) { if (magic != v3d_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
+      else if (hfp->format == p7_HMMFILE_3c) { if (magic != v3c_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
+      else if (hfp->format == p7_HMMFILE_3b) { if (magic != v3b_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
+      else if (hfp->format == p7_HMMFILE_3a) { if (magic != v3a_magic)  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "bad magic number at start of HMM");  }
+      else                                                              ESL_XFAIL(eslEFORMAT, hfp->errbuf, "no such HMM file format code");      
+    }
+
+  /* Allocate shell of the new HMM. 
+   * Two-step allocation lets us read/set the flags first; 
+   * then the later CreateBody() call will allocate optional internal fields we need. 
+   */
+  if ((hmm = p7_hmm_CreateShell()) == NULL)                     ESL_XFAIL(eslEMEM, hfp->errbuf, "allocation failed, HMM shell");
+  hmm->offset = offset;
+
+  /* Get sizes of things */
+  /* xref J5/114 for a legacy use of <flags> for optional acc, desc annotation */
+  if (! fread((char *) &(hmm->flags),  sizeof(int), 1, hfp->f)) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read flags");
+  if (! fread((char *) &(hmm->M),      sizeof(int), 1, hfp->f)) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read model size M");
+  if (! fread((char *) &alphabet_type, sizeof(int), 1, hfp->f)) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read alphabet_type");
+  
+  /* Set or verify alphabet. */
+  if (*ret_abc == NULL)  {  /* still unknown: set it, pass control of it back to caller */
+    if ((abc = esl_alphabet_Create(alphabet_type)) == NULL)     ESL_XFAIL(eslEMEM, hfp->errbuf, "allocation failed, alphabet");
+  } else {      /* already known: check it */
+    abc = *ret_abc;
+    if (abc->type != alphabet_type)                             ESL_XFAIL(eslEINCOMPAT, hfp->errbuf, "Alphabet type mismatch: was %s, but current HMM says %s", esl_abc_DecodeType( abc->type), esl_abc_DecodeType(alphabet_type));
+  }
+
+  /* Finish the allocation of the HMM
+   */
+  if ((status = p7_hmm_CreateBody(hmm, hmm->M, abc)) != eslOK)  ESL_XFAIL(eslEMEM, hfp->errbuf, "allocation failed, HMM body");
+  
+  /* Core model probabilities. */
+  for (k = 1; k <= hmm->M; k++)
+    if (! fread((char *) hmm->mat[k], sizeof(float), hmm->abc->K,      hfp->f))  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read mat[%d]", k);
+  for (k = 0; k <= hmm->M; k++)
+    if (! fread((char *) hmm->ins[k], sizeof(float), hmm->abc->K,      hfp->f))  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read ins[%d]", k);
+  for (k = 0; k <= hmm->M; k++)
+    if (! fread((char *) hmm->t[k],   sizeof(float), p7H_NTRANSITIONS, hfp->f))  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read t[%d]", k);
+  
+  /* Annotations. */
+  if (read_bin_string(hfp->f, &(hmm->name)) != eslOK)                                                ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read name");
+  if ((hmm->flags & p7H_ACC)  && read_bin_string(hfp->f, &(hmm->acc))  != eslOK)                     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read acc");
+  if ((hmm->flags & p7H_DESC) && read_bin_string(hfp->f, &(hmm->desc)) != eslOK)                     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read desc");
+  if ((hmm->flags & p7H_RF)   && ! fread((char *) hmm->rf,        sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read rf");   /* +2: 1..M and trailing \0 */
+  if ((hmm->flags & p7H_MMASK)&& ! fread((char *) hmm->mm,        sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read mm");   /* +2: 1..M and trailing \0 */
+  if ((hmm->flags & p7H_CONS) && ! fread((char *) hmm->consensus, sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read consensus"); /* don't need to test for >=3e format, because the flag is sufficient (didn't exist pre-3e) */
+  if ((hmm->flags & p7H_CS)   && ! fread((char *) hmm->cs,        sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read cs");
+  if ((hmm->flags & p7H_CA)   && ! fread((char *) hmm->ca,        sizeof(char), hmm->M+2, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read ca");
+  if (read_bin_string(hfp->f, &(hmm->comlog)) != eslOK)                                              ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read comlog");
+  if (! fread((char *) &(hmm->nseq),       sizeof(int),   1, hfp->f))                                ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read nseq");
+  if (! fread((char *) &(hmm->eff_nseq),   sizeof(float), 1, hfp->f))                                ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read eff_nseq");
+  if (hfp->format >= p7_HMMFILE_3c) {
+    if (! fread((char *) &(hmm->max_length), sizeof(int),   1, hfp->f))                         ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read max_length");
+  }
+  if (read_bin_string(hfp->f, &(hmm->ctime))  != eslOK)                                       ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read ctime");
+  if ((hmm->flags & p7H_MAP)  && ! fread((char *) hmm->map, sizeof(int), hmm->M+1, hfp->f))   ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read map");
+  if (! fread((char *) &(hmm->checksum), sizeof(uint32_t),1,hfp->f))                          ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read checksum");
+
+  /* E-value parameters and Pfam cutoffs */
+  if (hfp->format >= p7_HMMFILE_3b) {
+    if (! fread((char *) hmm->evparam, sizeof(float), p7_NEVPARAM, hfp->f))                            ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read statistical params");
+  } else if (hfp->format == p7_HMMFILE_3a) {
+    /* a backward compatibility mode. 3/a files stored 3 floats: LAMBDA, MU, TAU. Read 3 #'s and carefully copy/rearrange them into new 6 format */
+    if (! fread((char *) hmm->evparam, sizeof(float), 3,           hfp->f))                            ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read statistical params");
+    hmm->evparam[p7_FLAMBDA] = hmm->evparam[0];
+    hmm->evparam[p7_FTAU]    = hmm->evparam[2];
+    hmm->evparam[p7_VLAMBDA] = hmm->evparam[0];
+    hmm->evparam[p7_VMU]     = hmm->evparam[1];
+    hmm->evparam[p7_MLAMBDA] = hmm->evparam[p7_VLAMBDA];
+    hmm->evparam[p7_MMU]     = hmm->evparam[p7_VMU];
+  }
+  if (! fread((char *) hmm->cutoff,  sizeof(float), p7_NCUTOFFS, hfp->f))                            ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read Pfam score cutoffs");
+  if ((hmm->flags & p7H_COMPO) && ! fread((char *) hmm->compo, sizeof(float), hmm->abc->K, hfp->f))  ESL_XFAIL(eslEFORMAT, hfp->errbuf, "failed to read model composition");
+
+  /* other legacy issues */
+  if (hfp->format < p7_HMMFILE_3e && (status = p7_hmm_SetConsensus(hmm, NULL)) != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Failed to set consensus on legacy HMM format");
+
+  if (*ret_abc == NULL) *ret_abc = abc;  /* pass our new alphabet back to caller, if caller didn't know it already */
+  if ( opt_hmm != NULL) *opt_hmm = hmm; else p7_hmm_Destroy(hmm);
+  return eslOK;
+  
+ ERROR:
+  if (*ret_abc == NULL && abc != NULL) esl_alphabet_Destroy(abc); /* the test is for an alphabet created here, not passed */
+  if (hmm     != NULL) p7_hmm_Destroy(hmm);
+  if (opt_hmm != NULL) *opt_hmm = NULL;
+  return status;
+}
+
+/* read_asc20hmm()
+ * Read a HMMER2.0 ASCII format HMM file, for backward compatibility
+ * SRE, Thu Dec 25 09:13:36 2008 [Magallon]
+ */
+static int
+read_asc20hmm(P7_HMMFILE *hfp, ESL_ALPHABET **ret_abc, P7_HMM **opt_hmm)
+{
+  ESL_ALPHABET *abc  = NULL;
+  P7_HMM       *hmm  = NULL;
+  P7_BG        *bg   = NULL;
+  char         *tag  = NULL;
+  char         *tok1 = NULL;
+  char         *tok2 = NULL;
+  char         *tok3 = NULL;
+  float         null[p7_MAXABET];
+  int           alphatype;
+  int           k,x;
+  off_t         offset = 0;
+  int           status;
+ 
+  hfp->errbuf[0] = '\0';
+
+  if (hfp->newly_opened)
+    {
+      offset            = 0;
+      hfp->newly_opened = FALSE;
+    }
+  else
+    {
+      /* Record where this HMM starts on disk */
+      if ((! hfp->do_stdin) && (! hfp->do_gzip) && (offset = ftello(hfp->f)) < 0)   ESL_XEXCEPTION(eslESYS, "ftello() failed");
+
+      /* First line of file: "HMMER2.0". Allocate shell for HMM annotation information (we don't know K,M yet) */
+      if ((status = esl_fileparser_NextLine(hfp->efp))                   != eslOK)  goto ERROR;  /* EOF here is normal; could also be a thrown EMEM */
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tag, NULL)) != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "unexpected absence of tokens on data line");
+      if (strcmp(tag, "HMMER2.0")                                        != 0)      ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Didn't find HMMER3/a tag: not a HMMER save file?");
+    }
+
+  if ((hmm = p7_hmm_CreateShell())                                       == NULL)   ESL_XFAIL(eslEMEM,    hfp->errbuf, "allocation failure, HMM shell");
+  hmm->offset = offset;
+
+  /* Header */
+  /* H2 save files have no EFFN; 
+   * COM lines don't have number tags like [1];
+   * they have CKSUM but we ignore it because it uses different algorithm;
+   * have EVD line, we ignore it, H3 stats are different;
+   * XT, NULT lines are ignored; algorithm-dependent config is all internal in H3
+   */
+  while ((status = esl_fileparser_NextLine(hfp->efp)) == eslOK)
+    {
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tag, NULL))     != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "Premature end of line");
+
+      if (strcmp(tag, "NAME") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No name found on NAME line");
+  p7_hmm_SetName(hmm, tok1);
+      } 
+
+      else if (strcmp(tag, "ACC") == 0)  {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No accession found on ACC line");
+  p7_hmm_SetAccession(hmm, tok1);
+      }  
+
+      else if (strcmp(tag, "DESC") == 0) {
+        /* #h106. Allow "DESC" bare, with nothing following. Looks like some SMART models circa 1998 are like this. */
+        if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1)) == eslOK) p7_hmm_SetDescription(hmm, tok1);
+      } 
+
+      else if (strcmp(tag, "LENG") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No model length found on LENG line");
+  if ((hmm->M = atoi(tok1))                                            == 0)     ESL_XFAIL(status,    hfp->errbuf, "Invalid model length %s on LENG line", tok1);
+      }  
+
+      else if (strcmp(tag, "ALPH") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))  != eslOK)   ESL_XFAIL(status,    hfp->errbuf, "No alphabet type found on ALPH");
+  /* Bug #h80: H2 tags DNA/RNA files as "Nucleic"; modern Easel/H3
+   * expects tag "DNA" or "RNA", so you can't pass tok1 to esl_abc_EncodeType().
+   */
+  if      (strcasecmp(tok1, "nucleic") == 0) alphatype = eslDNA;
+  else if (strcasecmp(tok1, "amino")   == 0) alphatype = eslAMINO;
+  else    ESL_XFAIL(status,    hfp->errbuf, "Unrecognized alphabet type %s", tok1);
+
+  if (*ret_abc == NULL) {
+    if ((abc = esl_alphabet_Create(alphatype))                        == NULL)    ESL_XFAIL(eslEMEM,   hfp->errbuf, "Failed to create alphabet");
+  } else {
+    if ((*ret_abc)->type != alphatype)                                           ESL_XFAIL(eslEINCOMPAT,hfp->errbuf,"Alphabet type mismatch: was %s, but current HMM says %s", esl_abc_DecodeType( (*ret_abc)->type), tok1);
+    abc = *ret_abc;
+  }
+      } 
+
+      else if (strcmp(tag, "RF") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,    hfp->errbuf, "No yes/no found for RF line");
+  if      (strcasecmp(tok1, "yes") == 0)
+    hmm->flags |= p7H_RF;
+  else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "RF header line must say yes/no, not %s", tok1);
+      } 
+
+      else if (strcmp(tag, "CS") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No yes/no found for CS line");
+  if (strcasecmp(tok1, "yes") == 0)
+    hmm->flags |= p7H_CS;
+  else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "CS header line must say yes/no, not %s", tok1);
+      } 
+
+      else if (strcmp(tag, "MAP") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No yes/no found for MAP line");
+  if      (strcasecmp(tok1, "yes") == 0)
+    hmm->flags |= p7H_MAP;
+  else if (strcasecmp(tok1, "no")  != 0)                                           ESL_XFAIL(eslEFORMAT, hfp->errbuf, "MAP header line must say yes/no, not %s", tok1);
+      } 
+
+      else if (strcmp(tag, "DATE") == 0) {
+  if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No date found on DATE line");
+  if (esl_strdup(tok1, -1, &(hmm->ctime))                               != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "strdup() failed to set date");
+      }
+
+      else if (strcmp(tag, "COM") == 0) {
+  /* in an H2 save file, there's no [1] number tags. The H3 format parser skips these */
+  if ((status = esl_fileparser_GetRemainingLine(hfp->efp, &tok1))       != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "No command on COM line");
+  if (hmm->comlog == NULL) {
+    if (esl_strdup(tok1, -1, &(hmm->comlog))                            != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strdup() failed");
+  } else {
+    if (esl_strcat(&(hmm->comlog), -1, "\n", -1)                        != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strcat() failed");
+    if (esl_strcat(&(hmm->comlog), -1, tok1,  -1)                       != eslOK)  ESL_XFAIL(eslEMEM,    hfp->errbuf, "esl_strcat() failed");
+  }
+      }
+      
+      else if (strcmp(tag, "NSEQ") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Nothing follows NSEQ tag");
+  if ((hmm->nseq = atoi(tok1)) == 0 && strcmp(tok1, "0") != 0)                     ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Invalid nseq on NSEQ line: should be integer, not %s", tok1);
+      }
+
+      else if (strcmp(tag, "GA") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on GA line");
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on GA line");
+  hmm->cutoff[p7_GA1] = atof(tok1);
+  hmm->cutoff[p7_GA2] = atof(tok2);
+  hmm->flags         |= p7H_GA;
+      }
+
+      else if (strcmp(tag, "TC") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on TC line");
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on TC line");
+    hmm->cutoff[p7_TC1] = atof(tok1);
+    hmm->cutoff[p7_TC2] = atof(tok2);
+    hmm->flags         |= p7H_TC;
+      }
+
+      else if (strcmp(tag, "NC") == 0) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on NC line");
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on NC line");
+    hmm->cutoff[p7_NC1] = atof(tok1);
+    hmm->cutoff[p7_NC2] = atof(tok2);
+    hmm->flags         |= p7H_NC;
+      }
+
+      else if (strcmp(tag, "NULE") == 0) {
+  if (abc->type == eslUNKNOWN) ESL_XFAIL(eslEFORMAT, hfp->errbuf, "ALPH must precede NULE in HMMER2 save files");
+  for (x = 0; x < abc->K; x++) {
+    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few fields on NULE line");
+    null[x] = h2ascii2prob(tok1, 1./(float)abc->K);
+  }
+      }
+
+      else if (strcmp(tag, "HMM") == 0) 
+  break;
+    } /* end, loop over possible header tags */
+  if (status != eslOK) goto ERROR;
+
+
+  /* Skip main model header lines; allocate body of HMM now that K,M are known */
+  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
+  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
+  if ((status = p7_hmm_CreateBody(hmm, hmm->M, abc))                          != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Failed to allocate body of the new HMM");
+  if ((    bg = p7_bg_Create(abc))                                            == NULL)   ESL_XFAIL(eslEMEM,    hfp->errbuf, "failed to create background model");
+
+  /* H2's tbd1 line ==> translated to H3's node 0 */
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))         != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok2, NULL))         != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok3, NULL))         != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data before main model section");
+  hmm->t[0][p7H_MM] = h2ascii2prob(tok1, 1.0);  /* B->M1 */
+  hmm->t[0][p7H_MI] = 0.0;                  /* B->I0 */
+  hmm->t[0][p7H_MD] = h2ascii2prob(tok3, 1.0);    /* B->D1 */
+  hmm->t[0][p7H_IM] = 1.0;
+  hmm->t[0][p7H_II] = 0.0;
+  hmm->t[0][p7H_DM] = 1.0;
+  hmm->t[0][p7H_DD] = 0.0;
+  for (x = 0; x < abc->K; x++) hmm->ins[0][x] = bg->f[x];
+
+  /* The main model section. */
+  for (k = 1; k <= hmm->M; k++)
+    {
+      if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model section, at node %d (expected %d)", k, hmm->M);
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model section, at node %d (expected %d)", k, hmm->M);
+      if (atoi(tok1) != k)                                                               ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Expected match line to start with %d (of %d); saw %s", k, hmm->M, tok1);
+      
+      /* Line 1: match emissions; optional map info */
+      for (x = 0; x < abc->K; x++) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few probability fields on match line, node %d: expected %d, got %d\n", k, abc->K, x);
+  hmm->mat[k][x] = h2ascii2prob(tok1, null[x]);
+      }
+      if (hmm->flags & p7H_MAP) {
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing MAP field on match line for node %d: should at least be -", k);
+  hmm->map[k] = atoi(tok1);
+      }
+
+      /* Line 2: optional RF; then we ignore insert emissions */
+      if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model: no insert emission line, node %d", k);
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing RF field on match line for node %d: should at least be -",  k);
+      if (hmm->flags & p7H_RF)     hmm->rf[k]     = *tok1;
+      for (x = 0; x < abc->K; x++) hmm->ins[k][x] = bg->f[x];
+
+      /* Line 3: optional CS, then transitions (ignoring last 2, which are entry/exit */
+      if ((status = esl_fileparser_NextLine(hfp->efp))                        != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data in main model: no transition line, node %d", k);
+      if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))     != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Missing CS field on match line for node %d: should at least be -",  k);
+      if (hmm->flags & p7H_CS) hmm->cs[k]   = *tok1;
+      if (k < hmm->M) {    /* ignore last insert transition line; H3/H2 not compatible there */
+  for (x = 0; x < p7H_NTRANSITIONS; x++) {
+    if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))   != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Too few probability fields on transition line, node %d: expected %d, got %d\n", k, abc->K, x);
+    hmm->t[k][x] = h2ascii2prob(tok1, 1.0);
+  }
+      }
+    }
+
+  /* node M transitions: H2 doesn't have an I_M state */
+  hmm->t[hmm->M][p7H_MM] = 1.0;
+  hmm->t[hmm->M][p7H_MI] = 0.0;
+  hmm->t[hmm->M][p7H_MD] = 0.0;
+  hmm->t[hmm->M][p7H_IM] = 1.0;
+  hmm->t[hmm->M][p7H_II] = 0.0;
+  hmm->t[hmm->M][p7H_DM] = 1.0;
+  hmm->t[hmm->M][p7H_DD] = 0.0;
+
+  /* The closing // */
+  if ((status = esl_fileparser_NextLine(hfp->efp))                            != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data: missing //?");
+  if ((status = esl_fileparser_GetTokenOnLine(hfp->efp, &tok1, NULL))         != eslOK)  ESL_XFAIL(status,     hfp->errbuf, "Premature end of data: missing //?");
+  if (strcmp(tok1, "//")                                                      != 0)      ESL_XFAIL(eslEFORMAT, hfp->errbuf, "Expected closing //; found %s instead", tok1);
+
+  /* Tidy up. */
+  if (hmm->flags & p7H_RF)  { hmm->rf[0] = ' '; hmm->rf[hmm->M+1] = '\0'; }
+  if (hmm->flags & p7H_CS)  { hmm->cs[0] = ' '; hmm->cs[hmm->M+1] = '\0'; }
+  if (hmm->name == NULL)    ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No NAME found for HMM");
+  if (hmm->M    <= 0)       ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No LENG found for HMM (or LENG <= 0)");
+  if (abc       == NULL)    ESL_XFAIL(eslEFORMAT, hfp->errbuf, "No ALPH found for HMM");
+
+  /* Part of #h106 fix: */
+  if ((status = p7_hmm_Renormalize(hmm)) != eslOK) return status;
+
+  /* legacy issues */
+  if (( status = p7_hmm_SetConsensus(hmm, NULL)) != eslOK) ESL_XFAIL(status, hfp->errbuf, "Failed to create consensus line");
+
+  /* Calibrate the model:         cfg   rng   bg    gm    om */
+  if ((status = p7_Calibrate(hmm, NULL, NULL, &bg, NULL, NULL)) != eslOK) ESL_XFAIL(status, hfp->errbuf, "Failed to calibrate HMMER2 model after input conversion");
+
+  if (*ret_abc == NULL) *ret_abc = abc;
+  if ( opt_hmm != NULL) *opt_hmm = hmm; else p7_hmm_Destroy(hmm);
+  p7_bg_Destroy(bg);
+  return eslOK;
+
+ ERROR:
+  if (*ret_abc == NULL && abc != NULL) esl_alphabet_Destroy(abc);
+  if (hmm     != NULL) p7_hmm_Destroy(hmm);
+  if (bg      != NULL) p7_bg_Destroy(bg);
+  if (opt_hmm != NULL) *opt_hmm = NULL;
+  if      (status == eslEMEM || status == eslESYS) return status; 
+  else if (status == eslEOF)                       return status;
+  else if (status == eslEINCOMPAT)                 return status;
+  else                                             return eslEFORMAT;  /* anything else is a format error: includes premature EOF, EOL, EOD  */
+}
+/*--------------- end, private format parsers -------------------*/
+
+
+
+
+
+/*****************************************************************
+ * 5. Other private functions involved in i/o
+ *****************************************************************/
+
+
+/* multiline()
+ * 
+ * Used to print the command log to ASCII save files.
+ *
+ * Given a record (like the comlog) that contains 
+ * multiple lines, print it as multiple lines with
+ * a given prefix. e.g.:
+ *           
+ * given:   "COM   ", "foo\nbar\nbaz"
+ * print:   COM   1 foo
+ *          COM   2 bar
+ *          COM   3 baz
+ *
+ * If <s> is NULL, no-op. Otherwise <s> must be a <NUL>-terminated
+ * string.  It does not matter if it ends in <\n> or not. <pfx>
+ * must be a valid <NUL>-terminated string; it may be empty.
+ *           
+ * Args:     fp:   FILE to print to
+ *           pfx:  prefix for each line
+ *           s:    line to break up and print; tolerates a NULL
+ *
+ * Returns: <eslOK> on success.
+ *
+ * Throws:  <eslEWRITE> on write error.
+ */
+static int
+multiline(FILE *fp, const char *pfx, char *s)
+{
+  char *sptr  = s;
+  char *end   = NULL;
+  int   n     = 0;
+  int   nline = 1;
+
+  do {
+    end = strchr(sptr, '\n');
+
+    if (end != NULL)                  /* if there's no \n left, end == NULL */
+      {
+  n = end - sptr;                       /* n chars exclusive of \n */
+  if (fprintf(fp, "%s [%d] ", pfx, nline++) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");
+  if (fwrite(sptr, sizeof(char), n, fp)    != n) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");  /* using fwrite lets us write fixed # of chars   */
+  if (fprintf(fp, "\n")                     < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed");  /* while writing \n w/ printf allows newline conversion */
+  sptr += n + 1;                       /* +1 to get past \n */
+      } 
+    else 
+      {
+  if (fprintf(fp, "%s [%d] %s\n", pfx, nline++, sptr) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); /* last line */
+      }
+  } while (end != NULL  && *sptr != '\0');   /* *sptr == 0 if <s> terminates with a \n */
+  return eslOK;
+}
+
+/* multilineString()
+ *
+ * Used to print the command log to a string.
+ *
+ * Given a record (like the comlog) that contains
+ * multiple lines, print it as multiple lines with
+ * a given prefix. e.g.:
+ *
+ * given:   "COM   ", "foo\nbar\nbaz"
+ * print:   COM   1 foo
+ *          COM   2 bar
+ *          COM   3 baz
+ *
+ * If <s> is NULL, no-op. Otherwise <s> must be a <NUL>-terminated
+ * string.  It does not matter if it ends in <\n> or not. <pfx>
+ * must be a valid <NUL>-terminated string; it may be empty.
+ *
+ * Args:     ret_char: char pointer pointer
+ *           pfx:  prefix for each line
+ *           s:    line to break up and print; tolerates a NULL
+ *           coffset: the current write position in the string (pointer so we can add to it).
+ *
+ * Returns: <eslOK> on success or <eslEWRITE> on error.
+ *
+ */
+static int
+multilineString(char **ret_str, const char *pfx, char *s, int *coffset){
+  char *sptr  = s;
+  char *end   = NULL;
+  int   n     = 0;
+  int   nline = 1;
+  int   offset;
+
+  do {
+    end = strchr(sptr, '\n');
+    if (end != NULL) {                  /* if there's no \n left, end == NULL */
+      n = end - sptr;                       /* n chars exclusive of \n */
+      if ((offset = sprintf(*ret_str + *coffset, "%s [%d] ", pfx, nline++)) < 0) return eslEWRITE;
+      *coffset += offset;
+
+      strncpy(*ret_str + *coffset, sptr, sizeof(char) * n); /* using strncpy lets us write fixed # of chars   */
+      *coffset +=n;
+      if ((offset = sprintf(*ret_str + *coffset, "\n"))        < 0)              return eslEWRITE;
+      sptr += n + 1;                       /* +1 to get past \n */
+    } else {
+      if ((offset = sprintf(*ret_str + *coffset, "%s [%d] %s\n", pfx, nline++, sptr)) < 0) return eslEWRITE;
+      *coffset += offset;
+    }
+  } while (end != NULL  && *sptr != '\0');   /* *sptr == 0 if <s> terminates with a \n */
+  return eslOK;
+}
+
+
+
+static int
+printprob(FILE *fp, int fieldwidth, float p)
+{
+  if      (p == 0.0) { if (fprintf(fp, " %*s",   fieldwidth, "*")      < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  else if (p == 1.0) { if (fprintf(fp, " %*.5f", fieldwidth, 0.0)      < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  else               { if (fprintf(fp, " %*.5f", fieldwidth, -logf(p)) < 0) ESL_EXCEPTION_SYS(eslEWRITE, "hmm write failed"); }
+  return eslOK;
+}
+
+/* probToString
+ *
+ * Used to print probabilities floats in a fixed field to a char. Based on printprob.
+ *
+ *
+ * given :   4.115212345633
+ * append:   " 4.11521"
+ *
+ *
+ * If p is 0.0 or 1.0, append * or 0.00000
+ *
+ * Args:     str:         (pointer to pointer)
+ *           fieldwidth:  The size of the number to be printed. Note, a space is
+ *                        prepended
+ *           p:           float
+ *           offset:      currnet position in the strng
+ *
+ * Returns: <eslOK> on success or <eslEWRITE> on error.
+ */
+
+static int
+probToString(char **str , int fieldwidth, float p, int offset)
+{
+  if      (p == 0.0) { if (sprintf(*str+offset, " %*s",   fieldwidth, "*")      < 0) return( eslEWRITE ); }
+  else if (p == 1.0) { if (sprintf(*str+offset, " %*.5f", fieldwidth, 0.0)      < 0) return( eslEWRITE ); }
+  else               { if (sprintf(*str+offset, " %*.5f", fieldwidth, -logf(p)) < 0) return( eslEWRITE ); }
+  return eslOK;
+}
+
+/* Function: write_bin_string()
+ * 
+ * Purpose:  Write a string in binary save format: an integer
+ *           for the string length (including \0), followed by
+ *           the string.
+ *           
+ * Return:   <eslOK> on success;
+ * 
+ * Throw:    <eslEWRITE> on write error, such as a filled disk.
+ */
+static int
+write_bin_string(FILE *fp, char *s)
+{
+  int len;
+  if (s != NULL) 
+    {
+      len = strlen(s) + 1;
+      if (fwrite((char *) &len, sizeof(int),  1,   fp) != 1)   ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+      if (fwrite((char *) s,    sizeof(char), len, fp) != len) ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+    }
+  else
+    {
+      len = 0;
+      if (fwrite((char *) &len, sizeof(int), 1, fp) != 1)      ESL_EXCEPTION_SYS(eslEWRITE, "hmm binary write failed");
+    }
+  return eslOK;
+}
+
+/* Function: read_bin_string()
+ * 
+ * Purpose:  Read in a string from a binary file, where
+ *           the first integer is the length (including '\0').
+ *           If the length is 0, <*ret_s> is set to <NULL>.
+ *
+ *           This is a reasonable convention for storing/ reading
+ *           strings in binary files. Note that because the length is
+ *           inclusive of '\0', there's a difference between a NULL
+ *           string and an empty string.
+ *           
+ * Args:     fp       - FILE to read from
+ *           ret_s    - string to read into
+ *                             
+ * Return:   <eslOK> on success. ret_s is malloc'ed here.
+ *           <eslEOD> if a read fails - likely because no more
+ *             data in file.
+ * 
+ * Throws    <eslEMEM> on allocation error.
+ */                            
+static int
+read_bin_string(FILE *fp, char **ret_s)
+{
+  int   status;
+  char *s = NULL;
+  int   len;
+
+  if (! fread((char *) &len, sizeof(int), 1, fp)) { status = eslEOD; goto ERROR; }
+  if (len > 0) {
+    ESL_ALLOC(s,  (sizeof(char) * len));
+    if (! fread((char *) s, sizeof(char), len, fp)) { status = eslEOD; goto ERROR; }
+  }
+  *ret_s = s;
+  return eslOK;
+
+ ERROR:
+  if (s != NULL) free(s);
+  *ret_s = NULL;
+  return status;
+}
+
+static float
+h2ascii2prob(char *s, float null)
+{
+  return ((*s == '*') ? 0. : null * exp( atoi(s) * 0.00069314718));
+}
+/*---------------- end, private utilities -----------------------*/
+
+
+
+/*****************************************************************
+ * 6. Benchmark driver.
+ *****************************************************************/
+#ifdef p7HMMFILE_BENCHMARK
+/*
+  icc  -O3 -static -o p7_hmmfile_benchmark -I. -L. -I../easel -L../easel -Dp7HMMFILE_BENCHMARK p7_hmmfile.c -lhmmer -leasel -lm 
+  ./p7_hmmfile_benchmark Pfam.hmm
+ */
+#include "p7_config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "easel.h"
+#include "esl_getopts.h"
+#include "esl_stopwatch.h"
+
+#include "hmmer.h"
+
+static ESL_OPTIONS options[] = {
+  /* name           type      default  env  range toggles reqs incomp  help                                  docgroup*/
+  { "-h",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "show brief help on version and usage",  0 },
+  { "-a",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "include time of profile configuration", 0 }, 
+  { "-v",        eslARG_NONE,   FALSE, NULL, NULL,  NULL,  NULL, NULL, "verbose: print model info as they're read", 0 }, 
+  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+};
+static char usage[]  = "[-options] <HMM file>";
+static char banner[] = "benchmark driver for HMM input";
+
+int 
+main(int argc, char **argv)
+{
+  ESL_GETOPTS   *go      = p7_CreateDefaultApp(options, 1, argc, argv, banner, usage);
+  ESL_STOPWATCH *w       = esl_stopwatch_Create();
+  ESL_ALPHABET  *abc     = NULL;
+  char          *hmmfile = esl_opt_GetArg(go, 1);
+  P7_HMMFILE    *hfp     = NULL;
+  P7_HMM        *hmm     = NULL;
+  P7_BG         *bg      = NULL;
+  P7_PROFILE    *gm      = NULL;
+  P7_OPROFILE   *om      = NULL;
+  int            nmodel  = 0;
+  uint64_t       totM    = 0;
+  int            status;
+  char           errbuf[eslERRBUFSIZE];
+
+  esl_stopwatch_Start(w);
+
+  status = p7_hmmfile_OpenE(hmmfile, NULL, &hfp, errbuf);
+  if      (status == eslENOTFOUND) p7_Fail("File existence/permissions problem in trying to open HMM file %s.\n%s\n", hmmfile, errbuf);
+  else if (status == eslEFORMAT)   p7_Fail("File format problem in trying to open HMM file %s.\n%s\n",                hmmfile, errbuf);
+  else if (status != eslOK)        p7_Fail("Unexpected error %d in opening HMM file %s.\n%s\n",               status, hmmfile, errbuf);  
+
+  while ((status = p7_hmmfile_Read(hfp, &abc, &hmm)) == eslOK)
+    {
+      if (nmodel == 0) {   /* first time initialization, now that alphabet known */
+  bg = p7_bg_Create(abc);
+  p7_bg_SetLength(bg, 400);
+      }
+
+      if (esl_opt_GetBoolean(go, "-v")) printf("%s\n", hmm->name);
+      nmodel++;
+      totM += hmm->M;
+
+      if (esl_opt_GetBoolean(go, "-a") == TRUE) 
+  {
+    gm = p7_profile_Create(hmm->M, abc);
+    p7_ProfileConfig(hmm, bg, gm, 400, p7_LOCAL);
+    om = p7_oprofile_Create(gm->M, abc);
+    p7_oprofile_Convert(gm, om);
+    p7_oprofile_ReconfigLength(om, 400);
+
+    p7_profile_Destroy(gm);
+    p7_oprofile_Destroy(om);
+  }
+
+      p7_hmm_Destroy(hmm);
+    }
+  if      (status == eslEFORMAT)   p7_Fail("bad file format in HMM file %s",             hmmfile);
+  else if (status == eslEINCOMPAT) p7_Fail("HMM file %s contains different alphabets",   hmmfile);
+  else if (status != eslEOF)       p7_Fail("Unexpected error in reading HMMs from %s",   hmmfile);
+
+  esl_stopwatch_Stop(w);
+  esl_stopwatch_Display(stdout, w, "# CPU time: ");
+  printf("# number of models: %d\n", nmodel);
+  printf("# total M:          %" PRId64 "\n", totM);
+  
+  p7_bg_Destroy(bg);
+  p7_hmmfile_Close(hfp);
+  esl_alphabet_Destroy(abc);
+  esl_stopwatch_Destroy(w);
+  esl_getopts_Destroy(go);
+  return 0;
+}
+#endif /*p7HMMFILE_BENCHMARK*/
+/*---------------- end, benchmark driver ------------------------*/
+
+
+/*****************************************************************
+ * 7. Unit tests.
+ *****************************************************************/
+#ifdef p7HMMFILE_TESTDRIVE
+
+/* utest_io_30: tests read/write for 3.0 save files.
+ *              Caller provides a named tmpfile that we can
+ *              open, write to, close, reopen, then read from.
+ *              <format> can be -1 or any specified 3.x save
+ *              file format.
+ *              Caller also provides a test HMM, which might
+ *              be a nasty random-sampled HMM.
+ */
+static int
+utest_io_30(char *tmpfile, int format, P7_HMM *hmm)
+{
+  FILE         *fp     = NULL;
+  P7_HMMFILE   *hfp    = NULL;
+  P7_HMM       *new    = NULL;
+  ESL_ALPHABET *newabc = NULL;
+  char          msg[] = "3.0 file i/o unit test failed";
+  
+  /* Write the HMM to disk as ASCII */
+  if ((fp = fopen(tmpfile, "w"))              == NULL)  esl_fatal(msg);
+  if (p7_hmmfile_WriteASCII(fp, format, hmm)  != eslOK) esl_fatal(msg);
+  fclose(fp);
+  
+  /* Read it back */
+  if (p7_hmmfile_OpenE(tmpfile, NULL, &hfp, NULL) != eslOK)  esl_fatal(msg);
+  if (p7_hmmfile_Read(hfp, &newabc, &new)         != eslOK)  esl_fatal(msg);
+  
+  /* It should have determined the right file format */
+  if (format == -1) { if (hfp->format != p7_HMMFILE_3f) esl_fatal(msg); }
+  else              { if (hfp->format != format)        esl_fatal(msg); } 
+
+  /* It should be identical to what we started with, modulo some legacy format issues */
+  if (format < p7_HMMFILE_3e) { strcpy(new->consensus, hmm->consensus); }
+  if (p7_hmm_Compare(hmm, new, 0.0001)     != eslOK) esl_fatal(msg);
+  p7_hmm_Destroy(new);
+
+  /* Trying to read one more HMM should give us a normal EOF */
+  if (p7_hmmfile_Read(hfp, &newabc, &new)         != eslEOF) esl_fatal(msg);
+  p7_hmmfile_Close(hfp);
+
+  /* Do it all again, but with binary format */
+  if ((fp = fopen(tmpfile, "w"))                  == NULL)   esl_fatal(msg);
+  if (p7_hmmfile_WriteBinary(fp, format, hmm)     != eslOK)  esl_fatal(msg);
+  fclose(fp);
+  if (p7_hmmfile_OpenE(tmpfile, NULL, &hfp, NULL) != eslOK)  esl_fatal(msg);
+  if (p7_hmmfile_Read(hfp, &newabc, &new)         != eslOK)  esl_fatal(msg);
+  if (format < p7_HMMFILE_3e) { strcpy(new->consensus, hmm->consensus); }
+  if (p7_hmm_Compare(hmm, new, 0.0001)            != eslOK)  esl_fatal(msg);
+
+  if (format == -1) { if (hfp->format != p7_HMMFILE_3f)      esl_fatal(msg); }
+  else              { if (hfp->format != format)             esl_fatal(msg); } 
+
+  p7_hmm_Destroy(new);
+  p7_hmmfile_Close(hfp);
+
+  esl_alphabet_Destroy(newabc);
+  return eslOK;
+}
+
+
+/* Test current (3/e) file formats */
+static int
+utest_io_current(char *tmpfile, P7_HMM *hmm)
+{
+  /* Try to break the 32-bit unsigned checksum, setting high order bit */
+  hmm->checksum = 0xffeeddcc;
+  hmm->flags |= p7H_CHKSUM;
+
+  utest_io_30(tmpfile, -1, hmm);
+  return eslOK;
+}
+
+
+/* Test compatibility mode for 3/a file formats */
+static int
+utest_io_3a(char *tmpfile, P7_HMM *hmm)
+{
+  float oldparam[p7_NEVPARAM];
+
+  /* Try to break the 32-bit unsigned checksum, setting high order bit */
+  hmm->checksum = 0xffeeddcc;
+  hmm->flags |= p7H_CHKSUM;
+
+  /* Make a copy of the old statistics. 
+   * Rearrange stats params to satisfy 3/a's constraints: vmu=mmu, mlambda=vlambda=flambda 
+   */
+  esl_vec_FCopy(hmm->evparam, p7_NEVPARAM, oldparam);
+  hmm->evparam[p7_VMU]     = hmm->evparam[p7_MMU];
+  hmm->evparam[p7_VLAMBDA] = hmm->evparam[p7_MLAMBDA];
+  hmm->evparam[p7_FLAMBDA] = hmm->evparam[p7_MLAMBDA];
+
+  utest_io_30(tmpfile, p7_HMMFILE_3a, hmm);
+  
+  /* Restore the original statistics */
+  esl_vec_FCopy(oldparam, p7_NEVPARAM, hmm->evparam);
+  return eslOK;
+}
+
+#endif /*p7HMMFILE_TESTDRIVE*/
+/*-------------------- end, unit tests --------------------------*/
+
+
+
+
+/*****************************************************************
+ * 8. Test driver.
+ *****************************************************************/
+
+#ifdef p7HMMFILE_TESTDRIVE
+/* gcc -g -Wall -Dp7HMMFILE_TESTDRIVE -I. -I../easel -L. -L../easel -o p7_hmmfile_test p7_hmmfile.c -lhmmer -leasel -lm
+ */
+#include "p7_config.h"
+
+#include "easel.h"
+#include "esl_alphabet.h"
+#include "esl_random.h"
+
+#include "hmmer.h"
+
+int
+main(int argc, char **argv)
+{
+  ESL_RANDOMNESS *r    = NULL;
+  ESL_ALPHABET *aa_abc = NULL,
+               *nt_abc = NULL;
+  P7_HMM       *hmm    = NULL;
+  FILE         *fp     = NULL;
+  char tmpfile[32]     = "tmp-hmmerXXXXXX";
+  int           M      = 20;
+  
+  if ((aa_abc = esl_alphabet_Create(eslAMINO)) == NULL)  esl_fatal("failed to create amino alphabet");
+  if ((nt_abc = esl_alphabet_Create(eslDNA))   == NULL)  esl_fatal("failed to create DNA alphabet");
+  if ((r      = esl_randomness_CreateFast(0))  == NULL)  esl_fatal("failed to create randomness");
+  if ((esl_tmpfile_named(tmpfile, &fp))        != eslOK) esl_fatal("failed to create tmp file");
+  fclose(fp);
+
+  /* Protein HMMs */
+  p7_hmm_Sample(r, M, aa_abc, &hmm);
+  utest_io_current(tmpfile, hmm);
+  utest_io_3a     (tmpfile, hmm);
+  p7_hmm_Destroy(hmm);
+
+  /* Nucleic acid HMMs */
+  p7_hmm_Sample(r, M, nt_abc, &hmm);
+  utest_io_current(tmpfile, hmm);
+  utest_io_3a     (tmpfile, hmm);
+  p7_hmm_Destroy(hmm);
+
+  esl_alphabet_Destroy(aa_abc);
+  esl_alphabet_Destroy(nt_abc);
+  esl_randomness_Destroy(r);
+  remove(tmpfile);
+  exit(0);
+}
+#endif /*p7HMMFILE_TESTDRIVE*/
+/*-------------------- end, test driver -------------------------*/
+
+
+/*****************************************************************
+ * 9. Example.
+ *****************************************************************/
+/* On using the example to test error messages from p7_hmmfile_OpenE():
+ *    Message
+ *  --------------
+ *  .gz file missing/not readable     \rm test.hmm.gz; touch test.hmm.gz; src/p7_hmmfile_example test.hmm.gz
+ *  gzip -dc doesn't exist            \cp testsuite/20aa.hmm test.hmm; gzip test.hmm; sudo mv /usr/bin/gzip /usr/bin/gzip.old; src/p7_hmmfile_example test.hmm.gz
+ *  hmm file not found                \rm test.hmm; src/p7_hmmfile_example test.hmm
+ *  bad SSI file format               \cp testsuite/20aa.hmm test.hmm; \rm test.hmm.ssi; touch test.hmm.ssi; src/p7_hmmfile_example test.hmm
+ *  64-bit SSI on 32-bit sys
+ *  empty file                        \rm test.hmm; touch test.hmm
+ *  unrecognized format (binary)      cat testsuite/20aa.hmm > test.hmm; src/hmmpress test.hmm; \rm test.hmm; [edit test.hmm.h3m, delete first byte]
+ *  unrecognized format (ascii)       cat testsuite/20aa.hmm | sed -e 's/^HMMER3\/b/HMMER3\/x/' > test.hmm
+ *  
+ */
+
+#ifdef p7HMMFILE_EXAMPLE
+/* gcc -g -Wall -Dp7HMMFILE_EXAMPLE -I. -I../easel -L. -L../easel -o p7_hmmfile_example p7_hmmfile.c -lhmmer -leasel -lm
+ */
+#include "p7_config.h"
+
+#include "easel.h"
+#include "esl_alphabet.h"
+
+#include "hmmer.h"
+
+int
+main(int argc, char **argv)
+{
+  char         *hmmfile = argv[1];
+  P7_HMMFILE   *hfp     = NULL;
+  P7_HMM       *hmm     = NULL;
+  ESL_ALPHABET *abc     = NULL;
+  char          errbuf[eslERRBUFSIZE];
+  int           status;
+  
+  /* An example of reading a single HMM from a file, and checking that it is the only one. */
+  status = p7_hmmfile_OpenE(hmmfile, NULL, &hfp, errbuf);
+  if      (status == eslENOTFOUND) p7_Fail("File existence/permissions problem in trying to open HMM file %s.\n%s\n", hmmfile, errbuf);
+  else if (status == eslEFORMAT)   p7_Fail("File format problem in trying to open HMM file %s.\n%s\n",                hmmfile, errbuf);
+  else if (status != eslOK)        p7_Fail("Unexpected error %d in opening HMM file %s.\n%s\n",               status, hmmfile, errbuf);  
+
+  status = p7_hmmfile_Read(hfp, &abc, &hmm);
+  if      (status == eslEFORMAT)   p7_Fail("Bad file format in HMM file %s:\n%s\n",          hfp->fname, hfp->errbuf);
+  else if (status == eslEINCOMPAT) p7_Fail("HMM in %s is not in the expected %s alphabet\n", hfp->fname, esl_abc_DecodeType(abc->type));
+  else if (status == eslEOF)       p7_Fail("Empty HMM file %s? No HMM data found.\n",        hfp->fname);
+  else if (status != eslOK)        p7_Fail("Unexpected error in reading HMMs from %s\n",     hfp->fname);
+
+  status = p7_hmmfile_Read(hfp, &abc, NULL);
+  if (status != eslEOF)            p7_Fail("HMM file %s does not contain just one HMM\n", hfp->fname);
+
+  p7_hmmfile_Close(hfp);
+
+  p7_hmmfile_WriteASCII(stdout, -1, hmm);
+
+  esl_alphabet_Destroy(abc);
+  p7_hmm_Destroy(hmm);
+  return 0;
+}
+#endif /*p7HMMFILE_EXAMPLE*/
+/*----------------------- end, example --------------------------*/
+
+
